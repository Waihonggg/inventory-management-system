<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory Management System</title>
    <style>
        /* General Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Body Styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333; /* Default text color for better contrast on white backgrounds */
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border-radius: 15px;
        }

        /* Headings */
        h1 {
            color: #2c3e50;
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        /* Tabs Navigation */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 2px solid #ecf0f1;
            overflow-x: auto;
            gap: 2px;
        }

        .tab {
            padding: 15px 20px;
            cursor: pointer;
            background-color: transparent;
            border-radius: 10px 10px 0 0;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 11px;
            transition: all 0.3s ease;
            white-space: nowrap;
            color: #7f8c8d;
            min-width: 120px;
            text-align: center;
            border: 2px solid transparent;
            border-bottom: none;
        }

        .tab:hover {
            background-color: #f8f9fa;
            color: #2c3e50;
            border-color: #e1e8ed;
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateY(-2px);
            border-color: #667eea; /* Match gradient start */
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Stats Cards for Dashboard */
        .stats-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.4);
        }

        .stat-card.urgent {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
         .stat-card.urgent:hover {
            box-shadow: 0 15px 35px rgba(231, 76, 60, 0.4);
        }

        .stat-card.warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        .stat-card.warning:hover {
            box-shadow: 0 15px 35px rgba(243, 156, 18, 0.4);
        }

        .stat-card.info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }
         .stat-card.info:hover {
            box-shadow: 0 15px 35px rgba(52, 152, 219, 0.4);
        }
        .stat-card.toclear-card { /* Custom style for To Clear card if needed, or use existing */
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); /* Example: Purple */
        }
        .stat-card.toclear-card:hover {
            box-shadow: 0 15px 35px rgba(155, 89, 182, 0.4);
        }
        .stat-card.staff-claim-card {
    background: linear-gradient(135deg, #16a085 0%, #1abc9c 100%);
}
.stat-card.staff-claim-card:hover {
    box-shadow: 0 15px 35px rgba(22, 160, 133, 0.4);
}


        .stat-number {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 10px;
            line-height: 1;
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Controls (Buttons, Search) */
        .controls {
            margin: 20px 0; /* Keep vertical margin */
            display: flex;
            justify-content: space-between;
            align-items: flex-start; 
            flex-wrap: wrap;
            gap: 15px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e1e8ed;
        }
         .controls > * { 
            flex-shrink: 0;
        }


        /* Table Styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 25px; /* Increased margin for spacing */
            background: white;
            border-radius: 10px;
            overflow: hidden; /* Important for border-radius on table */
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }

        th, td {
            padding: 14px; /* Increased padding for more space */
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
            vertical-align: middle; /* Better vertical alignment */
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.6px; /* Slightly increased letter spacing */
            font-size: 12px;
            cursor: pointer; 
        }
        th .sort-arrow { 
            font-size: 0.8em;
            margin-left: 5px;
        }
        
        /* Zebra striping for table body rows */
        tbody tr:nth-child(even) {
            background-color: #f9f9fc; /* Very light purple/grey */
        }

        tbody tr:hover {
            background-color: #f1f3f5; /* Slightly darker hover for better feedback */
        }

        /* Right-align specific numeric columns */
        #inventory-table td:nth-child(4), /* Quantity */
        #new-products-table td:nth-child(6), /* Quantity */
        #to-clear-table td:nth-child(6), /* Initial Bal */ /* Adjusted index due to category removal */
        #to-clear-table td:nth-child(7), /* WH Qty */
        #to-clear-table td:nth-child(8), /* Store Qty */
        #to-clear-table td:nth-child(9), /* Total Qty */
        #to-clear-table td:nth-child(10), /* Weekly Demand */
        #to-clear-table td:nth-child(11), /* Weeks Supply */
        #master-table td:nth-child(4), /* WK Demand */ /* Adjusted index due to category->wkDemand */
        #master-table td:nth-child(6)  /* Price */
        {
            text-align: right;
            font-variant-numeric: tabular-nums; /* Helps align numbers if using proportional fonts */
        }


        /* Status Badges */
        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px; /* Slightly smaller for compactness */
            font-weight: bold;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-block;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .oos {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .low {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .normal {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }

        .danger-status {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .alert-status {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        /* General Buttons */
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 11px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }
         .btn-success:hover {
            box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4);
        }


        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        .btn-danger:hover {
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }

        .btn-info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }
         .btn-info:hover {
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .btn-warning {
             background: linear-gradient(135deg, #f39c12, #e67e22);
        }
        .btn-warning:hover {
             box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }


        /* Refined styles for buttons within table cells */
        td button {
            padding: 7px 10px;   /* Reduced padding for compactness */
            font-size: 10px;    /* Smaller font for text like "Edit", "Delete" */
            letter-spacing: 0.3px; /* Adjust letter spacing for smaller font */
            border-radius: 18px; /* Keep pill shape, but ensure it's compact */
            margin: 2px;         /* Spacing between buttons in a cell */
        }


        /* Search Box */
        .search-box {
            padding: 12px 16px;
            width: 280px;
            border: 2px solid #e1e8ed;
            border-radius: 25px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%237f8c8d' class='bi bi-search' viewBox='0 0 16 16'%3E%3Cpath d='M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z'/%3E%3C/svg%3E") no-repeat 12px center; /* Added search icon */
            padding-left: 35px; /* Space for the icon */
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .search-box:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2); /* Slightly more visible focus */
        }

        /* Modal Styling */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: none;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        /* Add this after the existing form-group input styles */
/* Clear button styling - NEW */
.clear-btn {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    background: #f8f9fa;
    border: 1px solid #e1e8ed;
    color: #666;
    cursor: pointer;
    font-size: 14px;
    padding: 4px 8px;
    width: auto;
    height: auto;
    border-radius: 4px;
    z-index: 10;
    font-weight: bold;
    line-height: 1;
    min-width: 24px;
    display: none;
}

.clear-btn:hover {
    background: #e9ecef;
    color: #e74c3c;
    border-color: #e74c3c;
}

.input-with-clear {
    position: relative;
    display: flex;
    align-items: center;
}

.input-with-clear input {
    padding-right: 40px !important;
}
        
        .close:hover {
            color: #e74c3c;
        }

        /* Form Group */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        .form-group input:disabled, .form-group select:disabled, .form-group textarea:disabled {
            background-color: #f0f0f0;
            opacity: 0.7;
            cursor: not-allowed;
        }
        .form-group label.disabled-label {
            opacity: 0.5;
        }


        /* Alert Notifications */
        .alert {
            padding: 15px 20px; /* More padding */
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 600;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            max-width: 320px; /* Slightly wider */
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* Stronger shadow */
            border-left-width: 5px; /* Accent border */
            border-left-style: solid;
        }

        .alert-success {
            background-color: #e6f7ed; /* Lighter green */
            color: #0f5132; /* Darker text for contrast */
            border-color: #27ae60; /* Accent color */
        }

        .alert-error {
            background-color: #fbe9e7; /* Lighter red */
            color: #842029; /* Darker text */
            border-color: #e74c3c; /* Accent color */
        }
        .alert-info {
            background-color: #e7f3fe;
            color: #0c5460;
            border-color: #3498db;
        }
        .alert-warning {
             background-color: #fff8e1;
             color: #856404;
             border-color: #f39c12;
        }

        /* Confirmation Modal Specific Styles */
        #confirmModal .modal-content {
            text-align: center;
            padding: 40px;
            max-width: 450px;
        }

        #confirmModal .modal-content h2 {
            margin-bottom: 20px;
            color: #333;
        }

        #confirmModal .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
        }

        #confirmModal .modal-buttons button {
            flex: 1;
            max-width: 150px;
            padding: 12px 25px;
            font-size: 14px;
        }

        /* --- Mobile Responsiveness --- */
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
                border-radius: 10px;
            }

            h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 1rem;
                margin-bottom: 20px;
            }

            .tabs {
                flex-wrap: wrap; 
                justify-content: center; 
                border-bottom: none; 
            }

            .tab {
                min-width: unset; 
                flex: 1 1 auto; 
                padding: 10px 15px;
                font-size: 10px;
                border-bottom: 2px solid #ecf0f1; 
            }

            .tab.active {
                transform: none; 
                box-shadow: none; 
                border-bottom: 2px solid #667eea;
            }

            .stats-cards {
                grid-template-columns: 1fr; 
            }

            .stat-card {
                padding: 20px;
            }

            .stat-number {
                font-size: 2.5rem;
            }

            .controls {
                flex-direction: column; 
                align-items: stretch; 
                padding: 15px;
            }
            .controls .search-box { 
                 width: 100%;
            }


            button { /* General button stacking */
                width: 100%;
                margin-bottom: 10px; 
                font-size: 12px;
                padding: 10px 15px;
            }
             /* Ensure table action buttons don't go full width on mobile */
            td button {
                width: auto; /* Override full width for table buttons */
                margin-bottom: 2px; /* Reduce margin if stacked vertically in a small cell */
            }


            .search-box { 
                width: 100%; 
                padding-left: 35px; /* Ensure icon space maintained */
            }


            /* Responsive Tables: force table to scroll horizontally */
            table {
                display: block; 
                width: 100%;
                overflow-x: auto; 
                -webkit-overflow-scrolling: touch; 
                white-space: nowrap; 
            }

            th, td {
                min-width: 120px; /* Ensure columns have a minimum width for readability */
                padding: 10px;    /* Adjust padding for mobile if needed */
            }
            /* Adjust right-alignment for mobile if it causes issues, or keep it */
             #inventory-table td:nth-child(4), /* Quantity */
            #new-products-table td:nth-child(6), /* Quantity */
            #to-clear-table td:nth-child(6), 
            #to-clear-table td:nth-child(7), 
            #to-clear-table td:nth-child(8), 
            #to-clear-table td:nth-child(9), 
            #to-clear-table td:nth-child(10), 
            #to-clear-table td:nth-child(11), 
            #master-table td:nth-child(4),
            #master-table td:nth-child(6) {
                text-align: right; /* Keep right alignment for consistency */
            }


            .modal-content {
                margin: 20px auto; 
                padding: 20px;
                width: 95%; 
            }

            .alert {
                width: calc(100% - 40px); 
                left: 20px;
                right: 20px;
                top: 10px; 
                text-align: center;
            }
        }
    </style>
     <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-messaging-compat.js"></script>
</head>
<body>
    <div class="container">
        <h1>Inventory Management System</h1>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab(this, 'dashboard')">📊 Dashboard</div>
            <div class="tab" onclick="switchTab(this, 'oos-lowstock')"> OOS/LOW STOCK</div>
            <div class="tab" onclick="switchTab(this, 'new-products')">✨ New Products</div>
            <div class="tab" onclick="switchTab(this, 'to-clear')">🏷️ 7-12 Months</div>
            <div class="tab" onclick="switchTab(this, 'staff-claim')">👥 Staff Claim</div>
            <div class="tab" onclick="switchTab(this, 'master-list')">📋 Master List</div>
            <div class="tab" onclick="switchTab(this, 'recycle-bin')">🗑️ Recycle Bin</div>
            <div class="tab" onclick="switchTab(this, 'management')">⚙️ Management</div>
        </div>
        
        <div id="dashboard" class="tab-content active">
            <div class="stats-cards">
                <div class="stat-card urgent" onclick="showFilteredInventory('OOS', true)">
                    <div class="stat-number" id="oos-count">0</div>
                    <div class="stat-label">Out of Stock</div>
                </div>
                <div class="stat-card warning" onclick="showFilteredInventory('Low stock', true)">
                    <div class="stat-number" id="low-count">0</div>
                    <div class="stat-label">Low Stock</div>
                </div>
                <div class="stat-card info" onclick="switchTab(document.querySelector('.tab[onclick*=\'new-products\']'), 'new-products')">
                    <div class="stat-number" id="new-count">0</div>
                    <div class="stat-label">New Products</div>
                </div>
                <div class="stat-card toclear-card" onclick="switchTab(document.querySelector('.tab[onclick*=\'to-clear\']'), 'to-clear')">
                    <div class="stat-number" id="to-clear-count">0</div>
                    <div class="stat-label">7-12 Months</div>
                </div>
                <div class="stat-card staff-claim-card" onclick="switchTab(document.querySelector('.tab[onclick*=\'staff-claim\']'), 'staff-claim')">
                    <div class="stat-number" id="staff-claim-count">0</div>
                    <div class="stat-label">Staff Claim</div>
                </div>
            </div>
            
            <h3>Recent Alerts</h3>
            <div id="alerts" style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-top: 20px; border: 1px solid #e1e8ed;">
                <p>Loading alerts...</p>
            </div>
        </div>
        
        <div id="oos-lowstock" class="tab-content">
            <div class="controls">
                <button onclick="showAddProductModal()">➕ Add Product</button>
                <input type="text" id="oosSearchInput" class="search-box" placeholder="Search products..." onkeyup="searchInventory(this.value)">
            </div>
            
            <table id="inventory-table-container">
                <thead>
                    <tr>
                        <th style="min-width: 200px;">Actions</th>
    <th onclick="sortTable('inventory', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
    <th onclick="sortTable('inventory', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
    <th onclick="sortTable('inventory', 'product')" data-column-key="product">Product <span class="sort-arrow"></span></th>
    <th onclick="sortTable('inventory', 'quantity')" data-column-key="quantity">Quantity <span class="sort-arrow"></span></th>
    <th onclick="sortTable('inventory', 'status')" data-column-key="status">Status <span class="sort-arrow"></span></th>
    <th onclick="sortTable('inventory', 'shipmentDate')" data-column-key="shipmentDate">Shipment Date <span class="sort-arrow"></span></th>
    <th>Remarks</th>
    <th onclick="sortTable('inventory', 'lastUpdated')" data-column-key="lastUpdated">Last Updated <span class="sort-arrow"></span></th>
    
</tr>
                </thead>
                <tbody id="inventory-table">
                    </tbody>
            </table>
        </div>
        
        <div id="new-products" class="tab-content">
            <div class="controls">
                <button onclick="showAddNewProductModal()">➕ Add New Product</button>
                <button onclick="mergeNewProductsToMaster()">Merge All to Inventory</button>
                 <input type="text" id="newProductsSearchInput" class="search-box" placeholder="Search new products..." onkeyup="searchNewProducts(this.value)">
            </div>
            
            <table id="new-products-table-container">
                <thead>
                    <tr>
                        <th>Actions</th>
    <th onclick="sortTable('newProducts', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
    <th onclick="sortTable('newProducts', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
    <th onclick="sortTable('newProducts', 'product')" data-column-key="product">Product <span class="sort-arrow"></span></th>
    <th onclick="sortTable('newProducts', 'addedDate')" data-column-key="addedDate">Added Date <span class="sort-arrow"></span></th>
    <th onclick="sortTable('newProducts', 'arrivalDate')" data-column-key="arrivalDate">Arrival Date <span class="sort-arrow"></span></th>
    <th onclick="sortTable('newProducts', 'quantity')" data-column-key="quantity">Quantity <span class="sort-arrow"></span></th>
    <th>Notes</th>
    <th onclick="sortTable('newProducts', 'lastUpdated')" data-column-key="lastUpdated">Last Updated <span class="sort-arrow"></span></th>
    
</tr>
                </thead>
                <tbody id="new-products-table">
                    </tbody>
            </table>
        </div>
        
        <div id="to-clear" class="tab-content">
            <div class="controls">
                <button onclick="showAddToClearModal()">➕ Add Product to 7-12 Months</button>
                <input type="text" id="toClearSearchInput" class="search-box" placeholder="Search products to clear..." onkeyup="searchToClear(this.value)">
            </div>
            
            <table id="to-clear-table-container">
                <thead>
                    <tr>
                        <th>Actions</th>
    <th onclick="sortTable('toClear', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'product')" data-column-key="product">Product <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'expiryDate')" data-column-key="expiryDate">Expiry Date <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'firstHighlightedDate')" data-column-key="firstHighlightedDate">First Highlighted <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'firstReportedBalance')" data-column-key="firstReportedBalance">Initial Bal <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'warehouseQty')" data-column-key="warehouseQty">WH Qty <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'storeQty')" data-column-key="storeQty">Store Qty <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'totalQty')" data-column-key="totalQty">Total Qty <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'weeklyDemand')" data-column-key="weeklyDemand">Wk Demand <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'weeksSupply')" data-column-key="weeksSupply">Wks Supply <span class="sort-arrow"></span></th>
    <th onclick="sortTable('toClear', 'supplyStatus')" data-column-key="supplyStatus">Supply Status <span class="sort-arrow"></span></th>
    <th>Remarks</th>
    <th>Action Plan</th>
    <th onclick="sortTable('toClear', 'lastUpdated')" data-column-key="lastUpdated">Last Updated <span class="sort-arrow"></span></th>
    
</tr>
                </thead>
                <tbody id="to-clear-table">
                    </tbody>
            </table>
        </div>
        
        <div id="staff-claim" class="tab-content">
            <div class="controls">
                <button onclick="showAddStaffClaimModal()">➕ Add Product to Staff Claim</button>
                <input type="text" id="staffClaimSearchInput" class="search-box" placeholder="Search staff claim products..." onkeyup="searchStaffClaim(this.value)">
            </div>
            
            <table id="staff-claim-table-container">
                <thead>
                    <tr>
                        <th>Actions</th>
                        <th onclick="sortTable('staffClaim', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'product')" data-column-key="product">Product <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'expiryDate')" data-column-key="expiryDate">Expiry Date <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'claimRemarks')" data-column-key="claimRemarks">Remarks <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'firstReportedBalance')" data-column-key="firstReportedBalance">Initial Bal <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'warehouseQty')" data-column-key="warehouseQty">WH Qty <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'storeQty')" data-column-key="storeQty">Store Qty <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'totalQty')" data-column-key="totalQty">Total Qty <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'weeklyDemand')" data-column-key="weeklyDemand">Wk Demand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'weeksSupply')" data-column-key="weeksSupply">Wks Supply <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('staffClaim', 'supplyStatus')" data-column-key="supplyStatus">Supply Status <span class="sort-arrow"></span></th>
                        <th>Action Plan</th>
                        <th onclick="sortTable('staffClaim', 'lastUpdated')" data-column-key="lastUpdated">Last Updated <span class="sort-arrow"></span></th>
                    </tr>
                </thead>
                <tbody id="staff-claim-table">
                </tbody>
            </table>
        </div>

        <div id="master-list" class="tab-content">
            <div class="controls">
                <button onclick="showAddMasterProductModal()">➕ Add Product</button>
                <input type="text" class="search-box" id="masterListSearchInput" placeholder="Search master products..." onkeyup="searchMasterList(this.value)">
                <button onclick="exportMasterList()">📥 Export List</button>
                <button onclick="document.getElementById('csvFileInput').click()">📤 Import CSV</button>
                <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="importCSV(event)">
            </div>
            
            <table id="master-table-container">
                <thead>
                    <tr>
                        <th>Actions</th>
                        <th onclick="sortTable('master', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('master', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('master', 'product')" data-column-key="product">Product Name <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('master', 'wkDemand')" data-column-key="wkDemand">WK Demand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('master', 'expiryDate')" data-column-key="expiryDate">Expiry Date <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('master', 'price')" data-column-key="price">Price <span class="sort-arrow"></span></th>
                        
                    </tr>
                </thead>
                <tbody id="master-table">
                    </tbody>
            </table>
        </div>

        <div id="recycle-bin" class="tab-content">
            <div class="controls">
                <h3>Recycle Bin</h3>
                <input type="text" id="recycleBinSearchInput" class="search-box" placeholder="Search recycle bin..." onkeyup="searchRecycleBin(this.value)">
                <button class="btn-danger" onclick="emptyRecycleBin()">🗑️ Empty Recycle Bin</button>
            </div>
            <table id="recycle-bin-table-container">
                <thead>
                    <tr>
                        <th>Actions</th>
                        <th onclick="sortTable('recycleBin', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('recycleBin', 'originalCollection')" data-column-key="originalCollection">Original Tab <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('recycleBin', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('recycleBin', 'product')" data-column-key="product">Product <span class="sort-arrow"></span></th>
                        
                    </tr>
                </thead>
                <tbody id="recycle-bin-table">
                    </tbody>
            </table>
        </div>
        
        <div id="management" class="tab-content">
            <div class="controls">
                <button onclick="exportAllData()">📥 Export All Data</button>
                <button onclick="confirmLoadSampleData()">📊 Load Sample Data</button>
            </div>
            
            <h3>System Information</h3>
            <p>Total Products (active): <span id="total-products">0</span></p>
            <p>Total Products (all unique SKUs): <span id="total-products-all">0</span></p>
            <p>Last Synced: <span id="last-updated">Never</span></p>
        </div>
    </div>

    <div id="productModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('productModal')">&times;</span>
            <h2 id="productModalTitle">Add New Product</h2>
            <form onsubmit="saveProduct(event)">
                <input type="hidden" id="editProductId" value="">
                <div class="form-group">
                    <label for="brand">Brand:</label>
                    <select id="brand" required onchange="filterProductsForBrand(this.value, 'productName', 'productsDatalist')">
                        </select>
                </div>
                <div class="form-group">
    <label for="productName">Product Name:</label>
    <div class="input-with-clear">
        <input type="text" id="productName" list="productsDatalist" required>
        <datalist id="productsDatalist"></datalist>
        <button type="button" class="clear-btn" onclick="clearProductSelection('productName')" title="Clear selection">×</button>
    </div>
</div>
                <div class="form-group">
                    <label for="inventoryQuantity">Quantity:</label>
                    <input type="number" id="inventoryQuantity" min="0" required>
                </div>
                <div class="form-group">
                    <label for="status">Status:</label>
                    <select id="status" required>
                        </select>
                </div>
                <div class="form-group">
                    <label for="shipmentDate">Shipment Date:</label>
                    <input type="date" id="shipmentDate">
                </div>
                <div class="form-group">
                    <label for="remarks">Remarks:</label>
                    <textarea id="remarks"></textarea>
                </div>
                <button type="submit">Save Product</button>
            </form>
        </div>
    </div>

    <div id="newProductModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('newProductModal')">&times;</span>
            <h2 id="newProductModalTitle">Add New Product Entry</h2>
            <form onsubmit="saveNewProduct(event)">
                <input type="hidden" id="editNewProductId" value="">
                <div class="form-group">
                    <label for="newBrand">Brand:</label>
                    <select id="newBrand" required onchange="filterProductsForBrand(this.value, 'newProductName', 'newProductsDatalist')">
                        </select>
                </div>
                <div class="form-group">
                    <label for="newProductSku">Product Code (SKU):</label>
                    <input type="text" id="newProductSku" required>
                </div>
                <div class="form-group">
                    <label for="newProductName">Product Name:</label>
                    <input type="text" id="newProductName" required>
                </div>

                <div class="form-group">
                    <label for="arrivalDate">Arrival Date:</label>
                    <input type="date" id="arrivalDate" required>
                </div>
                <div class="form-group">
                    <label for="newProductQuantity">Quantity:</label> <input type="number" id="newProductQuantity" min="0" required>
                </div>
                <div class="form-group">
                    <label for="notes">Notes:</label>
                    <textarea id="notes"></textarea>
                </div>
                <button type="submit">Save New Product</button>
            </form>
        </div>
    </div>

    <div id="masterProductModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('masterProductModal')">&times;</span>
            <h2 id="masterProductModalTitle">Add Master Product</h2>
            <form onsubmit="saveMasterProduct(event)">
                <input type="hidden" id="editMasterProductId" value="">
                <div class="form-group">
                    <label for="masterBrand">Brand:</label>
                    <select id="masterBrand" required>
                        </select>
                </div>
                <div class="form-group">
                    <label for="masterProductName">Product Name:</label>
                    <input type="text" id="masterProductName" required>
                </div>
                 <div class="form-group">
                    <label for="wkDemand">Weekly Demand (WK Demand):</label>
                    <input type="number" id="wkDemand" min="0" step="1" value="0">
                </div>
               <div class="form-group">
        <label for="masterExpiryMonth">Expiry Date:</label>
        <div style="display: flex; gap: 10px;">
            <select id="masterExpiryMonth" style="flex: 1;">
                <option value="">Month</option>
            </select>
            <select id="masterExpiryYear" style="flex: 1;">
                <option value="">Year</option>
            </select>
        </div>
    </div>
                <div class="form-group">
                    <label for="sku">Product Code (SKU):</label>
                    <input type="text" id="sku">
                </div>
                <div class="form-group">
                    <label for="price">Price:</label>
                    <input type="number" id="price" step="0.01" min="0">
                </div>
                <button type="submit">Save Master Product</button>
            </form>
        </div>
    </div>

    <div id="toClearModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('toClearModal')">&times;</span>
            <h2 id="toClearModalTitle">Add Product to Clear</h2>
            <form onsubmit="saveToClear(event)">
                <input type="hidden" id="editToClearId" value="">
                <div class="form-group">
                    <label for="toClearBrand">Brand:</label>
                     <select id="toClearBrand" required onchange="handleToClearBrandChange(this.value)">
                        </select>
                </div>
                <div class="form-group">
    <label for="toClearProductName">Product Name:</label>
    <div class="input-with-clear">
        <input type="text" id="toClearProductName" list="toClearProductsDatalist" required onchange="handleToClearProductChange()">
        <datalist id="toClearProductsDatalist"></datalist>
        <button type="button" class="clear-btn" onclick="clearProductSelection('toClearProductName')" title="Clear selection">×</button>
    </div>
</div>
                <div class="form-group">
                    <label for="toClearExpiryDate">Expiry Date:</label>
                    <input type="date" id="toClearExpiryDate" required>
                </div>
                <div class="form-group">
                    <label for="toClearFirstHighlightedDate">First Highlighted Date:</label>
                    <input type="date" id="toClearFirstHighlightedDate" required>
                </div>
                <div class="form-group">
                    <label for="toClearFirstReportedBalance">First Reported Balance (Total Qty):</label>
                    <input type="number" id="toClearFirstReportedBalance" min="0">
                </div>
                <div class="form-group">
                    <label for="toClearWarehouseQty">Warehouse Qty:</label>
                    <input type="number" id="toClearWarehouseQty" min="0" value="0">
                </div>
                <div class="form-group">
                    <label for="toClearStoreQty">Store Qty:</label>
                    <input type="number" id="toClearStoreQty" min="0" value="0">
                </div>
                <div class="form-group">
                    <label for="toClearWeeklyDemand">Weekly Demand:</label>
                    <input type="number" id="toClearWeeklyDemand" min="0" readonly>
                </div>
                <div class="form-group">
                    <label for="toClearRemarks">Remarks:</label>
                    <textarea id="toClearRemarks"></textarea>
                </div>
                <div class="form-group">
                    <label for="toClearActionPlan">Action Plan:</label>
                    <textarea id="toClearActionPlan"></textarea>
                </div>
                <button type="submit">Save Product to Clear</button>
            </form>
        </div>
    </div>

    <div id="staffClaimModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('staffClaimModal')">&times;</span>
            <h2 id="staffClaimModalTitle">Add Product to Staff Claim</h2>
            <form onsubmit="saveStaffClaim(event)">
                <input type="hidden" id="editStaffClaimId" value="">
                <div class="form-group">
                    <label for="staffClaimBrand">Brand:</label>
                    <select id="staffClaimBrand" required onchange="handleStaffClaimBrandChange(this.value)">
                    </select>
                </div>
                <div class="form-group">
                    <label for="staffClaimProductName">Product Name:</label>
                    <div class="input-with-clear">
                        <input type="text" id="staffClaimProductName" list="staffClaimProductsDatalist" required onchange="handleStaffClaimProductChange()">
                        <datalist id="staffClaimProductsDatalist"></datalist>
                        <button type="button" class="clear-btn" onclick="clearProductSelection('staffClaimProductName')" title="Clear selection">×</button>
                    </div>
                </div>
                <div class="form-group">
                    <label for="staffClaimExpiryDate">Expiry Date:</label>
                    <input type="date" id="staffClaimExpiryDate" required>
                </div>
                <div class="form-group">
                    <label for="staffClaimRemarks">Remarks:</label>
                    <select id="staffClaimRemarks" required onchange="handleRemarksChange()">
                        <option value="">Select Remarks</option>
                        <option value="add_new_remark">+ Add New Remark...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="staffClaimFirstReportedBalance">First Reported Balance (Total Qty):</label>
                    <input type="number" id="staffClaimFirstReportedBalance" min="0">
                </div>
                <div class="form-group">
                    <label for="staffClaimWarehouseQty">Warehouse Qty:</label>
                    <input type="number" id="staffClaimWarehouseQty" min="0" value="0">
                </div>
                <div class="form-group">
                    <label for="staffClaimStoreQty">Store Qty:</label>
                    <input type="number" id="staffClaimStoreQty" min="0" value="0">
                </div>
                <div class="form-group">
                    <label for="staffClaimWeeklyDemand">Weekly Demand:</label>
                    <input type="number" id="staffClaimWeeklyDemand" min="0" readonly>
                </div>
                <div class="form-group">
                    <label for="staffClaimActionPlan">Action Plan:</label>
                    <textarea id="staffClaimActionPlan"></textarea>
                </div>
                <button type="submit">Save Product to Staff Claim</button>
            </form>
        </div>
    </div>
    
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <h2>Confirmation</h2>
            <p id="confirmMessage"></p>
            <div class="modal-buttons">
                <button class="btn-danger" id="confirmNo">No</button>
                <button class="btn-success" id="confirmYes">Yes</button>
            </div>
        </div>
    </div>

    <div id="addBrandModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addBrandModal')">&times;</span>
            <h2>Add New Brand</h2>
            <form onsubmit="saveNewBrand(event)">
                <div class="form-group">
                    <label for="newBrandName">Brand Name:</label>
                    <input type="text" id="newBrandName" required>
                </div>
                <button type="submit">Add Brand</button>
            </form>
        </div>
    </div>

    <div id="addStatusModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addStatusModal')">&times;</span>
            <h2>Add New Status</h2>
            <form onsubmit="saveNewStatus(event)">
                <div class="form-group">
                    <label for="newStatusName">Status Name:</label>
                    <input type="text" id="newStatusName" required>
                </div>
                <button type="submit">Add Status</button>
            </form>
        </div>
    </div>

    <div id="addRemarkModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addRemarkModal')">&times;</span>
            <h2>Add New Remark</h2>
            <form onsubmit="saveNewRemark(event)">
                <div class="form-group">
                    <label for="newRemarkText">Remark Text:</label>
                    <input type="text" id="newRemarkText" required>
                </div>
                <button type="submit">Add Remark</button>
            </form>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    <script>
        // IMPORTANT: Replace with your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDo1-y0Vj4XTQeeEUQK_6Y2wqDs94TOAX0",
            authDomain: "inventory-c3bac.firebaseapp.com",
            projectId: "inventory-c3bac",
            storageBucket: "inventory-c3bac.firebasestorage.app",
            messagingSenderId: "261015083855",
            appId: "1:261015083855:web:e167f359928eb8ed8cc33a",
            measurementId: "G-V744486L78"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // --- Real-time notifications for new Inventory items ---
const seenInventoryIds = new Set();
db.collection('inventory').get().then(snapshot => {
  snapshot.forEach(doc => seenInventoryIds.add(doc.id));
});
db.collection('inventory').onSnapshot(snapshot => {
  snapshot.docChanges().forEach(change => {
    if (change.type === 'added' && !seenInventoryIds.has(change.doc.id)) {
      const data = change.doc.data();
      // Optional: Don't notify if this browser/tab just added it
      showBrowserNotification(
        'New Inventory Item Added',
        `${data.brand} - ${data.product} added to OOS/Low Stock.`
      );
      seenInventoryIds.add(change.doc.id);
    }
  });
});

// --- Real-time notifications for new New Products ---
const seenNewProductIds = new Set();
db.collection('new_products').get().then(snapshot => {
  snapshot.forEach(doc => seenNewProductIds.add(doc.id));
});
db.collection('new_products').onSnapshot(snapshot => {
  snapshot.docChanges().forEach(change => {
    if (change.type === 'added' && !seenNewProductIds.has(change.doc.id)) {
      const data = change.doc.data();
      showBrowserNotification(
        'New Product Added',
        `${data.brand} - ${data.product} (SKU: ${data.sku}) added.`
      );
      seenNewProductIds.add(change.doc.id);
    }
  });
});

        // Global data arrays to hold fetched data
        let inventoryData = [];
        let newProductsData = [];
        let toClearData = [];
        let masterProductsData = [];
        let deletedItemsData = []; // For Recycle Bin
        let brandsData = []; 
        let statusesData = []; 
        // let categoriesData = []; // Categories removed

        // Data for current views (used for filtering and sorting)
        let currentInventoryViewData = [];
        let currentNewProductsViewData = [];
        let currentToClearViewData = [];
        let currentMasterListViewData = [];
        let currentRecycleBinViewData = [];

        // Firestore collection references
        const inventoryColRef = db.collection('inventory');
        const newProductsColRef = db.collection('new_products');
        const toClearColRef = db.collection('to_clear');
        const masterProductsColRef = db.collection('master_products');
        const brandsColRef = db.collection('brands');
        const statusesColRef = db.collection('statuses');
        // const categoriesColRef = db.collection('categories'); // Categories removed

        // Sort state for tables
        let sortState = {
            inventory: { column: null, direction: 'asc' },
            newProducts: { column: null, direction: 'asc' },
            master: { column: null, direction: 'asc' },
            toClear: { column: null, direction: 'asc' },
            staffClaim: { column: null, direction: 'asc' },
            recycleBin: { column: null, direction: 'asc' }
        };

        // --- Notification System ---
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.classList.add('alert', `alert-${type}`);
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // --- Confirmation Modal ---
        let confirmCallback = null;
        function showConfirmModal(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').style.display = 'block';
            confirmCallback = callback;
        }

        document.getElementById('confirmYes').onclick = () => {
            if (confirmCallback) {
                confirmCallback(true);
            }
            document.getElementById('confirmModal').style.display = 'none';
        };

        document.getElementById('confirmNo').onclick = () => {
            if (confirmCallback) {
                confirmCallback(false);
            }
            document.getElementById('confirmModal').style.display = 'none';
        };


        // --- Firestore Data Operations ---
        async function fetchDataFromFirestore(collectionRef, includeDeleted = false) {
            let data = [];
            let query = collectionRef;
            if (!includeDeleted && 
                (collectionRef.id === 'inventory' || 
                 collectionRef.id === 'new_products' || 
                 collectionRef.id === 'to_clear' || 
                 collectionRef.id === 'master_products')) {
                query = collectionRef.where("isDeleted", "==", false);
            }
            
            try {
                const querySnapshot = await query.get();
                querySnapshot.forEach((doc) => {
                    const docData = doc.data();
                    // Ensure isPinned is initialized
                    if (collectionRef.id === 'to_clear' && typeof docData.isPinned === 'undefined') {
                        docData.isPinned = false;
                    }
                    data.push({ id: doc.id, ...docData });
                });
            } catch (error) {
                console.error(`Error fetching data from ${collectionRef.id}:`, error);
                if (error.code === 'failed-precondition' && !includeDeleted) {
                    console.warn(`Firestore query for ${collectionRef.id} might require an index. Check Firestore console. Query details: where("isDeleted", "==", false)`);
                } else if (error.code === 'failed-precondition') {
                     console.warn(`Firestore query for ${collectionRef.id} might require an index. Check Firestore console.`);
                }
                if (!( (collectionRef.id === 'brands' || collectionRef.id === 'statuses') && error.code === 'failed-precondition' ) ) {
                   // showNotification(`Error loading data from ${collectionRef.id}. Check console.`, 'error');
                }
            }
            return data;
        }

        async function fetchAllDataForRecycleBin() {
            const collectionsToFetchFrom = [inventoryColRef, newProductsColRef, toClearColRef, masterProductsColRef];
            let allDeletedItems = [];
            for (const colRef of collectionsToFetchFrom) {
                try {
                    const querySnapshot = await colRef.where("isDeleted", "==", true).get();
                    querySnapshot.forEach((doc) => {
                        allDeletedItems.push({ id: doc.id, ...doc.data(), originalCollection: colRef.id });
                    });
                } catch (error) {
                    console.error(`Error fetching deleted items from ${colRef.id}:`, error);
                    if (error.code === 'failed-precondition') {
                        console.warn(`Firestore query for deleted items in ${colRef.id} might require an index for 'isDeleted'. Check Firestore console.`);
                    }
                }
            }
            return allDeletedItems;
        }

        async function saveDataToFirestore(collectionRef, docId, data) {
            try {
                if (docId) {
                    await collectionRef.doc(docId).set(data, { merge: true }); // Use set with merge to handle updates and new fields
                } else {
                    const docRef = await collectionRef.add(data);
                    return docRef.id;
                }
                return docId;
            } catch (error) {
                console.error(`Error saving data to ${collectionRef.id}:`, error);
                showNotification(`Error saving data to server for ${collectionRef.id}.`, 'error');
                throw error;
            }
        }

        // --- Update Local Data & UI ---
        async function updateLocalData() {
            try {
                inventoryData = await fetchDataFromFirestore(inventoryColRef);
                newProductsData = await fetchDataFromFirestore(newProductsColRef);
                toClearData = await fetchDataFromFirestore(toClearColRef);
                masterProductsData = await fetchDataFromFirestore(masterProductsColRef);
                deletedItemsData = await fetchAllDataForRecycleBin();
                staffClaimData = await fetchDataFromFirestore(staffClaimColRef); // ADD THIS
const rawRemarks = await fetchDataFromFirestore(remarksColRef, true); // ADD THIS
remarksData = rawRemarks.filter(r => r.isDeleted === false || typeof r.isDeleted === 'undefined'); // ADD THIS
currentStaffClaimViewData = staffClaimData.filter(item => !item.isDeleted); // ADD THIS

                const rawBrands = await fetchDataFromFirestore(brandsColRef, true); // Fetch all, then filter
                brandsData = rawBrands.filter(b => b.isDeleted === false || typeof b.isDeleted === 'undefined');

                const rawStatuses = await fetchDataFromFirestore(statusesColRef, true); // Fetch all, then filter
                statusesData = rawStatuses.filter(s => s.isDeleted === false || typeof s.isDeleted === 'undefined');
                
                currentInventoryViewData = inventoryData.filter(item =>
                    !item.isDeleted && (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))
                );
                currentNewProductsViewData = newProductsData.filter(item => !item.isDeleted);
                currentToClearViewData = toClearData.filter(item => !item.isDeleted);
                currentMasterListViewData = masterProductsData.filter(item => !item.isDeleted);
                currentRecycleBinViewData = [...deletedItemsData];


                updateAllTablesAndViews();
                updateDashboardStats();
                updateAlerts();
                updateManagementStats();
                populateProductDatalists();
                setupDynamicDropdowns();
            } catch (error) {
                console.error("Error updating local data from Firestore:", error);
                showNotification('Error loading data from server. Please check your internet connection or Firebase setup.', 'error');
            }
        }
        
        function updateAllTablesAndViews() {
            renderInventoryItems();
            renderNewProductsItems();
            renderMasterListItems();
            renderToClearItems();
            renderStaffClaimItems();
            renderRecycleBinItems();
        }
        // Helper function to clear product selection - NEW
function clearProductSelection(inputId) {
    const input = document.getElementById(inputId);
    const clearButton = input.parentElement.querySelector('.clear-btn');
    
    if (input) {
        input.value = '';
        input.style.borderColor = '#e1e8ed';
        input.style.boxShadow = '0 2px 8px rgba(0,0,0,0.05)';
        input.focus();
    }
    
    if (clearButton) {
        clearButton.style.display = 'none';
    }

    // Special handling for toClear modal
    if (inputId === 'toClearProductName') {
        document.getElementById('toClearWeeklyDemand').value = '';
    }
}

// Function to toggle clear button visibility - NEW
function toggleClearButton(inputElement, show) {
    const clearButton = inputElement.parentElement.querySelector('.clear-btn');
    if (clearButton) {
        clearButton.style.display = show ? 'block' : 'none';
    }
}
        // --- Dynamic Dropdowns ---
        function setupDynamicDropdowns() {
            populateBrandDropdowns('brand');
            populateBrandDropdowns('newBrand');
            populateBrandDropdowns('masterBrand');
            populateBrandDropdowns('toClearBrand');
            populateStatusDropdowns('status');
        }

        function populateBrandDropdowns(selectId) {
    const selectElement = document.getElementById(selectId);
    if (!selectElement) return;

    const currentValue = selectElement.value; 
    selectElement.innerHTML = '<option value="">Select Brand</option>';

    const uniqueBrandsFromMaster = [...new Set(masterProductsData.filter(item => !item.isDeleted).map(item => item.brand).filter(Boolean))];
    let allUniqueBrands = [...uniqueBrandsFromMaster];
    
    brandsData.forEach(brandDoc => {
        if (brandDoc.name && !allUniqueBrands.includes(brandDoc.name)) {
            allUniqueBrands.push(brandDoc.name);
        }
    });
    allUniqueBrands.sort((a, b) => a.localeCompare(b));

    allUniqueBrands.forEach(brand => {
        const option = document.createElement('option');
        option.value = brand;
        option.textContent = brand;
        selectElement.appendChild(option);
    });

    const addNewOption = document.createElement('option');
    addNewOption.value = 'add_new_brand';
    addNewOption.textContent = '+ Add New Brand...';
    selectElement.appendChild(addNewOption);
    
    if (currentValue && allUniqueBrands.includes(currentValue)) {
        selectElement.value = currentValue;
    } else if (currentValue === 'add_new_brand') {
        selectElement.value = ''; 
    }

    selectElement.removeEventListener('change', handleDynamicDropdownChange); 
    selectElement.addEventListener('change', handleDynamicDropdownChange);
}

        function populateStatusDropdowns(selectId) {
            const selectElement = document.getElementById(selectId);
            if (!selectElement) return;

            const currentValue = selectElement.value;
            selectElement.innerHTML = '<option value="">Select Status</option>';

            // Define core statuses and add any from statusesData, excluding "In stock" for OOS/Low Stock modal
            let allowedStatuses = ['OOS', 'Low stock']; 
            
            statusesData.forEach(statusDoc => { 
                if (statusDoc.name && !allowedStatuses.includes(statusDoc.name) && statusDoc.name.toLowerCase() !== 'in stock') {
                    allowedStatuses.push(statusDoc.name);
                }
            });
             // Also include statuses currently in use in inventoryData (excluding "In stock")
            inventoryData.forEach(item => {
                if (item.status && !allowedStatuses.includes(item.status) && item.status.toLowerCase() !== 'in stock' && !item.isDeleted) {
                    allowedStatuses.push(item.status);
                }
            });

            allowedStatuses = [...new Set(allowedStatuses)]; // Make unique
            allowedStatuses.sort((a, b) => a.localeCompare(b));

            allowedStatuses.forEach(status => {
                const option = document.createElement('option');
                option.value = status;
                option.textContent = status;
                selectElement.appendChild(option);
            });

            const addNewOption = document.createElement('option');
            addNewOption.value = 'add_new_status';
            addNewOption.textContent = '+ Add New Status...';
            selectElement.appendChild(addNewOption);

            if (currentValue && allowedStatuses.includes(currentValue)) {
                selectElement.value = currentValue;
            }  else if (currentValue === 'add_new_status') {
                selectElement.value = ''; 
            }
            selectElement.removeEventListener('change', handleDynamicDropdownChange);
            selectElement.addEventListener('change', handleDynamicDropdownChange);
        }


        function handleDynamicDropdownChange(event) {
            const selectElement = event.target;
            const selectedOptionValue = selectElement.value;
            
            if (selectedOptionValue === 'add_new_brand') {
                showAddBrandModal();
            } else if (selectedOptionValue === 'add_new_status') {
                showAddStatusModal();
            }
        }

        // --- Product Datalists (for autocomplete) ---
        function populateProductDatalists() {
    const productsDatalist = document.getElementById('productsDatalist');
    const newProductsDatalist = document.getElementById('newProductsDatalist');
    const toClearProductsDatalist = document.getElementById('toClearProductsDatalist');
    const staffClaimProductsDatalist = document.getElementById('staffClaimProductsDatalist'); // ADD THIS LINE

    if (productsDatalist) productsDatalist.innerHTML = '';
    if (newProductsDatalist) newProductsDatalist.innerHTML = '';
    if (toClearProductsDatalist) toClearProductsDatalist.innerHTML = '';
    if (staffClaimProductsDatalist) staffClaimProductsDatalist.innerHTML = ''; // ADD THIS LINE

    const allProductNames = [...new Set(masterProductsData.filter(item => !item.isDeleted).map(item => item.product).filter(Boolean))].sort();

    allProductNames.forEach(productName => {
        const option1 = document.createElement('option');
        option1.value = productName;
        if (productsDatalist) productsDatalist.appendChild(option1);

        const option2 = document.createElement('option');
        option2.value = productName;
        if (newProductsDatalist) newProductsDatalist.appendChild(option2);

        const option3 = document.createElement('option');
        option3.value = productName;
        if (toClearProductsDatalist) toClearProductsDatalist.appendChild(option3);

        // ADD THIS BLOCK
        const option4 = document.createElement('option');
        option4.value = productName;
        if (staffClaimProductsDatalist) staffClaimProductsDatalist.appendChild(option4);
    });
}

        function filterProductsForBrand(brand, productNameInputId, datalistId) {
    const productNameInput = document.getElementById(productNameInputId);
    const datalist = document.getElementById(datalistId);
    if (!productNameInput || !datalist) return;

    const currentValue = productNameInput.value;
    datalist.innerHTML = '';
    
    if (brand) {
        const filteredProducts = masterProductsData.filter(item => !item.isDeleted && item.brand === brand);
        const uniqueProductNames = [...new Set(filteredProducts.map(item => item.product).filter(Boolean))].sort();

        uniqueProductNames.forEach(productName => {
            const option = document.createElement('option');
            option.value = productName;
            datalist.appendChild(option);
        });

        if (currentValue && !uniqueProductNames.includes(currentValue)) {
            productNameInput.value = '';
            toggleClearButton(productNameInput, false);
        }
    } else { 
        productNameInput.value = '';
        toggleClearButton(productNameInput, false);
    }

    // Remove existing event listeners to prevent duplicates
    const existingInputHandler = productNameInput.inputHandler;
    const existingChangeHandler = productNameInput.changeHandler;
    
    if (existingInputHandler) productNameInput.removeEventListener('input', existingInputHandler);
    if (existingChangeHandler) productNameInput.removeEventListener('change', existingChangeHandler);

    // Add input event to show/hide clear button and validate
    const inputHandler = function() {
        const currentVal = this.value.trim();
        toggleClearButton(this, currentVal.length > 0);
        
        if (brand && currentVal) {
            const validOptions = Array.from(datalist.options).map(opt => opt.value);
            if (!validOptions.includes(currentVal)) {
                this.style.borderColor = '#e74c3c';
                this.style.boxShadow = '0 0 5px rgba(231, 76, 60, 0.3)';
            } else {
                this.style.borderColor = '#e1e8ed';
                this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.05)';
            }
        }
    };
    productNameInput.inputHandler = inputHandler;
    productNameInput.addEventListener('input', inputHandler);

    // Add change event to clear invalid selections
    const changeHandler = function() {
        if (brand && this.value) {
            const validOptions = Array.from(datalist.options).map(opt => opt.value);
            if (!validOptions.includes(this.value)) {
                showNotification(`"${this.value}" is not available for ${brand}. Please select from the dropdown list.`, 'warning');
                this.value = '';
                this.style.borderColor = '#e1e8ed';
                this.style.boxShadow = '0 2px 8px rgba(0,0,0,0.05)';
                toggleClearButton(this, false);
            }
        }
        
        if (productNameInputId === 'toClearProductName') {
            handleToClearProductChange();
        }
    };
    productNameInput.changeHandler = changeHandler;
    productNameInput.addEventListener('change', changeHandler);

    // Initialize clear button visibility
    toggleClearButton(productNameInput, productNameInput.value.trim().length > 0);
}
        
        function handleToClearBrandChange(brandValue) {
            filterProductsForBrand(brandValue, 'toClearProductName', 'toClearProductsDatalist');
            // Also clear WK demand if brand changes, as product will likely change or be cleared
            document.getElementById('toClearWeeklyDemand').value = '';
            document.getElementById('toClearProductName').value = ''; // Clear product name input
        }

        function handleToClearProductChange() {
            const brand = document.getElementById('toClearBrand').value;
            const productName = document.getElementById('toClearProductName').value;
            const wkDemandInput = document.getElementById('toClearWeeklyDemand');

            if (brand && productName) {
                const masterProduct = masterProductsData.find(mp => 
                    !mp.isDeleted && mp.brand === brand && mp.product === productName
                );
                if (masterProduct) {
                    wkDemandInput.value = masterProduct.wkDemand !== undefined ? masterProduct.wkDemand : 0;
                } else {
                    wkDemandInput.value = 0; // Or some default/indicator that it's not found
                    showNotification("Selected product not found in Master List, or WK Demand is missing. Please check Master List.", "warning");
                }
            } else {
                wkDemandInput.value = ''; // Clear if no brand/product
            }
        }


        // --- Tab Switching ---
        function switchTab(clickedTab, tabId) {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            clickedTab.classList.add('active');

            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');

            // Reset search inputs and apply default filters for specific tabs
            if (tabId === 'oos-lowstock') {
                // Default to showing all OOS/Low Stock items, filter can be applied by showFilteredInventory
                currentInventoryViewData = inventoryData.filter(item =>
                    !item.isDeleted && (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))
                );
                if(document.getElementById('oosSearchInput')) document.getElementById('oosSearchInput').value = '';
                renderInventoryItems();
            } else if (tabId === 'new-products') {
                currentNewProductsViewData = newProductsData.filter(item => !item.isDeleted);
                if(document.getElementById('newProductsSearchInput')) document.getElementById('newProductsSearchInput').value = '';
                renderNewProductsItems();
            } else if (tabId === 'to-clear') {
                currentToClearViewData = toClearData.filter(item => !item.isDeleted);
                if(document.getElementById('toClearSearchInput')) document.getElementById('toClearSearchInput').value = '';
                renderToClearItems();
            } else if (tabId === 'master-list') {
                currentMasterListViewData = masterProductsData.filter(item => !item.isDeleted);
                if(document.getElementById('masterListSearchInput')) document.getElementById('masterListSearchInput').value = '';
                renderMasterListItems();
            } else if (tabId === 'recycle-bin') {
                currentRecycleBinViewData = [...deletedItemsData];
                if(document.getElementById('recycleBinSearchInput')) document.getElementById('recycleBinSearchInput').value = '';
                renderRecycleBinItems();
            }
        }

        // --- Modals ---
        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                 modal.style.display = 'none';
                const form = modal.querySelector('form');
                if (form) {
                    form.reset(); // This will clear the inputs
                    // After form reset, ensure readOnly state is correctly set for next "Add" operation if it's the toClearModal
                    if (modalId === 'toClearModal') {
                        document.getElementById('toClearFirstHighlightedDate').readOnly = false;
                        document.getElementById('toClearFirstReportedBalance').readOnly = false;
                        document.getElementById('toClearWeeklyDemand').value = ''; // Clear auto-populated field
                        document.getElementById('editToClearId').value = ''; // Ensure edit ID is cleared
                    }
                    // Handle other modals as before
                    if (modalId === 'productModal') {
                        filterProductsForBrand('', 'productName', 'productsDatalist');
                        document.getElementById('editProductId').value = '';
                    } else if (modalId === 'newProductModal') {
                         filterProductsForBrand('', 'newProductName', 'newProductsDatalist');
                        document.getElementById('editNewProductId').value = '';
                    } else if (modalId === 'masterProductModal') {
                        document.getElementById('editMasterProductId').value = '';
                    }
                }
            }
        }
        
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target == modal) {
                    closeModal(modal.id);
                }
            });
        }


        // --- CRUD Operations & Rendering ---

        // Inventory (OOS/Low Stock)
        function renderInventoryItems() {
    const tableBody = document.getElementById('inventory-table');
    if (!tableBody) return;
    tableBody.innerHTML = '';
    const pinnedItems = currentInventoryViewData.filter(item => item.isPinned === true);
    const unpinnedItems = currentInventoryViewData.filter(item => !item.isPinned);

    const sortedPinnedItems = sortArray(pinnedItems, sortState.inventory.column, sortState.inventory.direction);
    const sortedUnpinnedItems = sortArray(unpinnedItems, sortState.inventory.column, sortState.inventory.direction);

    const sortedData = [...sortedPinnedItems, ...sortedUnpinnedItems];

    sortedData.forEach(item => {
        const row = tableBody.insertRow();
        
        // Actions column FIRST
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button class="btn-info" onclick="editProduct('${item.id}')">✏️ Edit</button>
            <button class="${item.isPinned ? 'btn-warning' : 'btn-success'}" onclick="togglePinInventoryItem('${item.id}')">
                ${item.isPinned ? '➖ Unpin' : '📌 Pin'}
            </button>
            <button class="btn-danger" onclick="moveToRecycleBin('${item.id}', 'inventory')">🗑️ Delete</button>
        `;
        
        // Then other columns
        row.insertCell().textContent = item.sku || '';
        row.insertCell().textContent = item.brand || '';
        row.insertCell().textContent = item.product || '';
        row.insertCell().textContent = item.quantity !== undefined ? item.quantity : '';
        const statusCell = row.insertCell();
        const badgeClass = item.status === 'OOS' ? 'oos' : (item.status && item.status.toLowerCase().includes('low stock') ? 'low' : 'normal');
        statusCell.innerHTML = `<span class="status-badge ${badgeClass}">${item.status || ''}</span>`;
        row.insertCell().textContent = item.shipmentDate || '';
        row.insertCell().textContent = item.remarks || '';
        const lastUpdatedCell = row.insertCell();
        lastUpdatedCell.textContent = item.lastUpdated ? new Date(item.lastUpdated).toLocaleString() : '';
    });
}


        function showAddProductModal() {
            document.getElementById('productModalTitle').textContent = 'Add Product (OOS/Low Stock)';
            document.getElementById('editProductId').value = '';
            document.getElementById('productModal').querySelector('form').reset();
            populateBrandDropdowns('brand');
            populateStatusDropdowns('status'); // Will use the modified logic for statuses
            filterProductsForBrand('', 'productName', 'productsDatalist'); 
            openModal('productModal');
        }

        async function saveProduct(event) {
            event.preventDefault();
            const id = document.getElementById('editProductId').value;
            const brand = document.getElementById('brand').value;
            const productName = document.getElementById('productName').value;
            let sku = getSkuForProduct(brand, productName); 

            if (!sku) {
                showNotification("Product not found in Master List. Please add to Master List first or ensure Brand/Product Name match.", "error");
                return;
            }
            // Check for duplicates in OOS/Low Stock list (only if adding new item) - NEW
if (!id) {
    const duplicateExists = inventoryData.some(item => 
        !item.isDeleted && 
        item.sku === sku &&
        (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))
    );
    
    if (duplicateExists) {
        showNotification(`This product (${brand} - ${productName}) is already in the OOS/Low Stock list. Please check the existing entry or edit it instead.`, "error");
        return;
    }
}

            // Check for duplicates in OOS/Low Stock list (only if adding new item)
            if (!id) {
                const duplicateExists = inventoryData.some(item => 
                    !item.isDeleted && 
                    item.sku === sku &&
                    (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))
                );
                
                if (duplicateExists) {
                    showNotification(`This product (${brand} - ${productName}) is already in the OOS/Low Stock list. Please check the existing entry or edit it instead.`, "error");
                    return;
                }
            }

            const data = {
    brand: brand,
    product: productName,
    sku: sku,
    quantity: parseInt(document.getElementById('inventoryQuantity').value),
    status: document.getElementById('status').value,
    shipmentDate: document.getElementById('shipmentDate').value,
    remarks: document.getElementById('remarks').value,
    lastUpdated: new Date().toISOString(),
    isDeleted: false,
    isPinned: id ? (inventoryData.find(p => p.id === id)?.isPinned || false) : false
};

            try {
                await saveDataToFirestore(inventoryColRef, id, data);
                showNotification('Product saved successfully!', 'success');
                showBrowserNotification(
  'Inventory Update',
  `${brand} - ${productName} has been added to OOS/Low Stock.`
);
                closeModal('productModal');
                await updateLocalData(); 
            } catch (e) {
                // Error already handled in saveDataToFirestore
            }
        }

        async function editProduct(id) {
            const item = inventoryData.find(p => p.id === id);
            if (item) {
                document.getElementById('productModalTitle').textContent = 'Edit Product (OOS/Low Stock)';
                document.getElementById('editProductId').value = item.id;
                populateBrandDropdowns('brand'); 
                document.getElementById('brand').value = item.brand;
                filterProductsForBrand(item.brand, 'productName', 'productsDatalist'); 
                document.getElementById('productName').value = item.product;
                document.getElementById('inventoryQuantity').value = item.quantity;
                populateStatusDropdowns('status'); 
                document.getElementById('status').value = item.status;
                document.getElementById('shipmentDate').value = item.shipmentDate || ''; // Changed from shipment
                document.getElementById('remarks').value = item.remarks;
                openModal('productModal');
            }
        }

        function showFilteredInventory(statusFilter, switchToOosTab = false) {
             if (statusFilter) {
                currentInventoryViewData = inventoryData.filter(item =>
                    !item.isDeleted && item.status && item.status.toLowerCase().includes(statusFilter.toLowerCase())
                );
            } else { // Show all OOS and Low Stock if no specific filter
                 currentInventoryViewData = inventoryData.filter(item =>
                    !item.isDeleted && (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))
                );
            }
            renderInventoryItems();
            if (switchToOosTab) {
                const oosLowStockTabButton = document.querySelector('.tab[onclick*=\'oos-lowstock\']');
                if (oosLowStockTabButton) {
                    switchTab(oosLowStockTabButton, 'oos-lowstock');
                }
            }
        }


        function searchInventory(searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
            
            let baseFilteredData = inventoryData.filter(item =>
                !item.isDeleted && (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))
            );

            if (lowerCaseSearchTerm) {
                currentInventoryViewData = baseFilteredData.filter(item =>
                    (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.status && item.status.toLowerCase().includes(lowerCaseSearchTerm))
                );
            } else {
                currentInventoryViewData = baseFilteredData;
            }
            renderInventoryItems();
        }


        // New Products
        function renderNewProductsItems() {
    const tableBody = document.getElementById('new-products-table');
    if (!tableBody) return;
    tableBody.innerHTML = '';

    const sortedData = sortArray(currentNewProductsViewData, sortState.newProducts.column, sortState.newProducts.direction);

    sortedData.forEach(item => {
        const row = tableBody.insertRow();
        
        // Actions column FIRST
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button class="btn-info" onclick="editNewProduct('${item.id}')">✏️ Edit</button>
            <button class="btn-success" onclick="moveNewProductToMaster('${item.id}')">✅ Approve</button>
            <button class="btn-danger" onclick="moveToRecycleBin('${item.id}', 'new_products')">🗑️ Delete</button>
        `;
        
        // Then other columns
        row.insertCell().textContent = item.sku || '';
        row.insertCell().textContent = item.brand || '';
        row.insertCell().textContent = item.product || '';
        row.insertCell().textContent = item.addedDate || '';
        row.insertCell().textContent = item.arrivalDate || '';
        row.insertCell().textContent = item.quantity !== undefined ? item.quantity : '';
        row.insertCell().textContent = item.notes || '';
        const lastUpdatedCell = row.insertCell();
        lastUpdatedCell.textContent = item.lastUpdated ? new Date(item.lastUpdated).toLocaleString() : '';
    });
}


        function showAddNewProductModal() {
            document.getElementById('newProductModalTitle').textContent = 'Add New Product Entry';
            document.getElementById('editNewProductId').value = '';
            document.getElementById('newProductModal').querySelector('form').reset();
            document.getElementById('arrivalDate').valueAsDate = new Date();
            populateBrandDropdowns('newBrand');
            filterProductsForBrand('', 'newProductName', 'newProductsDatalist');
            openModal('newProductModal');
        }

        async function saveNewProduct(event) {
            event.preventDefault();
            const id = document.getElementById('editNewProductId').value;
            const skuValue = document.getElementById('newProductSku').value.trim();

            if (!skuValue) {
                showNotification('Product Code (SKU) is required for new products.', 'error');
                return;
            }
            if (!id) { 
                const skuExistsInNew = newProductsData.some(p => p.sku === skuValue && !p.isDeleted);
                const skuExistsInMaster = masterProductsData.some(p => p.sku === skuValue && !p.isDeleted);
                if (skuExistsInNew || skuExistsInMaster) {
                    showNotification('This SKU already exists. Please use a unique SKU.', 'error');
                    return;
                }
            }

            const data = {
    brand: document.getElementById('newBrand').value,
    sku: skuValue,
    product: document.getElementById('newProductName').value,
    arrivalDate: document.getElementById('arrivalDate').value,
    quantity: parseInt(document.getElementById('newProductQuantity').value),
    notes: document.getElementById('notes').value,
    addedDate: id ? (newProductsData.find(item => item.id === id)?.addedDate || new Date().toISOString().split('T')[0]) : new Date().toISOString().split('T')[0],
    lastUpdated: new Date().toISOString(),
    isDeleted: false
};

            try {
                await saveDataToFirestore(newProductsColRef, id, data);
                showNotification('New product entry saved successfully!', 'success');
                showBrowserNotification(
  'New Product Added',
  `${document.getElementById('newBrand').value} - ${document.getElementById('newProductName').value} (SKU: ${document.getElementById('newProductSku').value}) has been added.`
);
                closeModal('newProductModal');
                await updateLocalData();
            } catch (e) {
                //error handled
            }
        }

        async function editNewProduct(id) {
            const item = newProductsData.find(p => p.id === id);
            if (item) {
                document.getElementById('newProductModalTitle').textContent = 'Edit New Product Entry';
                document.getElementById('editNewProductId').value = item.id;
                populateBrandDropdowns('newBrand');
                document.getElementById('newBrand').value = item.brand;
                filterProductsForBrand(item.brand, 'newProductName', 'newProductsDatalist');
                document.getElementById('newProductSku').value = item.sku || '';
                document.getElementById('newProductName').value = item.product;
                document.getElementById('arrivalDate').value = item.arrivalDate;
                document.getElementById('newProductQuantity').value = item.quantity;
                document.getElementById('notes').value = item.notes;
                openModal('newProductModal');
            }
        }

        async function moveNewProductToMaster(id) {
            showConfirmModal('Are you sure you want to approve this new product and move it to Master List & Inventory?', async (confirmed) => {
                if (confirmed) {
                    const item = newProductsData.find(p => p.id === id);
                    if (item) {
                        try {
                            const masterProductExists = masterProductsData.find(mp => mp.sku === item.sku && !mp.isDeleted);
                            if (masterProductExists) {
                                showNotification(`SKU ${item.sku} already exists in Master List. Cannot move. Please edit SKU or manage in Master List.`, 'error');
                                return;
                            }

                            const masterProductData = {
                                brand: item.brand,
                                product: item.product,
                                sku: item.sku,
                                wkDemand: 0, // Default WK Demand
                                price: 0.00, 
                                isDeleted: false
                            };
                            await saveDataToFirestore(masterProductsColRef, null, masterProductData);

                            const inventoryProductData = {
                                brand: item.brand,
                                product: item.product,
                                sku: item.sku,
                                quantity: item.quantity,
                                status: 'In stock', // Default status for newly approved
                                shipmentDate: '', 
                                remarks: `Added from New Products (Approved: ${new Date().toISOString().split('T')[0]})`,
                                isDeleted: false
                            };
                            await saveDataToFirestore(inventoryColRef, null, inventoryProductData);
                            await saveDataToFirestore(newProductsColRef, item.id, { isDeleted: true }); 

                            showNotification('Product approved and moved successfully!', 'success');
                            await updateLocalData();
                        } catch (e) {
                            console.error("Error moving new product to master:", e);
                            showNotification('Error moving product.', 'error');
                        }
                    }
                }
            });
        }
        
        async function mergeNewProductsToMaster() {
            showConfirmModal('Are you sure you want to merge ALL new products to Master List & Inventory? SKUs already in Master List will be skipped.', async (confirmed) => {
                if (confirmed) {
                    const batch = db.batch();
                    let successCount = 0;
                    let skippedCount = 0;
                    const activeNewProducts = newProductsData.filter(item => !item.isDeleted);

                    if (activeNewProducts.length === 0) {
                        showNotification('No new products to merge.', 'info');
                        return;
                    }

                    for (const item of activeNewProducts) {
                        const masterProductExists = masterProductsData.find(mp => mp.sku === item.sku && !mp.isDeleted);
                        if (masterProductExists) {
                            skippedCount++;
                            console.warn(`Skipping SKU ${item.sku} as it already exists in Master List.`);
                            continue; 
                        }
                        
                        try {
                            const masterProductRef = masterProductsColRef.doc(); 
                            const masterProductData = {
                                brand: item.brand, product: item.product, sku: item.sku,
                                wkDemand: 0, price: 0.00, isDeleted: false
                            };
                            batch.set(masterProductRef, masterProductData);

                            const inventoryProductRef = inventoryColRef.doc(); 
                            const inventoryProductData = {
                                brand: item.brand, product: item.product, sku: item.sku,
                                quantity: item.quantity, status: 'In stock', shipmentDate: '',
                                remarks: `Added from New Products (Batch Merge: ${new Date().toISOString().split('T')[0]})`,
                                isDeleted: false
                            };
                            batch.set(inventoryProductRef, inventoryProductData);

                            const newProductRef = newProductsColRef.doc(item.id);
                            batch.update(newProductRef, { isDeleted: true });
                            successCount++;
                        } catch (e) {
                            console.error(`Error processing new product ${item.id || item.sku} for merge:`, e);
                        }
                    }

                    if (successCount > 0 || skippedCount > 0) {
                        try {
                            await batch.commit();
                            let message = "";
                            if (successCount > 0) message += `Successfully merged ${successCount} new products. `;
                            if (skippedCount > 0) message += `${skippedCount} products were skipped.`;
                            showNotification(message.trim(), successCount > 0 ? 'success' : 'info');
                            await updateLocalData();
                        } catch (e) {
                            console.error("Batch commit failed:", e);
                            showNotification('Error committing batch merge.', 'error');
                        }
                    } else if (activeNewProducts.length > 0) { 
                         showNotification('Failed to merge new products. Check console.', 'error');
                    } else {
                        showNotification('No new products were eligible for merging.', 'info');
                    }
                }
            });
        }

        function searchNewProducts(searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
            const baseData = newProductsData.filter(item => !item.isDeleted);
            if (lowerCaseSearchTerm) {
                currentNewProductsViewData = baseData.filter(item =>
                    (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm))
                );
            } else {
                currentNewProductsViewData = baseData;
            }
            renderNewProductsItems();
        }

        // ADD this new function (around line 1550, near togglePinToClearItem)
async function togglePinInventoryItem(id) {
    const item = inventoryData.find(p => p.id === id);
    if (item) {
        const newPinnedState = !item.isPinned; // Toggle the current pinned state
        try {
            await saveDataToFirestore(inventoryColRef, id, { 
                isPinned: newPinnedState,
                lastUpdated: new Date().toISOString()
            });
            showNotification(`Product ${newPinnedState ? 'pinned' : 'unpinned'} successfully!`, 'success');
            
            item.isPinned = newPinnedState;
            const viewItem = currentInventoryViewData.find(p => p.id === id);
            if (viewItem) viewItem.isPinned = newPinnedState;
            
            renderInventoryItems(); // Re-render the table
        } catch (e) {
            showNotification('Error updating pin status.', 'error');
            console.error("Error toggling pin status:", e);
        }
    }
}
        
        // To Clear
        async function togglePinToClearItem(id) {
            const item = toClearData.find(p => p.id === id);
            if (item) {
                const newPinnedState = !item.isPinned; // Toggle the current pinned state
                try {
                    await saveDataToFirestore(toClearColRef, id, { 
    isPinned: newPinnedState,
    lastUpdated: new Date().toISOString()
});
                    showNotification(`Product ${newPinnedState ? 'pinned' : 'unpinned'} successfully!`, 'success');
                    
                    item.isPinned = newPinnedState;
                    const viewItem = currentToClearViewData.find(p => p.id === id);
                    if (viewItem) viewItem.isPinned = newPinnedState;
                    
                    renderToClearItems(); // Re-render the table
                } catch (e) {
                    showNotification('Error updating pin status.', 'error');
                    console.error("Error toggling pin status:", e);
                }
            }
        }
        
        function renderToClearItems() {
    const tableBody = document.getElementById('to-clear-table');
    if (!tableBody) return;
    tableBody.innerHTML = '';

    const pinnedItems = currentToClearViewData.filter(item => item.isPinned === true);
    const unpinnedItems = currentToClearViewData.filter(item => !item.isPinned);

    const sortedPinnedItems = sortArray(pinnedItems, sortState.toClear.column, sortState.toClear.direction);
    const sortedUnpinnedItems = sortArray(unpinnedItems, sortState.toClear.column, sortState.toClear.direction);

    const sortedData = [...sortedPinnedItems, ...sortedUnpinnedItems];

    sortedData.forEach(item => {
        const row = tableBody.insertRow();
        
        // Actions column FIRST
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button class="btn-info" onclick="editToClear('${item.id}')">✏️ Edit</button>
            <button class="${item.isPinned ? 'btn-warning' : 'btn-success'}" onclick="togglePinToClearItem('${item.id}')">
                ${item.isPinned ? '➖ Unpin' : '📌 Pin'}
            </button>
            <button class="btn-danger" onclick="moveToRecycleBin('${item.id}', 'to_clear')">🗑️ Delete</button>
        `;
        
        // Then other columns
        row.insertCell().textContent = item.sku || '';
        row.insertCell().textContent = item.brand || '';
        row.insertCell().textContent = item.product || '';
        row.insertCell().textContent = item.expiryDate || '';
        row.insertCell().textContent = item.firstHighlightedDate || '';
        row.insertCell().textContent = item.firstReportedBalance !== undefined ? item.firstReportedBalance : '';
        row.insertCell().textContent = item.warehouseQty !== undefined ? item.warehouseQty : '';
        row.insertCell().textContent = item.storeQty !== undefined ? item.storeQty : '';
        const totalQty = (Number(item.warehouseQty) || 0) + (Number(item.storeQty) || 0);
        row.insertCell().textContent = totalQty;
        row.insertCell().textContent = item.weeklyDemand !== undefined ? item.weeklyDemand : '';
        const weeksSupply = (Number(item.weeklyDemand) || 0) > 0 ? (totalQty / Number(item.weeklyDemand)).toFixed(2) : 'N/A';
        row.insertCell().textContent = weeksSupply;
        const supplyStatusClass = getSupplyStatusClass(item);
        row.insertCell().innerHTML = `<span class="status-badge ${supplyStatusClass}">${getSupplyStatusText(item)}</span>`;
        row.insertCell().textContent = item.remarks || '';
        row.insertCell().textContent = item.actionPlan || '';
        const lastUpdatedCell = row.insertCell();
        lastUpdatedCell.textContent = item.lastUpdated ? new Date(item.lastUpdated).toLocaleString() : '';
    });
}


         function showAddToClearModal() {
            document.getElementById('toClearModalTitle').textContent = 'Add Product to Clear';
            document.getElementById('editToClearId').value = '';
            const form = document.getElementById('toClearModal').querySelector('form');
            if (form) form.reset();

            const firstHighlightedDateInput = document.getElementById('toClearFirstHighlightedDate');
            firstHighlightedDateInput.valueAsDate = new Date(); // Default to today
            firstHighlightedDateInput.readOnly = false; // Make editable for new entries

            const firstReportedBalanceInput = document.getElementById('toClearFirstReportedBalance');
            firstReportedBalanceInput.readOnly = false; // Make editable for new entries
            firstReportedBalanceInput.value = ''; // Clear any previous value


            populateBrandDropdowns('toClearBrand');
            filterProductsForBrand('', 'toClearProductName', 'toClearProductsDatalist');
            document.getElementById('toClearWeeklyDemand').value = '';
            document.getElementById('toClearWarehouseQty').value = 0;
            document.getElementById('toClearStoreQty').value = 0;
            openModal('toClearModal');
        }

        // Staff Claim functions - COMPLETE IMPLEMENTATION
let staffClaimData = [];
let currentStaffClaimViewData = [];
let remarksData = [];
const staffClaimColRef = db.collection('staff_claim');
const remarksColRef = db.collection('remarks');

function renderStaffClaimItems() {
    const tableBody = document.getElementById('staff-claim-table');
    if (!tableBody) return;
    tableBody.innerHTML = '';

    const pinnedItems = currentStaffClaimViewData.filter(item => item.isPinned === true);
    const unpinnedItems = currentStaffClaimViewData.filter(item => !item.isPinned);

    const sortedPinnedItems = sortArray(pinnedItems, sortState.staffClaim?.column, sortState.staffClaim?.direction || 'asc');
    const sortedUnpinnedItems = sortArray(unpinnedItems, sortState.staffClaim?.column, sortState.staffClaim?.direction || 'asc');

    const sortedData = [...sortedPinnedItems, ...sortedUnpinnedItems];

    sortedData.forEach(item => {
        const row = tableBody.insertRow();
        
        // Actions column FIRST
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button class="btn-info" onclick="editStaffClaim('${item.id}')">✏️ Edit</button>
            <button class="${item.isPinned ? 'btn-warning' : 'btn-success'}" onclick="togglePinStaffClaimItem('${item.id}')">
                ${item.isPinned ? '➖ Unpin' : '📌 Pin'}
            </button>
            <button class="btn-danger" onclick="moveToRecycleBin('${item.id}', 'staff_claim')">🗑️ Delete</button>
        `;
        
        // Then other columns
        row.insertCell().textContent = item.sku || '';
        row.insertCell().textContent = item.brand || '';
        row.insertCell().textContent = item.product || '';
        row.insertCell().textContent = item.expiryDate || '';
        row.insertCell().textContent = item.claimRemarks || '';
        row.insertCell().textContent = item.firstReportedBalance !== undefined ? item.firstReportedBalance : '';
        row.insertCell().textContent = item.warehouseQty !== undefined ? item.warehouseQty : '';
        row.insertCell().textContent = item.storeQty !== undefined ? item.storeQty : '';
        const totalQty = (Number(item.warehouseQty) || 0) + (Number(item.storeQty) || 0);
        row.insertCell().textContent = totalQty;
        row.insertCell().textContent = item.weeklyDemand !== undefined ? item.weeklyDemand : '';
        const weeksSupply = (Number(item.weeklyDemand) || 0) > 0 ? (totalQty / Number(item.weeklyDemand)).toFixed(2) : 'N/A';
        row.insertCell().textContent = weeksSupply;
        const supplyStatusClass = getSupplyStatusClass(item);
        row.insertCell().innerHTML = `<span class="status-badge ${supplyStatusClass}">${getSupplyStatusText(item)}</span>`;
        row.insertCell().textContent = item.actionPlan || '';
        const lastUpdatedCell = row.insertCell();
        lastUpdatedCell.textContent = item.lastUpdated ? new Date(item.lastUpdated).toLocaleString() : '';
    });
}

function showAddStaffClaimModal() {
    document.getElementById('staffClaimModalTitle').textContent = 'Add Product to Staff Claim';
    document.getElementById('editStaffClaimId').value = '';
    const form = document.getElementById('staffClaimModal').querySelector('form');
    if (form) form.reset();

    populateBrandDropdowns('staffClaimBrand');
    filterProductsForBrand('', 'staffClaimProductName', 'staffClaimProductsDatalist');
    populateRemarksDropdowns('staffClaimRemarks');
    document.getElementById('staffClaimWeeklyDemand').value = '';
    document.getElementById('staffClaimWarehouseQty').value = 0;
    document.getElementById('staffClaimStoreQty').value = 0;
    openModal('staffClaimModal');
}

function handleStaffClaimBrandChange(brandValue) {
    filterProductsForBrand(brandValue, 'staffClaimProductName', 'staffClaimProductsDatalist');
    document.getElementById('staffClaimWeeklyDemand').value = '';
    document.getElementById('staffClaimProductName').value = '';
}

function handleStaffClaimProductChange() {
    const brand = document.getElementById('staffClaimBrand').value;
    const productName = document.getElementById('staffClaimProductName').value;
    const wkDemandInput = document.getElementById('staffClaimWeeklyDemand');

    if (brand && productName) {
        const masterProduct = masterProductsData.find(mp => 
            !mp.isDeleted && mp.brand === brand && mp.product === productName
        );
        if (masterProduct) {
            wkDemandInput.value = masterProduct.wkDemand !== undefined ? masterProduct.wkDemand : 0;
        } else {
            wkDemandInput.value = 0;
            showNotification("Selected product not found in Master List, or WK Demand is missing. Please check Master List.", "warning");
        }
    } else {
        wkDemandInput.value = '';
    }
}

async function saveStaffClaim(event) {
    event.preventDefault();
    const id = document.getElementById('editStaffClaimId').value;
    const brand = document.getElementById('staffClaimBrand').value;
    const productName = document.getElementById('staffClaimProductName').value;
    const skuValue = getSkuForProduct(brand, productName);

    if (!skuValue) {
        showNotification("Product not found in Master List. Please select a valid product or add it to Master List first.", "error");
        return;
    }
    
    const weeklyDemandValue = parseInt(document.getElementById('staffClaimWeeklyDemand').value || '0');

    const data = {
        brand: brand,
        product: productName,
        sku: skuValue, 
        expiryDate: document.getElementById('staffClaimExpiryDate').value,
        claimRemarks: document.getElementById('staffClaimRemarks').value,
        firstReportedBalance: parseInt(document.getElementById('staffClaimFirstReportedBalance').value || '0'),
        warehouseQty: parseInt(document.getElementById('staffClaimWarehouseQty').value || '0'),
        storeQty: parseInt(document.getElementById('staffClaimStoreQty').value || '0'),
        weeklyDemand: weeklyDemandValue,
        actionPlan: document.getElementById('staffClaimActionPlan').value,
        lastUpdated: new Date().toISOString(),
        isDeleted: false,
        isPinned: id ? (staffClaimData.find(p => p.id === id)?.isPinned || false) : false
    };

    try {
        await saveDataToFirestore(staffClaimColRef, id, data);
        showNotification('Product to staff claim saved successfully!', 'success');
        closeModal('staffClaimModal');
        await updateLocalData();
    } catch (e) {
        //error handled in saveDataToFirestore
    }
}

async function editStaffClaim(id) {
    const item = staffClaimData.find(p => p.id === id);
    if (item) {
        document.getElementById('staffClaimModalTitle').textContent = 'Edit Staff Claim Product';
        document.getElementById('editStaffClaimId').value = item.id;
        
        populateBrandDropdowns('staffClaimBrand');
        document.getElementById('staffClaimBrand').value = item.brand;
        
        filterProductsForBrand(item.brand, 'staffClaimProductName', 'staffClaimProductsDatalist');
        document.getElementById('staffClaimProductName').value = item.product;
        
        document.getElementById('staffClaimWeeklyDemand').value = item.weeklyDemand !== undefined ? item.weeklyDemand : '';
        document.getElementById('staffClaimExpiryDate').value = item.expiryDate;
        populateRemarksDropdowns('staffClaimRemarks');
        document.getElementById('staffClaimRemarks').value = item.claimRemarks;
        document.getElementById('staffClaimFirstReportedBalance').value = item.firstReportedBalance;
        document.getElementById('staffClaimWarehouseQty').value = item.warehouseQty;
        document.getElementById('staffClaimStoreQty').value = item.storeQty;
        document.getElementById('staffClaimActionPlan').value = item.actionPlan;
        openModal('staffClaimModal');
    }
}

async function togglePinStaffClaimItem(id) {
    const item = staffClaimData.find(p => p.id === id);
    if (item) {
        const newPinnedState = !item.isPinned;
        try {
            await saveDataToFirestore(staffClaimColRef, id, { 
                isPinned: newPinnedState,
                lastUpdated: new Date().toISOString()
            });
            showNotification(`Product ${newPinnedState ? 'pinned' : 'unpinned'} successfully!`, 'success');
            
            item.isPinned = newPinnedState;
            const viewItem = currentStaffClaimViewData.find(p => p.id === id);
            if (viewItem) viewItem.isPinned = newPinnedState;
            
            renderStaffClaimItems();
        } catch (e) {
            showNotification('Error updating pin status.', 'error');
            console.error("Error toggling pin status:", e);
        }
    }
}

function searchStaffClaim(searchTerm) {
    const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
    const baseData = staffClaimData.filter(item => !item.isDeleted);
    if (lowerCaseSearchTerm) {
        currentStaffClaimViewData = baseData.filter(item =>
            (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
            (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
            (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm)) ||
            (item.claimRemarks && item.claimRemarks.toLowerCase().includes(lowerCaseSearchTerm)) ||
            (item.actionPlan && item.actionPlan.toLowerCase().includes(lowerCaseSearchTerm))
        );
    } else {
        currentStaffClaimViewData = baseData;
    }
    renderStaffClaimItems();
}

function populateRemarksDropdowns(selectId) {
    const selectElement = document.getElementById(selectId);
    if (!selectElement) return;

    const currentValue = selectElement.value;
    selectElement.innerHTML = '<option value="">Select Remarks</option>';

    let allUniqueRemarks = [...new Set(remarksData.map(item => item.text).filter(Boolean))];
    
    staffClaimData.forEach(item => {
        if (item.claimRemarks && !allUniqueRemarks.includes(item.claimRemarks) && !item.isDeleted) {
            allUniqueRemarks.push(item.claimRemarks);
        }
    });

    allUniqueRemarks.sort((a, b) => a.localeCompare(b));

    allUniqueRemarks.forEach(remark => {
        const option = document.createElement('option');
        option.value = remark;
        option.textContent = remark;
        selectElement.appendChild(option);
    });

    const addNewOption = document.createElement('option');
    addNewOption.value = 'add_new_remark';
    addNewOption.textContent = '+ Add New Remark...';
    selectElement.appendChild(addNewOption);

    if (currentValue && allUniqueRemarks.includes(currentValue)) {
        selectElement.value = currentValue;
    } else if (currentValue === 'add_new_remark') {
        selectElement.value = ''; 
    }

    selectElement.removeEventListener('change', handleRemarksChange);
    selectElement.addEventListener('change', handleRemarksChange);
}

function handleRemarksChange() {
    const selectElement = document.getElementById('staffClaimRemarks');
    if (selectElement && selectElement.value === 'add_new_remark') {
        showAddRemarkModal();
    }
}

function showAddRemarkModal() {
    document.getElementById('addRemarkModal').querySelector('form').reset();
    openModal('addRemarkModal');
}

async function saveNewRemark(event) {
    event.preventDefault();
    const newRemarkTextInput = document.getElementById('newRemarkText');
    const newRemarkText = newRemarkTextInput.value.trim();

    if (!newRemarkText) {
        showNotification('Remark text cannot be empty.', 'error');
        return;
    }
    if (remarksData.some(remark => remark.text.toLowerCase() === newRemarkText.toLowerCase())) {
        showNotification('This remark already exists.', 'error');
        return;
    }
    try {
        await saveDataToFirestore(remarksColRef, null, { text: newRemarkText, isDeleted: false });
        showNotification('Remark added successfully!', 'success');
        closeModal('addRemarkModal');
        await updateLocalData();
        
        // IMPORTANT: Re-populate the remarks dropdown and set the new value
        populateRemarksDropdowns('staffClaimRemarks');
        document.getElementById('staffClaimRemarks').value = newRemarkText;
        
    } catch (e) {
        showNotification('Error adding remark. Check console.', 'error');
        console.error("Error adding new remark:", e);
    }
}
        async function saveToClear(event) {
            event.preventDefault();
            const id = document.getElementById('editToClearId').value;
            const brand = document.getElementById('toClearBrand').value;
            const productName = document.getElementById('toClearProductName').value;
            const skuValue = getSkuForProduct(brand, productName);

            if (!skuValue) {
                showNotification("Product not found in Master List. Please select a valid product or add it to Master List first.", "error");
                return;
            }
            
            const weeklyDemandValue = parseInt(document.getElementById('toClearWeeklyDemand').value || '0');
            const firstHighlightedDateValue = document.getElementById('toClearFirstHighlightedDate').value;
            const firstReportedBalanceValue = parseInt(document.getElementById('toClearFirstReportedBalance').value || '0');

            if (!firstHighlightedDateValue) {
                showNotification("First Highlighted Date is required.", "error");
                return;
            }

        const data = {
    brand: brand,
    product: productName,
    sku: skuValue, 
    expiryDate: document.getElementById('toClearExpiryDate').value,
    firstHighlightedDate: firstHighlightedDateValue,
    firstReportedBalance: firstReportedBalanceValue,
    warehouseQty: parseInt(document.getElementById('toClearWarehouseQty').value || '0'),
    storeQty: parseInt(document.getElementById('toClearStoreQty').value || '0'),
    weeklyDemand: weeklyDemandValue,
    remarks: document.getElementById('toClearRemarks').value,
    actionPlan: document.getElementById('toClearActionPlan').value,
    lastUpdated: new Date().toISOString(),
    isDeleted: false,
    isPinned: id ? (toClearData.find(p => p.id === id)?.isPinned || false) : false
};
            
            if (id) {
                const existingItem = toClearData.find(p => p.id === id);
                if (existingItem) {
                    data.firstHighlightedDate = existingItem.firstHighlightedDate;
                    data.firstReportedBalance = existingItem.firstReportedBalance;
                }
            }


            try {
                await saveDataToFirestore(toClearColRef, id, data);
                showNotification('Product to clear saved successfully!', 'success');
                closeModal('toClearModal');
                await updateLocalData();
            } catch (e) {
                //error handled in saveDataToFirestore
            }
        }
        
        async function editToClear(id) {
            const item = toClearData.find(p => p.id === id);
            if (item) {
                document.getElementById('toClearModalTitle').textContent = 'Edit Product to Clear';
                document.getElementById('editToClearId').value = item.id;
                
                populateBrandDropdowns('toClearBrand');
                document.getElementById('toClearBrand').value = item.brand;
                
                filterProductsForBrand(item.brand, 'toClearProductName', 'toClearProductsDatalist');
                document.getElementById('toClearProductName').value = item.product;
                
                document.getElementById('toClearWeeklyDemand').value = item.weeklyDemand !== undefined ? item.weeklyDemand : '';

                const firstHighlightedDateInput = document.getElementById('toClearFirstHighlightedDate');
                firstHighlightedDateInput.value = item.firstHighlightedDate;
                firstHighlightedDateInput.readOnly = true; // Make read-only for existing entries

                const firstReportedBalanceInput = document.getElementById('toClearFirstReportedBalance');
                firstReportedBalanceInput.value = item.firstReportedBalance;
                firstReportedBalanceInput.readOnly = true; // Make read-only for existing entries

                document.getElementById('toClearExpiryDate').value = item.expiryDate;
                document.getElementById('toClearWarehouseQty').value = item.warehouseQty;
                document.getElementById('toClearStoreQty').value = item.storeQty;
                document.getElementById('toClearRemarks').value = item.remarks || '';
                document.getElementById('toClearActionPlan').value = item.actionPlan;
                openModal('toClearModal');
            }
        }


        function searchToClear(searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
            const baseData = toClearData.filter(item => !item.isDeleted);
            if (lowerCaseSearchTerm) {
                currentToClearViewData = baseData.filter(item =>
                    (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.remarks && item.remarks.toLowerCase().includes(lowerCaseSearchTerm)) || // Search remarks
                    (item.actionPlan && item.actionPlan.toLowerCase().includes(lowerCaseSearchTerm))
                );
            } else {
                currentToClearViewData = baseData;
            }
            renderToClearItems();
        }

        function getSkuForProduct(brand, product) {
            const masterProduct = masterProductsData.find(item => !item.isDeleted && item.brand === brand && item.product === product);
            return masterProduct ? masterProduct.sku : null; // Return null if not found
        }

        function getSupplyStatusClass(item) {
            const expiryDateStr = item.expiryDate;
            const warehouseQty = Number(item.warehouseQty) || 0;
            const storeQty = Number(item.storeQty) || 0;
            const weeklyDemand = Number(item.weeklyDemand) || 0;
            const totalQuantity = warehouseQty + storeQty;

            const today = new Date();
            today.setHours(0, 0, 0, 0); 

            if (!expiryDateStr) return 'info'; 
            const expiryDate = new Date(expiryDateStr);
            expiryDate.setHours(0, 0, 0, 0); 
            if (expiryDate <= today) return 'danger-status'; 
            if (weeklyDemand <= 0) return 'danger-status'; 

            const daysToSellOut = (totalQuantity / weeklyDemand) * 7;
            const projectedSellOutDate = new Date(today.getTime() + daysToSellOut * 24 * 60 * 60 * 1000);
            projectedSellOutDate.setHours(0, 0, 0, 0); 

            const expiryDateMinus9Months = new Date(expiryDate);
            expiryDateMinus9Months.setMonth(expiryDateMinus9Months.getMonth() - 9);
            const expiryDateMinus6Months = new Date(expiryDate);
            expiryDateMinus6Months.setMonth(expiryDateMinus6Months.getMonth() - 6);

            if (projectedSellOutDate <= expiryDateMinus9Months) return 'normal'; 
            else if (projectedSellOutDate <= expiryDateMinus6Months) return 'alert-status'; 
            else return 'danger-status'; 
        }

        function getSupplyStatusText(item) {
            const expiryDateStr = item.expiryDate;
            const warehouseQty = Number(item.warehouseQty) || 0;
            const storeQty = Number(item.storeQty) || 0;
            const weeklyDemand = Number(item.weeklyDemand) || 0;
            const totalQuantity = warehouseQty + storeQty;
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (!expiryDateStr) return 'N/A';
            const expiryDate = new Date(expiryDateStr);
            expiryDate.setHours(0, 0, 0, 0);
            if (expiryDate <= today) return 'Expired';
            if (weeklyDemand <= 0) return 'Danger';

            const daysToSellOut = (totalQuantity / weeklyDemand) * 7;
            const projectedSellOutDate = new Date(today.getTime() + daysToSellOut * 24 * 60 * 60 * 1000);
            projectedSellOutDate.setHours(0, 0, 0, 0);
            
            const expiryDateMinus9Months = new Date(expiryDate);
            expiryDateMinus9Months.setMonth(expiryDateMinus9Months.getMonth() - 9);
            const expiryDateMinus6Months = new Date(expiryDate);
            expiryDateMinus6Months.setMonth(expiryDateMinus6Months.getMonth() - 6);

            if (projectedSellOutDate <= expiryDateMinus9Months) return 'Normal';
            else if (projectedSellOutDate <= expiryDateMinus6Months) return 'Alert';
            else return 'Danger';
        }


        // Master List
        function renderMasterListItems() {
    const tableBody = document.getElementById('master-table');
    if (!tableBody) return;
    tableBody.innerHTML = '';

    const sortedData = sortArray(currentMasterListViewData, sortState.master.column, sortState.master.direction);

    sortedData.forEach(item => {
        const row = tableBody.insertRow();
        
        // Actions column FIRST
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button class="btn-info" onclick="editMasterProduct('${item.id}')">✏️ Edit</button>
            <button class="btn-danger" onclick="moveToRecycleBin('${item.id}', 'master_products')">🗑️ Delete</button>
        `;
        
        // Then other columns
        row.insertCell().textContent = item.sku || '';
        row.insertCell().textContent = item.brand || '';
        row.insertCell().textContent = item.product || '';
        row.insertCell().textContent = item.wkDemand !== undefined ? item.wkDemand : '';
        
        const expiryDateCell = row.insertCell();
        if (item.expiryDate) {
            const [year, month] = item.expiryDate.split('-');
            const dateObj = new Date(year, month - 1);
            const monthName = dateObj.toLocaleString('default', { month: 'short' });
            const shortYear = year.slice(-2);
            expiryDateCell.textContent = `${monthName}-${shortYear}`;
        } else {
            expiryDateCell.textContent = '';
        }

        row.insertCell().textContent = item.price !== undefined ? parseFloat(item.price).toFixed(2) : '';
    });
}

        function showAddMasterProductModal() {
    document.getElementById('masterProductModalTitle').textContent = 'Add Master Product';
    document.getElementById('editMasterProductId').value = '';
    document.getElementById('masterProductModal').querySelector('form').reset();
    populateBrandDropdowns('masterBrand');
    document.getElementById('wkDemand').value = 0; // Default WK Demand

    // Populate the expiry dropdowns for a new product (they will be empty)
    populateExpiryDateSelectors(null);

    openModal('masterProductModal');
}
// New helper function to populate Month and Year dropdowns
function populateExpiryDateSelectors(selectedDate) { // selectedDate is 'YYYY-MM' or null
    const monthSelect = document.getElementById('masterExpiryMonth');
    const yearSelect = document.getElementById('masterExpiryYear');

    monthSelect.innerHTML = '<option value="">Month</option>';
    yearSelect.innerHTML = '<option value="">Year</option>';

    // Populate months
    for (let i = 1; i <= 12; i++) {
        const monthStr = String(i).padStart(2, '0');
        const monthName = new Date(2000, i - 1, 1).toLocaleString('default', { month: 'long' });
        monthSelect.innerHTML += `<option value="${monthStr}">${monthName}</option>`;
    }

    // Populate years (e.g., this year to 15 years from now)
    const currentYear = new Date().getFullYear();
    for (let i = currentYear; i <= currentYear + 15; i++) {
        yearSelect.innerHTML += `<option value="${i}">${i}</option>`;
    }

    // Set selected values if they exist
    if (selectedDate && selectedDate.includes('-')) {
        const [year, month] = selectedDate.split('-');
        monthSelect.value = month;

        // If the year is old and not in the list, add it dynamically
        if (!Array.from(yearSelect.options).some(opt => opt.value === year)) {
             const option = document.createElement('option');
             option.value = year;
             option.textContent = year;
             // Insert it at the correct position (e.g., after the placeholder)
             yearSelect.insertBefore(option, yearSelect.options[1]);
        }
        yearSelect.value = year;
    }
}
        async function saveMasterProduct(event) {
    event.preventDefault();
    const id = document.getElementById('editMasterProductId').value;
    const sku = document.getElementById('sku').value.trim();
    const productName = document.getElementById('masterProductName').value.trim();
    const brandName = document.getElementById('masterBrand').value;

    if (!sku || !productName || !brandName) {
        showNotification('SKU, Product Name, and Brand are required.', 'error');
        return;
    }

    if (masterProductsData.some(p => p.sku === sku && p.id !== id && !p.isDeleted)) {
        showNotification('This SKU already exists for another product.', 'error');
        return;
    }
    if (masterProductsData.some(p => p.brand === brandName && p.product === productName && p.id !== id && !p.isDeleted)) {
         showNotification('This Brand and Product Name combination already exists.', 'error');
        return;
    }
    
    const month = document.getElementById('masterExpiryMonth').value;
    const year = document.getElementById('masterExpiryYear').value;
    const expiryDateValue = (year && month) ? `${year}-${month}` : '';

    const data = {
        brand: brandName,
        product: productName,
        wkDemand: parseInt(document.getElementById('wkDemand').value || '0'),
        expiryDate: expiryDateValue, // Use combined value from dropdowns
        sku: sku,
        price: parseFloat(document.getElementById('price').value || '0'),
        isDeleted: false
    };

    try {
        await saveDataToFirestore(masterProductsColRef, id, data);
        showNotification('Master product saved successfully!', 'success');
        closeModal('masterProductModal');
        await updateLocalData();
    } catch (e) {
        //error handled
    }
}

        async function editMasterProduct(id) {
    const item = masterProductsData.find(p => p.id === id);
    if (item) {
        document.getElementById('masterProductModalTitle').textContent = 'Edit Master Product';
        document.getElementById('editMasterProductId').value = item.id;
        populateBrandDropdowns('masterBrand');
        document.getElementById('masterBrand').value = item.brand;
        document.getElementById('masterProductName').value = item.product;
        document.getElementById('wkDemand').value = item.wkDemand !== undefined ? item.wkDemand : '';
        
        // This function now populates the dropdowns
        populateExpiryDateSelectors(item.expiryDate || ''); 

        document.getElementById('sku').value = item.sku;
        document.getElementById('price').value = item.price;
        openModal('masterProductModal');
    }
}
        function searchMasterList(searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
            const baseData = masterProductsData.filter(item => !item.isDeleted);
            if (lowerCaseSearchTerm) {
                currentMasterListViewData = baseData.filter(item =>
                    (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm))
                );
            } else {
                currentMasterListViewData = baseData;
            }
            renderMasterListItems();
        }

        function exportMasterList() {
            const headers = ["Product Code", "Brand", "Product Name", "WK Demand", "Expiry Date", "Price"];
            const activeMasterList = masterProductsData.filter(item => !item.isDeleted);
            const rows = activeMasterList.map(item => {
                let formattedExpiry = '';
                if (item.expiryDate) { // Stored as 'YYYY-MM'
                    const [year, month] = item.expiryDate.split('-');
                    const dateObj = new Date(year, month - 1);
                    const monthName = dateObj.toLocaleString('default', { month: 'short' });
                    const shortYear = year.slice(-2);
                    formattedExpiry = `${monthName}-${shortYear}`;
                }
                return [
                    item.sku || '',
                    item.brand || '',
                    item.product || '',
                    item.wkDemand !== undefined ? item.wkDemand : '',
                    formattedExpiry,
                    item.price !== undefined ? parseFloat(item.price).toFixed(2) : ''
                ];
            });

            let csvContent = headers.join(',') + '\n';
            rows.forEach(row => {
                csvContent += row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',') + '\n';
            });

            downloadCSV(csvContent, 'master_list.csv');
            showNotification('Master list exported!', 'success');
        }

        // Recycle Bin
        function renderRecycleBinItems() {
    const tableBody = document.getElementById('recycle-bin-table');
    if (!tableBody) return;
    tableBody.innerHTML = '';

    const sortedData = sortArray(currentRecycleBinViewData, sortState.recycleBin.column, sortState.recycleBin.direction);

    sortedData.forEach(item => {
        const row = tableBody.insertRow();
        
        // Actions column FIRST
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button class="btn-success" onclick="restoreItem('${item.id}', '${item.originalCollection}')">↩️ Restore</button>
            <button class="btn-danger" onclick="deleteItemPermanently('${item.id}', '${item.originalCollection}')">❌ Permanent Delete</button>
        `;
        
        // Then other columns
        row.insertCell().textContent = item.sku || '';
        row.insertCell().textContent = item.originalCollection || '';
        row.insertCell().textContent = item.brand || '';
        row.insertCell().textContent = item.product || '';
    });
}

        async function moveToRecycleBin(id, collectionName) {
            showConfirmModal('Are you sure you want to move this item to Recycle Bin?', async (confirmed) => {
                if (confirmed) {
                    try {
                        const collectionRef = db.collection(collectionName);
                        await saveDataToFirestore(collectionRef, id, { isDeleted: true });
                        showNotification('Item moved to Recycle Bin!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error(`Error moving item to recycle bin from ${collectionName}:`, e);
                        showNotification('Error moving item to Recycle Bin.', 'error');
                    }
                }
            });
        }

        async function restoreItem(id, originalCollection) {
            showConfirmModal('Are you sure you want to restore this item?', async (confirmed) => {
                if (confirmed) {
                    try {
                        const itemToRestore = deletedItemsData.find(item => item.id === id && item.originalCollection === originalCollection);
                        if (!itemToRestore) {
                             showNotification('Item not found for restoration.', 'error');
                             return;
                        }

                        if (originalCollection === 'master_products' || originalCollection === 'new_products') {
                            const sku = itemToRestore.sku;
                            if (sku) {
                                if ( (originalCollection === 'master_products' && masterProductsData.some(p => p.sku === sku && !p.isDeleted && p.id !== id)) ||
                                     (originalCollection === 'new_products' && newProductsData.some(p => p.sku === sku && !p.isDeleted && p.id !== id)) ) {
                                     showNotification(`Cannot restore: SKU ${sku} already exists in an active item in ${originalCollection}. Please resolve conflict first.`, 'error');
                                     return;
                                }
                            }
                        }

                        const collectionRef = db.collection(originalCollection);
                        await saveDataToFirestore(collectionRef, id, { isDeleted: false });
                        showNotification('Item restored successfully!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error(`Error restoring item to ${originalCollection}:`, e);
                        showNotification('Error restoring item.', 'error');
                    }
                }
            });
        }

        async function deleteItemPermanently(id, originalCollection) {
            showConfirmModal('WARNING: This will permanently delete this item. Are you sure?', async (confirmed) => {
                if (confirmed) {
                    try {
                        const collectionRef = db.collection(originalCollection);
                        await collectionRef.doc(id).delete();
                        showNotification('Item permanently deleted!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error(`Error permanently deleting item from ${originalCollection}:`, e);
                        showNotification('Error permanently deleting item.', 'error');
                    }
                }
            });
        }

        async function emptyRecycleBin() {
            showConfirmModal('WARNING: This will permanently delete ALL items in the Recycle Bin. Are you sure?', async (confirmed) => {
                if (confirmed) {
                    if (deletedItemsData.length === 0) {
                        showNotification('Recycle Bin is already empty.', 'info');
                        return;
                    }
                    const batch = db.batch();
                    let deleteCount = 0;
                    for (const item of deletedItemsData) {
                        try {
                            const collectionRef = db.collection(item.originalCollection);
                            batch.delete(collectionRef.doc(item.id));
                            deleteCount++;
                        } catch (e) {
                            console.error(`Error adding item ${item.id} to batch for permanent deletion:`, e);
                        }
                    }

                    if (deleteCount > 0) {
                        try {
                            await batch.commit();
                            showNotification(`Successfully deleted ${deleteCount} items permanently.`, 'success');
                            await updateLocalData();
                        } catch (e) {
                            console.error("Batch commit for empty recycle bin failed:", e);
                            showNotification('Error emptying recycle bin.', 'error');
                        }
                    } else {
                         showNotification('No items were eligible for deletion, or an error occurred preparing deletions.', 'info');
                    }
                }
            });
        }

        function searchRecycleBin(searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
             if (lowerCaseSearchTerm) {
                currentRecycleBinViewData = deletedItemsData.filter(item =>
                    (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.originalCollection && item.originalCollection.toLowerCase().includes(lowerCaseSearchTerm))
                );
            } else {
                currentRecycleBinViewData = [...deletedItemsData];
            }
            renderRecycleBinItems();
        }
        
        function showAddBrandModal() {
            document.getElementById('addBrandModal').querySelector('form').reset();
            openModal('addBrandModal');
        }

        function showAddStatusModal() {
            document.getElementById('addStatusModal').querySelector('form').reset();
            openModal('addStatusModal');
        }

        async function saveNewBrand(event) {
            event.preventDefault();
            const newBrandNameInput = document.getElementById('newBrandName');
            const newBrandName = newBrandNameInput.value.trim();

            if (!newBrandName) {
                showNotification('Brand name cannot be empty.', 'error');
                return;
            }
            if (brandsData.some(brand => brand.name.toLowerCase() === newBrandName.toLowerCase())) {
                showNotification('This brand already exists.', 'error');
                return;
            }
            try {
                await saveDataToFirestore(brandsColRef, null, { name: newBrandName, isDeleted: false });
                showNotification('Brand added successfully!', 'success');
                closeModal('addBrandModal'); 
                await updateLocalData(); 
            } catch (e) {
                showNotification('Error adding brand. Check console.', 'error');
                console.error("Error adding new brand:", e);
            }
        }

        async function saveNewStatus(event) {
            event.preventDefault();
            const newStatusNameInput = document.getElementById('newStatusName');
            const newStatusName = newStatusNameInput.value.trim();

            if (!newStatusName) {
                showNotification('Status name cannot be empty.', 'error');
                return;
            }
            if (statusesData.some(status => status.name.toLowerCase() === newStatusName.toLowerCase())) {
                showNotification('This status already exists.', 'error');
                return;
            }
            try {
                await saveDataToFirestore(statusesColRef, null, { name: newStatusName, isDeleted: false });
                showNotification('Status added successfully!', 'success');
                closeModal('addStatusModal');
                await updateLocalData();
            } catch (e) {
                showNotification('Error adding status. Check console.', 'error');
                console.error("Error adding new status:", e);
            }
        }

        // Management Tab Functions
        function getTableDataForExport(tableKey, dataArray) {
            let headers = [];
            let rows = [];

            if (tableKey === 'inventory') {
    headers = ["Product Code", "Brand", "Product", "Quantity", "Status", "Shipment Date", "Remarks", "Last Updated"];
    rows = dataArray.filter(item => !item.isDeleted && (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))).map(item => [
        item.sku || '', item.brand || '', item.product || '',
        item.quantity !== undefined ? item.quantity : '',
        item.status || '', item.shipmentDate || '', item.remarks || '',
        item.lastUpdated ? new Date(item.lastUpdated).toLocaleString() : ''
    ]);
} else if (tableKey === 'new_products') {
    headers = ["Product Code", "Brand", "Product", "Added Date", "Arrival Date", "Quantity", "Notes", "Last Updated"];
    rows = dataArray.filter(item => !item.isDeleted).map(item => [
        item.sku || '', item.brand || '', item.product || '',
        item.addedDate || '', item.arrivalDate || '',
        item.quantity !== undefined ? item.quantity : '', item.notes || '',
        item.lastUpdated ? new Date(item.lastUpdated).toLocaleString() : ''
    ]);
} else if (tableKey === 'to_clear') {
    headers = ["Product Code", "Brand", "Product", "Expiry Date", "First Highlighted", "Initial Bal", "WH Qty", "Store Qty", "Total Qty", "Wk Demand", "Wks Supply", "Supply Status", "Remarks", "Action Plan", "Last Updated"];
    rows = dataArray.filter(item => !item.isDeleted).map(item => {
        const totalQty = (Number(item.warehouseQty) || 0) + (Number(item.storeQty) || 0);
        const weeksSupply = (Number(item.weeklyDemand) || 0) > 0 ? (totalQty / Number(item.weeklyDemand)).toFixed(2) : 'N/A';
        return [
            item.sku || '', item.brand || '', item.product || '',
            item.expiryDate || '', item.firstHighlightedDate || '',
            item.firstReportedBalance !== undefined ? item.firstReportedBalance : '',
            item.warehouseQty !== undefined ? item.warehouseQty : '',
            item.storeQty !== undefined ? item.storeQty : '',
            totalQty,
            item.weeklyDemand !== undefined ? item.weeklyDemand : '',
            weeksSupply, getSupplyStatusText(item), item.remarks || '', item.actionPlan || '',
            item.lastUpdated ? new Date(item.lastUpdated).toLocaleString() : ''
        ];
    });
} else if (tableKey === 'master_products') {
                headers = ["Product Code", "Brand", "Product Name", "WK Demand", "Expiry Date", "Price"];
                rows = dataArray.filter(item => !item.isDeleted).map(item => {
                    let formattedExpiry = '';
                    if (item.expiryDate) { // Stored as 'YYYY-MM'
                        const [year, month] = item.expiryDate.split('-');
                        const dateObj = new Date(year, month - 1);
                        const monthName = dateObj.toLocaleString('default', { month: 'short' });
                        const shortYear = year.slice(-2);
                        formattedExpiry = `${monthName}-${shortYear}`;
                    }
                    return [
                        item.sku || '',
                        item.brand || '',
                        item.product || '',
                        item.wkDemand !== undefined ? item.wkDemand : '',
                        formattedExpiry,
                        item.price !== undefined ? parseFloat(item.price).toFixed(2) : ''
                    ];
                });
            }
            return { headers, rows };
        }

       async function exportAllData() {
            if (typeof JSZip === 'undefined') {
                showNotification('Data export library (JSZip) is not loaded. Please try again in a moment or check console.', 'error');
                console.error('JSZip library not found for exportAllData.');
                // Attempt to load JSZip if not found - useful if initial load failed
                if (!document.querySelector('script[src*="jszip.min.js"]')) {
                    const script = document.createElement('script');
                    script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js";
                    script.onload = () => {
                        console.log("JSZip loaded dynamically. Please try exporting again.");
                        showNotification("JSZip loaded. Please click Export All Data again.", "info");
                    };
                    script.onerror = () => console.error("Failed to load JSZip dynamically.");
                    document.head.appendChild(script);
                }
                return;
            }

            let zip = new JSZip();
            const collectionsToExport = [
                { key: 'inventory', data: inventoryData, fileName: 'oos_low_stock_products.csv' },
                { key: 'new_products', data: newProductsData, fileName: 'new_products.csv' },
                { key: 'to_clear', data: toClearData, fileName: 'to_clear_products.csv' },
                { key: 'master_products', data: masterProductsData, fileName: 'master_list.csv' }
            ];

            for (const collectionInfo of collectionsToExport) {
                const { headers, rows } = getTableDataForExport(collectionInfo.key, collectionInfo.data);
                if (rows.length === 0) continue;
                let csvContent = headers.map(h => `"${String(h).replace(/"/g, '""')}"`).join(',') + '\n';
                rows.forEach(row => {
                    csvContent += row.map(f => `"${String(f !== undefined && f !== null ? f : '').replace(/"/g, '""')}"`).join(',') + '\n';
                });
                zip.file(collectionInfo.fileName, csvContent);
            }

            try {
                const content = await zip.generateAsync({ type: "blob" });
                downloadBlob(content, 'inventory_reports.zip');
                showNotification('Selected data exported as ZIP!', 'success');
            } catch (e) {
                console.error("Error generating zip file:", e);
                showNotification('Error exporting all data.', 'error');
            }
        }
        
        function downloadBlob(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }


        async function loadSampleData() {
            showNotification('Loading sample data... This may take a moment.', 'info');
            const sampleBrands = [
                { name: 'BrandX', isDeleted: false }, { name: 'BrandY', isDeleted: false }, { name: 'BrandZ', isDeleted: false },
                { name: 'BrandA', isDeleted: false }, { name: 'BrandB', isDeleted: false }, { name: 'BrandC', isDeleted: false }
            ];
            const sampleStatuses = [ // "In stock" is not added here by default for OOS/LOW selection logic
                { name: 'OOS', isDeleted: false }, { name: 'Low stock', isDeleted: false }, { name: 'Awaiting Delivery', isDeleted: false }
            ];
            const sampleMasterProducts = [
                { brand: 'BrandX', product: 'Laptop Pro', sku: 'LX1001', wkDemand: 10, expiryDate: '2027-12', price: 1200.00, isDeleted: false },
                { brand: 'BrandY', product: 'Wireless Mouse', sku: 'WM2002', wkDemand: 25, expiryDate: '2026-06', price: 25.00, isDeleted: false },
                { brand: 'BrandX', product: 'Mechanical Keyboard', sku: 'MK3003', wkDemand: 15, expiryDate: '', price: 80.00, isDeleted: false },
                { brand: 'BrandZ', product: 'Smart Speaker', sku: 'SS4004', wkDemand: 5, expiryDate: '2028-01', price: 99.00, isDeleted: false },
                { brand: 'BrandA', product: 'Ergonomic Chair', sku: 'EC5005', wkDemand: 2, expiryDate: '2029-05', price: 350.00, isDeleted: false },
                { brand: 'BrandB', product: 'Old Stock Monitor', sku: 'OSM6006', wkDemand: 1, expiryDate: '2025-07', price: 150.00, isDeleted: false },
                { brand: 'BrandC', product: 'Demo Unit Tablet', sku: 'DUT7007', wkDemand: 0, expiryDate: '2025-08', price: 100.00, isDeleted: false }
            ];
            const sampleInventory = [
                { brand: 'BrandX', product: 'Laptop Pro', sku: 'LX1001', quantity: 5, status: 'Low stock', shipmentDate: '2025-07-01', remarks: 'Partial shipment received', isDeleted: false },
                { brand: 'BrandY', product: 'Wireless Mouse', sku: 'WM2002', quantity: 0, status: 'OOS', shipmentDate: '2025-07-15', remarks: 'Awaiting restock', isDeleted: false },
                { brand: 'BrandX', product: 'Mechanical Keyboard', sku: 'MK3003', quantity: 20, status: 'Low stock', shipmentDate: '', remarks: '', isDeleted: false } // Example of 'In stock' like, but low
            ];
            const sampleNewProducts = [
                { brand: 'BrandZ', product: 'Smart Speaker', sku: 'SS4004', arrivalDate: '2025-06-15', quantity: 50, notes: 'New model launch', addedDate: '2025-05-20', isDeleted: false },
                { brand: 'BrandA', product: 'Ergonomic Chair', sku: 'EC5005', arrivalDate: '2025-06-20', quantity: 15, notes: '', addedDate: '2025-05-25', isDeleted: false }
            ];
            const sampleToClear = [
                { brand: 'BrandB', product: 'Old Stock Monitor', sku: 'OSM6006', expiryDate: '2025-07-31', firstHighlightedDate: '2025-05-01', firstReportedBalance: 20, warehouseQty: 10, storeQty: 5, weeklyDemand: 1, remarks: 'Slight scratch on bezel', actionPlan: 'Promotional discount 20%', isDeleted: false },
                { brand: 'BrandC', product: 'Demo Unit Tablet', sku: 'DUT7007', expiryDate: '2025-08-30', firstHighlightedDate: '2025-05-10', firstReportedBalance: 5, warehouseQty: 1, storeQty: 2, weeklyDemand: 0, remarks: 'Used for display', actionPlan: 'Bundle with accessories', isDeleted: false }
            ];
            
            const collectionsAndData = [
                { ref: brandsColRef, data: sampleBrands },
                { ref: statusesColRef, data: sampleStatuses },
                { ref: masterProductsColRef, data: sampleMasterProducts },
                { ref: inventoryColRef, data: sampleInventory },
                { ref: newProductsColRef, data: sampleNewProducts },
                { ref: toClearColRef, data: sampleToClear }
            ];

            try {
                // Clear existing data
                for (const { ref } of collectionsAndData) {
                    const snapshot = await ref.get();
                    if (snapshot.docs.length > 0) {
                        const deleteBatch = db.batch();
                        snapshot.docs.forEach(doc => deleteBatch.delete(doc.ref));
                        await deleteBatch.commit();
                    }
                }
                // Load new sample data
                const loadBatch = db.batch();
                for (const { ref, data } of collectionsAndData) {
                    data.forEach(item => {
                        const docRef = ref.doc(); 
                        loadBatch.set(docRef, item);
                    });
                }
                await loadBatch.commit();
                showNotification('Sample data loaded successfully!', 'success');
                await updateLocalData();
            } catch (e) {
                console.error("Error loading sample data:", e);
                showNotification('Error loading sample data. Check console.', 'error');
            }
        }


        function confirmLoadSampleData() {
            showConfirmModal('WARNING: This will delete ALL existing data and load sample data. Are you sure?', async (confirmed) => {
                if (confirmed) {
                    await loadSampleData();
                }
            });
        }

        // Sorting
        function sortTable(tableKey, column) {
            const tableSortState = sortState[tableKey];
            if (tableSortState.column === column) {
                tableSortState.direction = tableSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                tableSortState.column = column;
                tableSortState.direction = 'asc';
            }
            updateSortIndicators(tableKey);
            if (tableKey === 'inventory') renderInventoryItems();
            else if (tableKey === 'newProducts') renderNewProductsItems();
            else if (tableKey === 'master') renderMasterListItems();
            else if (tableKey === 'toClear') renderToClearItems();
            else if (tableKey === 'recycleBin') renderRecycleBinItems();
        }

        function sortArray(arr, column, direction) {
            if (!column || !arr) return arr || []; 

            return [...arr].sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                if (sortState.toClear.column === 'totalQty' && column === 'totalQty') {
                    valA = (Number(a.warehouseQty) || 0) + (Number(a.storeQty) || 0);
                    valB = (Number(b.warehouseQty) || 0) + (Number(b.storeQty) || 0);
                } else if (sortState.toClear.column === 'weeksSupply' && column === 'weeksSupply') {
                    const totalA = (Number(a.warehouseQty) || 0) + (Number(a.storeQty) || 0);
                    valA = (Number(a.weeklyDemand) || 0) > 0 ? (totalA / Number(a.weeklyDemand)) : (direction === 'asc' ? Infinity : -Infinity);
                    const totalB = (Number(b.warehouseQty) || 0) + (Number(b.storeQty) || 0);
                    valB = (Number(b.weeklyDemand) || 0) > 0 ? (totalB / Number(b.weeklyDemand)) : (direction === 'asc' ? Infinity : -Infinity);
                }

                const aUndefined = (valA === undefined || valA === null || valA === '' || valA === 'N/A' || (typeof valA === 'number' && isNaN(valA)) );
                const bUndefined = (valB === undefined || valB === null || valB === '' || valB === 'N/A' || (typeof valB === 'number' && isNaN(valB)) );

                if (aUndefined && bUndefined) return 0;
                if (aUndefined) return direction === 'asc' ? 1 : -1;
                if (bUndefined) return direction === 'asc' ? -1 : 1;

                if (typeof valA === 'string' && typeof valB === 'string') {
                    // YYYY-MM-DD for to_clear or YYYY-MM for master
                    if (/^\d{4}-\d{2}(-\d{2})?$/.test(valA) && /^\d{4}-\d{2}(-\d{2})?$/.test(valB)) { 
                        return direction === 'asc' ? new Date(valA) - new Date(valB) : new Date(valB) - new Date(valA);
                    }
                    const numA = parseFloat(valA);
                    const numB = parseFloat(valB);
                    if (!isNaN(numA) && !isNaN(numB) && String(numA) === valA && String(numB) === valB) {
                         return direction === 'asc' ? numA - numB : numB - numA;
                    }
                    return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return direction === 'asc' ? valA - valB : valB - valA;
                }
                
                const strA = String(valA);
                const strB = String(valB);
                return direction === 'asc' ? strA.localeCompare(strB) : strB.localeCompare(strA);
            });
        }

        function updateSortIndicators(tableKey) {
            const tableContainerId = `${tableKey === 'master' ? 'master-table' : tableKey}-table-container`;
            const tableContainer = document.getElementById(tableContainerId);
            let headers;

            if (tableContainer && tableContainer.querySelector('thead')) {
                headers = tableContainer.querySelectorAll('thead th[data-column-key]');
            } else {
                return;
            }
            
            headers.forEach(header => {
                const arrowSpan = header.querySelector('.sort-arrow');
                if (arrowSpan) arrowSpan.textContent = ''; 
                if (header.dataset.columnKey === sortState[tableKey].column) {
                    if (arrowSpan) arrowSpan.textContent = sortState[tableKey].direction === 'asc' ? ' ▲' : ' ▼';
                }
            });
        }

        // Dashboard Stats
        function updateDashboardStats() {
            document.getElementById('oos-count').textContent = inventoryData.filter(item => !item.isDeleted && item.status === 'OOS').length;
            document.getElementById('low-count').textContent = inventoryData.filter(item => !item.isDeleted && item.status && item.status.toLowerCase().includes('low stock')).length;
            document.getElementById('new-count').textContent = newProductsData.filter(item => !item.isDeleted).length;
            document.getElementById('to-clear-count').textContent = toClearData.filter(item => !item.isDeleted).length;
            document.getElementById('staff-claim-count').textContent = staffClaimData.filter(item => !item.isDeleted).length;
        }

        function updateAlerts() {
            const alertsDiv = document.getElementById('alerts');
            alertsDiv.innerHTML = '';
            let alertContent = '';

            const recentOOS = inventoryData.filter(item => !item.isDeleted && item.status === 'OOS').slice(0, 5);
            const recentLowStock = inventoryData.filter(item => !item.isDeleted && item.status && item.status.toLowerCase().includes('low stock')).slice(0, 5);
            
            const today = new Date();
            today.setHours(0, 0, 0, 0); 
            const ninetyDaysFromToday = new Date(today);
            ninetyDaysFromToday.setDate(today.getDate() + 90);

            const expiringSoon = toClearData.filter(item => {
                if (!item.isDeleted && item.expiryDate) {
                    try {
                        const expiryParts = item.expiryDate.split('-');
                        const expiry = new Date(expiryParts[0], expiryParts[1] - 1, expiryParts[2]);
                        expiry.setHours(0,0,0,0);
                        return expiry >= today && expiry <= ninetyDaysFromToday;
                    } catch (e) { console.warn("Error parsing expiry date for alert:", item.expiryDate, e); return false; }
                }
                return false;
            }).sort((a,b) => new Date(a.expiryDate) - new Date(b.expiryDate)).slice(0, 5);

            if (recentOOS.length > 0) {
                alertContent += '<h4>Out of Stock Items:</h4><ul>' +
                    recentOOS.map(item => `<li><span class="status-badge oos">OOS</span> ${item.product || 'N/A'} (${item.brand || 'N/A'})</li>`).join('') +
                    '</ul>';
            }
            if (recentLowStock.length > 0) {
                alertContent += '<h4>Low Stock Items:</h4><ul>' +
                    recentLowStock.map(item => `<li><span class="status-badge low">Low</span> ${item.product || 'N/A'} (${item.brand || 'N/A'}) - Qty: ${item.quantity}</li>`).join('') +
                    '</ul>';
            }
            if (expiringSoon.length > 0) {
                alertContent += '<h4>Expiring Soon Items (within 90 days):</h4><ul>' +
                    expiringSoon.map(item => `<li><span class="status-badge alert-status">Expiring</span> ${item.product || 'N/A'} (${item.brand || 'N/A'}) - Expiry: ${item.expiryDate}</li>`).join('') +
                    '</ul>';
            }
            
            // New section for Top 5 Danger Items from To Clear list
            const dangerToClearItems = toClearData.filter(item => {
                if (item.isDeleted) return false;
                const statusText = getSupplyStatusText(item);
                return statusText === 'Danger' || statusText === 'Expired';
            }).sort((a, b) => {
                const statusTextA = getSupplyStatusText(a);
                const statusTextB = getSupplyStatusText(b);

                // Prioritize 'Expired' items over 'Danger' items
                if (statusTextA === 'Expired' && statusTextB !== 'Expired') return -1;
                if (statusTextA !== 'Expired' && statusTextB === 'Expired') return 1;

                // For items with the same status ('Expired' or 'Danger'), sort by expiryDate (earliest first)
                const dateA = a.expiryDate ? new Date(a.expiryDate) : null;
                const dateB = b.expiryDate ? new Date(b.expiryDate) : null;

                if (dateA && dateB) {
                    return dateA - dateB;
                } else if (dateA) { // Only A has a valid date, so it comes first
                    return -1;
                } else if (dateB) { // Only B has a valid date, so it comes first
                    return 1;
                }
                return 0; 
            }).slice(0, 5);

            if (dangerToClearItems.length > 0) {
                alertContent += '<h4>Danger Zone (To Clear):</h4><ul>' +
                    dangerToClearItems.map(item => {
                        const statusText = getSupplyStatusText(item); // Will be 'Expired' or 'Danger'
                        const badgeClass = getSupplyStatusClass(item); // Should correctly return 'danger-status'
                        return `<li><span class="status-badge ${badgeClass}">${statusText}</span> ${item.product || 'N/A'} (${item.brand || 'N/A'}) - SKU: ${item.sku || 'N/A'}${item.expiryDate ? `, Exp: ${item.expiryDate}` : ''}</li>`;
                    }).join('') +
                    '</ul>';
            }
            
            alertsDiv.innerHTML = alertContent || '<p>No immediate alerts.</p>';
        }

        function updateManagementStats() {
            const activeMasterProductsCount = masterProductsData.filter(item => !item.isDeleted).length;
            document.getElementById('total-products').textContent = activeMasterProductsCount;
            
            const allUniqueSkus = new Set(masterProductsData.filter(item => !item.isDeleted && item.sku).map(item => item.sku));
            document.getElementById('total-products-all').textContent = allUniqueSkus.size; 
            document.getElementById('last-updated').textContent = new Date().toLocaleString();
        }

        function downloadCSV(csvContent, fileName) {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            downloadBlob(blob, fileName);
        }

        async function importCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                const lines = text.split(/\r\n|\n/).filter(line => line.trim() !== ''); 
                if (lines.length < 2) { 
                    showNotification('CSV file is empty, invalid, or has no data rows.', 'error');
                    event.target.value = ''; 
                    return;
                }

                const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, '').toLowerCase()); 
                // Adjusted required headers: "wk demand" instead of "category"
                const requiredHeaders = ['product code', 'brand', 'product name']; 
                const missingHeaders = requiredHeaders.filter(rh => !headers.includes(rh));
                if (missingHeaders.length > 0) {
                    showNotification(`CSV missing required headers: ${missingHeaders.join(', ')}.`, 'error');
                    event.target.value = '';
                    return;
                }
                
                // Adjusted headerMap for "wk demand" and "expiry date"
                const headerMap = {
                    'product code': 'sku', 'brand': 'brand', 'product name': 'product',
                    'wk demand': 'wkDemand', 'expiry date': 'expiryDate', 'price': 'price'
                };

                const importData = [];
                const importedSkusThisBatch = new Set(); 

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                    if (values.length !== headers.length) {
                        console.warn(`Skipping CSV row ${i + 1} due to column mismatch.`);
                        continue;
                    }
                    let item = { isDeleted: false }; 
                    let validRow = true;
                    let currentSku = '';

                    headers.forEach((header, index) => {
                        const fieldName = headerMap[header.toLowerCase()];
                        if (fieldName) {
                            let value = values[index];
                            if (fieldName === 'price') item[fieldName] = parseFloat(value) || 0;
                            else if (fieldName === 'wkDemand') item[fieldName] = parseInt(value) || 0;
                            else if (fieldName === 'sku') {
                                currentSku = value.trim();
                                if (!currentSku) validRow = false; 
                                else item[fieldName] = currentSku;
                            }
                            else item[fieldName] = value;
                        }
                    });

                    if (!item.brand || !item.product) validRow = false;

                    if (validRow && currentSku) {
                        if (importedSkusThisBatch.has(currentSku)) {
                            console.warn(`Skipping CSV row ${i+1}: Duplicate SKU '${currentSku}' in CSV.`);
                            validRow = false;
                        } else {
                            importedSkusThisBatch.add(currentSku);
                            importData.push(item);
                        }
                    } else if (!validRow) {
                         console.warn(`Skipping invalid CSV row ${i+1}.`);
                    }
                }

                if (importData.length === 0) {
                    showNotification('No valid data found to import from CSV.', 'error');
                    event.target.value = '';
                    return;
                }

                showConfirmModal(`Found ${importData.length} valid items. Importing will add new items or update existing ones in Master List based on SKU. Continue?`, async (confirmed) => {
                    if (confirmed) {
                        const batch = db.batch();
                        let newItemsCount = 0;
                        let updatedItemsCount = 0;

                        for (const item of importData) {
                            try {
                                const existingProduct = masterProductsData.find(mp => mp.sku === item.sku && !mp.isDeleted);
                                if (existingProduct) { 
                                    const docRef = masterProductsColRef.doc(existingProduct.id);
                                    batch.set(docRef, item, { merge: true }); 
                                    updatedItemsCount++;
                                } else { 
                                    const docRef = masterProductsColRef.doc(); 
                                    const newPayload = { ...item, wkDemand: item.wkDemand || 0, isDeleted: false };
                                    batch.set(docRef, newPayload);
                                    newItemsCount++;
                                }
                            } catch (err) {
                                console.error("Error adding item to batch for import:", item, err);
                            }
                        }

                        if (newItemsCount > 0 || updatedItemsCount > 0) {
                            try {
                                await batch.commit();
                                showNotification(`Successfully imported: ${newItemsCount} new, ${updatedItemsCount} updated.`, 'success');
                                await updateLocalData();
                            } catch (err) {
                                console.error("Batch commit failed for import:", err);
                                showNotification('Error during CSV import batch commit.', 'error');
                            }
                        } else {
                            showNotification('No items were imported.', 'info');
                        }
                    }
                    event.target.value = ''; 
                });
            };
            reader.onerror = () => {
                showNotification('Error reading CSV file.', 'error');
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        window.onload = async function() {
            if (typeof JSZip === 'undefined') {
                console.log("JSZip not found, attempting to load...");
                const script = document.createElement('script');
                script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js";
                script.onload = async () => {
                    console.log("JSZip loaded successfully.");
                    await initializeApp();
                };
                script.onerror = () => {
                    console.error("Failed to load JSZip. Export all data may not work.");
                    initializeApp(); 
                };
                document.head.appendChild(script);
            } else {
                await initializeApp();
            }
        };

        async function initializeApp() {
            await updateLocalData();
            const dashboardTabButton = document.querySelector('.tab[onclick*="dashboard"]');
            const dashboardContent = document.getElementById('dashboard');

            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            if (dashboardTabButton && dashboardContent) {
                dashboardTabButton.classList.add('active');
                dashboardContent.classList.add('active');
            } else { 
                const firstTab = document.querySelector('.tab');
                const firstContent = document.querySelector('.tab-content');
                if(firstTab) firstTab.classList.add('active');
                if(firstContent) firstContent.classList.add('active');
            }
            Object.keys(sortState).forEach(tableKey => updateSortIndicators(tableKey));
        }

// --- Browser Notification Setup ---
if ('serviceWorker' in navigator && 'Notification' in window) {
  navigator.serviceWorker.register('sw.js')
    .then(() => {
      if (Notification.permission !== 'granted') {
        Notification.requestPermission().then(permission => {
          if (permission === 'granted') {
            console.log('Notification permission granted.');
          }
        });
      }
    })
    .catch(error => {
      console.error('Service Worker registration failed:', error);
    });
}

// Utility for showing notifications via service worker
function showBrowserNotification(title, message) {
  if (Notification.permission === 'granted') {
    navigator.serviceWorker.getRegistration().then(function(reg) {
      if (reg) {
        reg.showNotification(title, {
          body: message,
          icon: '/icon.png' // Optional: place a PNG icon in your project root or change this path
        });
      }
    });
  }
}
    </script>
    </body>
</html>
