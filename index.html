<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory Management System</title>
    <style>
        /* General Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Body Styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border-radius: 15px;
        }

        /* Headings */
        h1 {
            color: #2c3e50;
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        /* Tabs Navigation */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 2px solid #ecf0f1;
            overflow-x: auto;
            gap: 2px;
        }

        .tab {
            padding: 15px 20px;
            cursor: pointer;
            background-color: transparent;
            border-radius: 10px 10px 0 0;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 11px;
            transition: all 0.3s ease;
            white-space: nowrap;
            color: #7f8c8d;
            min-width: 120px;
            text-align: center;
            border: 2px solid transparent;
            border-bottom: none;
        }

        .tab:hover {
            background-color: #f8f9fa;
            color: #2c3e50;
            border-color: #e1e8ed;
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateY(-2px);
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Stats Cards for Dashboard */
        .stats-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
            transition: transform 0.3s ease;
            cursor: pointer;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card.urgent {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .stat-card.warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .stat-card.info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        .stat-number {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 10px;
            line-height: 1;
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Controls (Buttons, Search, Filters) */
        .controls {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 15px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e1e8ed;
        }

        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-group label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9em;
        }

        .filter-group select {
            padding: 8px 12px;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            font-size: 0.9em;
        }


        /* Table Styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }

        th, td {
            padding: 15px 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 12px;
            cursor: pointer; /* Make headers clickable for sorting */
        }

        th.sort-asc::after {
            content: ' ▲';
            font-size: 0.8em;
            margin-left: 5px;
        }

        th.sort-desc::after {
            content: ' ▼';
            font-size: 0.8em;
            margin-left: 5px;
        }

        tr:hover {
            background-color: #f8f9fa;
        }

        /* Status Badges */
        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-block;
        }

        .oos {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .low {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .normal {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }

        .danger-status {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .alert-status {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        /* Buttons */
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 11px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        /* Search Box */
        .search-box {
            padding: 12px 16px;
            width: 280px;
            border: 2px solid #e1e8ed;
            border-radius: 25px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .search-box:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Modal Styling */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: none;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close:hover {
            color: #e74c3c;
        }

        /* Form Group */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        /* Alert Notifications */
        .alert {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 600;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* Confirmation Modal Specific Styles */
        #confirmModal .modal-content {
            text-align: center;
            padding: 40px;
            max-width: 450px;
        }

        #confirmModal .modal-content h2 {
            margin-bottom: 20px;
            color: #333;
        }

        #confirmModal .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
        }

        #confirmModal .modal-buttons button {
            flex: 1;
            max-width: 150px;
            padding: 12px 25px;
            font-size: 14px;
        }

        /* --- Mobile Responsiveness --- */
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
                border-radius: 10px;
            }

            h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 1rem;
                margin-bottom: 20px;
            }

            .tabs {
                flex-wrap: wrap; /* Allow tabs to wrap to next line */
                justify-content: center; /* Center tabs when wrapped */
                border-bottom: none; /* Remove border when wrapped */
            }

            .tab {
                min-width: unset; /* Remove fixed min-width */
                flex: 1 1 auto; /* Allow tabs to grow/shrink */
                padding: 10px 15px;
                font-size: 10px;
                border-bottom: 2px solid #ecf0f1; /* Add border to each tab */
            }

            .tab.active {
                transform: none; /* Remove transform on active tab */
                box-shadow: none; /* Remove shadow on active tab */
                border-bottom: 2px solid #667eea;
            }

            .stats-cards {
                grid-template-columns: 1fr; /* Stack cards vertically */
            }

            .stat-card {
                padding: 20px;
            }

            .stat-number {
                font-size: 2.5rem;
            }

            .controls {
                flex-direction: column; /* Stack buttons and search vertically */
                align-items: stretch; /* Stretch items to full width */
                padding: 15px;
            }

            button {
                width: 100%;
                margin-bottom: 10px; /* Add space between stacked buttons */
                font-size: 12px;
                padding: 10px 15px;
            }

            .search-box {
                width: 100%; /* Make search box full width */
            }

            /* Responsive Tables: force table to scroll horizontally */
            table {
                display: block; /* Make table a block element */
                width: 100%;
                overflow-x: auto; /* Enable horizontal scrolling */
                -webkit-overflow-scrolling: touch; /* Smooth scrolling for iOS */
                white-space: nowrap; /* Prevent content from wrapping */
            }

            th, td {
                min-width: 120px; /* Ensure columns have a minimum width */
                padding: 10px;
            }

            .modal-content {
                margin: 20px auto; /* Adjust margin for smaller screens */
                padding: 20px;
                width: 95%; /* Make modal content a bit wider */
            }

            .alert {
                width: calc(100% - 40px); /* Full width minus padding */
                left: 20px;
                right: 20px;
                top: 10px; /* Move notification higher */
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Inventory Management System</h1>
        <p class="subtitle">Professional Inventory Tracking & Management Solution</p>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab(this, 'dashboard')">📊 Dashboard</div>
            <div class="tab" onclick="switchTab(this, 'oos-lowstock')">📦 OOS/LOW STOCK</div>
            <div class="tab" onclick="switchTab(this, 'new-products')">✨ New Products</div>
            <div class="tab" onclick="switchTab(this, 'to-clear')">🏷️ To Clear</div>
            <div class="tab" onclick="switchTab(this, 'master-list')">📋 Master List</div>
            <div class="tab" onclick="switchTab(this, 'recycle-bin')">🗑️ Recycle Bin</div>
            <div class="tab" onclick="switchTab(this, 'management')">⚙️ Management</div>
        </div>
        
        <div id="dashboard" class="tab-content active">
            <div class="stats-cards">
                <div class="stat-card urgent" onclick="showFilteredInventory('OOS')">
                    <div class="stat-number" id="oos-count">0</div>
                    <div class="stat-label">Out of Stock</div>
                </div>
                <div class="stat-card warning" onclick="showFilteredInventory('Low stock')">
                    <div class="stat-number" id="low-count">0</div>
                    <div class="stat-label">Low Stock</div>
                </div>
                <div class="stat-card info" onclick="switchTab(document.querySelector('.tab[onclick*=\'new-products\']'), 'new-products')">
                    <div class="stat-number" id="new-count">0</div>
                    <div class="stat-label">New Products</div>
                </div>
            </div>
            
            <h3>Recent Alerts</h3>
            <div id="alerts" style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-top: 20px;">
                <p>Loading alerts...</p>
            </div>
        </div>
        
        <div id="oos-lowstock" class="tab-content">
            <div class="controls">
                <button onclick="showAddProductModal()">➕ Add Product</button>
                <input type="text" id="oosLowStockSearchInput" class="search-box" placeholder="🔍 Search products...">
                <div class="filter-group">
                    <label for="oosLowStockBrandFilter">Brand:</label>
                    <select id="oosLowStockBrandFilter" onchange="applyInventoryFilters()"></select>
                    <label for="oosLowStockStatusFilter">Status:</label>
                    <select id="oosLowStockStatusFilter" onchange="applyInventoryFilters()"></select>
                </div>
            </div>
            
            <table>
                <thead>
                    <tr>
                        <th data-column="sku">Product Code</th>
                        <th data-column="brand">Brand</th>
                        <th data-column="product">Product</th>
                        <th data-column="quantity">Quantity</th> 
                        <th data-column="status">Status</th>
                        <th data-column="expiry">Expiry</th>
                        <th data-column="shipment">Shipment</th>
                        <th data-column="remarks">Remarks</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="inventory-table">
                    </tbody>
            </table>
        </div>
        
        <div id="new-products" class="tab-content">
            <div class="controls">
                <button onclick="showAddNewProductModal()">➕ Add New Product</button>
                <button onclick="mergeNewProductsToMaster()">Merge All to Inventory</button>
                <input type="text" id="newProductsSearchInput" class="search-box" placeholder="🔍 Search new products...">
            </div>
            
            <table>
                <thead>
                    <tr>
                        <th data-column="sku">Product Code</th>
                        <th data-column="brand">Brand</th>
                        <th data-column="product">Product</th>
                        <th data-column="addedDate">Added Date</th>
                        <th data-column="arrivalDate">Arrival Date</th>
                        <th data-column="quantity">Quantity</th>
                        <th data-column="notes">Notes</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="new-products-table">
                    </tbody>
            </table>
        </div>
        
        <div id="to-clear" class="tab-content">
            <div class="controls">
                <button onclick="showAddToClearModal()">➕ Add Product to Clear</button>
                <input type="text" id="toClearSearchInput" class="search-box" placeholder="🔍 Search products to clear...">
                <div class="filter-group">
                    <label for="toClearBrandFilter">Brand:</label>
                    <select id="toClearBrandFilter" onchange="applyToClearFilters()"></select>
                    <label for="toClearCategoryFilter">Category:</label>
                    <select id="toClearCategoryFilter" onchange="applyToClearFilters()"></select>
                </div>
            </div>
            
            <table>
                <thead>
                    <tr>
                        <th data-column="sku">Product Code</th>
                        <th data-column="brand">Brand</th>
                        <th data-column="product">Product</th>
                        <th data-column="category">Category</th>
                        <th data-column="expiryDate">Expiry Date</th>
                        <th data-column="firstHighlightedDate">First Highlighted Date</th>
                        <th data-column="firstReportedBalance">First Reported Balance</th>
                        <th data-column="warehouseQty">Warehouse Qty</th>
                        <th data-column="storeQty">Store Qty</th>
                        <th data-column="totalQty">Total Qty</th>
                        <th data-column="weeklyDemand">Weekly Demand</th>
                        <th data-column="weeksSupply">Weeks Supply</th>
                        <th data-column="supplyStatus">Supply Status</th>
                        <th data-column="actionPlan">Action Plan</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="to-clear-table">
                    </tbody>
            </table>
        </div>
        
        <div id="master-list" class="tab-content">
            <div class="controls">
                <button onclick="showAddMasterProductModal()">➕ Add Product</button>
                <button onclick="exportMasterList()">📥 Export List</button>
                <button onclick="document.getElementById('csvFileInput').click()">📤 Import CSV</button>
                <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="importCSV(event)">
                <input type="text" id="masterListSearchInput" class="search-box" placeholder="🔍 Search master list...">
                <div class="filter-group">
                    <label for="masterListBrandFilter">Brand:</label>
                    <select id="masterListBrandFilter" onchange="applyMasterListFilters()"></select>
                    <label for="masterListCategoryFilter">Category:</label>
                    <select id="masterListCategoryFilter" onchange="applyMasterListFilters()"></select>
                </div>
            </div>
            
            <table>
                <thead>
                    <tr>
                        <th data-column="sku">Product Code</th>
                        <th data-column="brand">Brand</th>
                        <th data-column="product">Product Name</th>
                        <th data-column="category">Category</th>
                        <th data-column="description">Description</th>
                        <th data-column="price">Price</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="master-table">
                    </tbody>
            </table>
        </div>

        <div id="recycle-bin" class="tab-content">
            <div class="controls">
                <h3>Recycle Bin</h3>
                <button class="btn-danger" onclick="emptyRecycleBin()">🗑️ Empty Recycle Bin</button>
            </div>
            <table>
                <thead>
                    <tr>
                        <th data-column="sku">Product Code</th>
                        <th data-column="originalCollection">Original Tab</th>
                        <th data-column="brand">Brand</th>
                        <th data-column="product">Product</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="recycle-bin-table">
                    </tbody>
            </table>
        </div>
        
        <div id="management" class="tab-content">
            <div class="controls">
                <button onclick="exportAllData()">📥 Export All Data</button>
                <button onclick="confirmLoadSampleData()">📊 Load Sample Data</button>
            </div>
            
            <h3>System Information</h3>
            <p>Total Products (active): <span id="total-products">0</span></p>
            <p>Total Products (including deleted): <span id="total-products-all">0</span></p>
            <p>Last Synced: <span id="last-updated">Never</span></p>
        </div>
    </div>

    <div id="productModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('productModal')">&times;</span>
            <h2 id="productModalTitle">Add New Product</h2>
            <form onsubmit="saveProduct(event)">
                <input type="hidden" id="editProductId" value="">
                <div class="form-group">
                    <label>Brand:</label>
                    <select id="brand" required onchange="filterProductsForBrand(this.value, 'productName', 'productsDatalist')">
                        </select>
                </div>
                <div class="form-group">
                    <label>Product Name:</label>
                    <input type="text" id="productName" list="productsDatalist" required placeholder="Select or type product name">
                    <datalist id="productsDatalist"></datalist>
                </div>
                <div class="form-group">
                    <label>Quantity:</label>
                    <input type="number" id="inventoryQuantity" min="0" required>
                </div>
                <div class="form-group">
                    <label>Status:</label>
                    <select id="status" required>
                        </select>
                </div>
                <div class="form-group">
                    <label>Expiry Date:</label>
                    <input type="date" id="expiry">
                </div>
                <div class="form-group">
                    <label>Shipment No.:</label>
                    <input type="text" id="shipment">
                </div>
                <div class="form-group">
                    <label>Remarks:</label>
                    <textarea id="remarks"></textarea>
                </div>
                <button type="submit">Save Product</button>
            </form>
        </div>
    </div>

    <div id="newProductModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('newProductModal')">&times;</span>
            <h2 id="newProductModalTitle">Add New Product Entry</h2>
            <form onsubmit="saveNewProduct(event)">
                <input type="hidden" id="editNewProductId" value="">
                <div class="form-group">
                    <label>Brand:</label>
                    <select id="newBrand" required onchange="filterProductsForBrand(this.value, 'newProductName', 'newProductsDatalist')">
                        </select>
                </div>
                <div class="form-group">
                    <label>Product Name:</label>
                    <input type="text" id="newProductName" list="newProductsDatalist" required placeholder="Select or type product name">
                    <datalist id="newProductsDatalist"></datalist>
                </div>
                <div class="form-group">
                    <label>Arrival Date:</label>
                    <input type="date" id="arrivalDate" required>
                </div>
                <div class="form-group">
                    <label>Quantity:</label>
                    <input type="number" id="quantity" min="0" required>
                </div>
                <div class="form-group">
                    <label>Notes:</label>
                    <textarea id="notes"></textarea>
                </div>
                <button type="submit">Save New Product</button>
            </form>
        </div>
    </div>

    <div id="masterProductModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('masterProductModal')">&times;</span>
            <h2 id="masterProductModalTitle">Add Master Product</h2>
            <form onsubmit="saveMasterProduct(event)">
                <input type="hidden" id="editMasterProductId" value="">
                <div class="form-group">
                    <label>Brand:</label>
                    <select id="masterBrand" required>
                        </select>
                </div>
                <div class="form-group">
                    <label>Product Name:</label>
                    <input type="text" id="masterProductName" required>
                </div>
                <div class="form-group">
                    <label>Category:</label>
                    <select id="category" required>
                        </select>
                </div>
                <div class="form-group">
                    <label>Description:</label>
                    <textarea id="description"></textarea>
                </div>
                <div class="form-group">
                    <label>Product Code (SKU):</label>
                    <input type="text" id="sku">
                </div>
                <div class="form-group">
                    <label>Price:</label>
                    <input type="number" id="price" step="0.01" min="0">
                </div>
                <button type="submit">Save Master Product</button>
            </form>
        </div>
    </div>

    <div id="toClearModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('toClearModal')">&times;</span>
            <h2 id="toClearModalTitle">Add Product to Clear</h2>
            <form onsubmit="saveToClear(event)">
                <input type="hidden" id="editToClearId" value="">
                <div class="form-group">
                    <label>Brand:</label>
                    <select id="toClearBrand" required onchange="filterProductsForBrand(this.value, 'toClearProductName', 'toClearProductsDatalist')">
                        </select>
                </div>
                <div class="form-group">
                    <label>Product Name:</label>
                    <input type="text" id="toClearProductName" list="toClearProductsDatalist" required placeholder="Select or type product name">
                    <datalist id="toClearProductsDatalist"></datalist>
                </div>
                <div class="form-group">
                    <label>Category:</label>
                    <select id="toClearCategory" required>
                        </select>
                </div>
                <div class="form-group">
                    <label>Expiry Date:</label>
                    <input type="date" id="toClearExpiryDate" required>
                </div>
                <div class="form-group">
                    <label>First Highlighted Date:</label>
                    <input type="date" id="toClearFirstHighlightedDate" required readonly>
                </div>
                <div class="form-group">
                    <label>First Reported Balance (Total Qty):</label>
                    <input type="number" id="toClearFirstReportedBalance" min="0">
                </div>
                <div class="form-group">
                    <label>Warehouse Qty:</label>
                    <input type="number" id="toClearWarehouseQty" min="0">
                </div>
                <div class="form-group">
                    <label>Store Qty:</label>
                    <input type="number" id="toClearStoreQty" min="0">
                </div>
                <div class="form-group">
                    <label>Weekly Demand:</label>
                    <input type="number" id="toClearWeeklyDemand" min="0">
                </div>
                <div class="form-group">
                    <label>Action Plan:</label>
                    <textarea id="toClearActionPlan"></textarea>
                </div>
                <button type="submit">Save Product to Clear</button>
            </form>
        </div>
    </div>

    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <h2>Confirmation</h2>
            <p id="confirmMessage"></p>
            <div class="modal-buttons">
                <button class="btn-danger" id="confirmNo">No</button>
                <button class="btn-success" id="confirmYes">Yes</button>
            </div>
        </div>
    </div>

    <div id="addNewBrandModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addNewBrandModal')">&times;</span>
            <h2>Add New Brand</h2>
            <form onsubmit="handleAddNewBrand(event)">
                <div class="form-group">
                    <label for="newBrandNameInput">Brand Name:</label>
                    <input type="text" id="newBrandNameInput" required data-calling-select="">
                </div>
                <button type="submit">Add Brand</button>
            </form>
        </div>
    </div>

    <div id="addNewStatusModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addNewStatusModal')">&times;</span>
            <h2>Add New Status</h2>
            <form onsubmit="handleAddNewStatus(event)">
                <div class="form-group">
                    <label for="newStatusNameInput">Status Name:</label>
                    <input type="text" id="newStatusNameInput" required data-calling-select="">
                </div>
                <button type="submit">Add Status</button>
            </form>
        </div>
    </div>

    <div id="addNewCategoryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addNewCategoryModal')">&times;</span>
            <h2>Add New Category</h2>
            <form onsubmit="handleAddNewCategory(event)">
                <div class="form-group">
                    <label for="newCategoryNameInput">Category Name:</label>
                    <input type="text" id="newCategoryNameInput" required data-calling-select="">
                </div>
                <button type="submit">Add Category</button>
            </form>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    <script>
        // Your web app's Firebase configuration
        // IMPORTANT: Ensure these values are correct for your Firebase project.
        // You can find them in your Firebase project settings under "Project settings" -> "Your apps" -> "Firebase SDK snippet" -> "Config".
        const firebaseConfig = {
            apiKey: "AIzaSyDo1-y0Vj4XTQeeEUQK_6Y2wqDs94TOAX0",
            authDomain: "inventory-c3bac.firebaseapp.com",
            projectId: "inventory-c3bac",
            storageBucket: "inventory-c3bac.firebasestorage.app",
            messagingSenderId: "261015083855",
            appId: "1:261015083855:web:e167f359928eb8ed8cc33a"
            // measurementId: "G-V744486L78" // Typically for Google Analytics, not essential for Firestore connection
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // Global data arrays to hold fetched data
        let inventoryData = [];
        let newProductsData = [];
        let toClearData = [];
        let masterProductsData = [];
        let deletedItemsData = [];
        let brandsData = []; 
        let statusesData = []; 
        let categoriesData = []; 

        // Firestore collection references
        const inventoryColRef = db.collection('inventory');
        const newProductsColRef = db.collection('new_products');
        const toClearColRef = db.collection('to_clear');
        const masterProductsColRef = db.collection('master_products');
        const deletedItemsColRef = db.collection('deleted_items');
        const brandsColRef = db.collection('brands'); 
        const statusesColRef = db.collection('statuses'); 
        const categoriesColRef = db.collection('categories'); 

        // Variable to hold the callback for the confirmation modal
        let confirmCallback = null;

        // --- Utility Functions ---

        // Helper function to show notifications
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `alert alert-${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Fetch data from Firestore
        async function fetchDataFromFirestore(collectionRef, includeDeleted = false) {
            let data = [];
            let queryRef = collectionRef;
            if (!includeDeleted) {
                queryRef = collectionRef.where("isDeleted", "==", false);
            }
            const querySnapshot = await queryRef.get();
            querySnapshot.forEach((doc) => {
                data.push({ id: doc.id, ...doc.data() });
            });
            return data;
        }

        // Save data to Firestore (add or update)
        async function saveDataToFirestore(collectionRef, docId, data) {
            try {
                if (docId) {
                    await collectionRef.doc(docId).update(data);
                } else {
                    const docRef = await collectionRef.add(data);
                    return docRef.id; // Return the new document ID
                }
                return docId; // Return original docId for updates
            } catch (error) {
                console.error(`Error saving data to ${collectionRef.id}:`, error);
                showNotification(`Error saving data to server for ${collectionRef.id}.`, 'error');
                throw error; // Propagate error for calling functions to handle
            }
        }

        // Update all local data arrays from Firestore and then refresh tables
        async function updateLocalData() {
            try {
                inventoryData = await fetchDataFromFirestore(inventoryColRef);
                newProductsData = await fetchDataFromFirestore(newProductsColRef);
                toClearData = await fetchDataFromFirestore(toClearColRef);
                masterProductsData = await fetchDataFromFirestore(masterProductsColRef);
                
                // Fetch dynamic dropdown data
                brandsData = await fetchDataFromFirestore(brandsColRef);
                statusesData = await fetchDataFromFirestore(statusesColRef);
                categoriesData = await fetchDataFromFirestore(categoriesColRef);

                // Sync Brands from Master Products to Brands Collection
                const uniqueBrandsFromMaster = [...new Set(masterProductsData.map(item => item.brand).filter(Boolean))];
                const existingBrandNames = new Set(brandsData.map(b => b.name));
                const brandsToAdd = uniqueBrandsFromMaster.filter(brandName => !existingBrandNames.has(brandName));

                if (brandsToAdd.length > 0) {
                    const brandBatch = db.batch();
                    brandsToAdd.forEach(brandName => {
                        brandBatch.set(brandsColRef.doc(), { name: brandName });
                    });
                    await brandBatch.commit();
                    brandsData = await fetchDataFromFirestore(brandsColRef); // Re-fetch after adding
                }

                // Fetch all items (including deleted) for recycle bin
                const allInventoryItems = await fetchDataFromFirestore(inventoryColRef, true);
                const allNewProductsItems = await fetchDataFromFirestore(newProductsColRef, true);
                const allToClearItems = await fetchDataFromFirestore(toClearColRef, true);
                const allMasterProductsItems = await fetchDataFromFirestore(masterProductsColRef, true);

                deletedItemsData = [];
                allInventoryItems.filter(item => item.isDeleted).forEach(item => deletedItemsData.push({ ...item, originalCollection: inventoryColRef.id }));
                allNewProductsItems.filter(item => item.isDeleted).forEach(item => deletedItemsData.push({ ...item, originalCollection: newProductsColRef.id }));
                allToClearItems.filter(item => item.isDeleted).forEach(item => deletedItemsData.push({ ...item, originalCollection: toClearColRef.id }));
                allMasterProductsItems.filter(item => item.isDeleted).forEach(item => deletedItemsData.push({ ...item, originalCollection: masterProductsColRef.id }));

                updateAllTables();
                updateDashboardStats();
                updateAlerts();
                updateManagementStats();
                populateAllDropdowns(); // Call a new comprehensive function
                attachSortListeners(); // Attach sort listeners after tables are updated
            } catch (e) {
                console.error("Error updating local data from Firestore: ", e);
                showNotification("Error loading data from server.", "error");
            }
        }

        // --- Confirmation Modal Logic ---
        function showConfirmModal(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').style.display = 'block';
            confirmCallback = callback;
        }

        document.getElementById('confirmYes').onclick = function() {
            if (confirmCallback) {
                confirmCallback(true);
            }
            closeModal('confirmModal');
        };

        document.getElementById('confirmNo').onclick = function() {
            if (confirmCallback) {
                confirmCallback(false);
            }
            closeModal('confirmModal');
        };

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // --- Data Management Functions (Firestore Integrated) ---

        // Initial sample data (to be added only if collections are empty)
        const sampleData = {
            inventory: [
                { brand: "Greenlife", product: "GL CALCIUM GUMMIES", sku: "GL-CG-001", quantity: 0, status: "OOS", expiry: "", shipment: "", remarks: "", isDeleted: false },
                { brand: "Greenlife", product: "GL VIT C + ZINC", sku: "GL-VCZ-002", quantity: 0, status: "OOS", expiry: "", shipment: "", remarks: "", isDeleted: false },
                { brand: "NN", product: "NORDIC KIDS VIT C GUM 60'S", sku: "NN-KVC-001", quantity: 5, status: "Low stock", expiry: "", shipment: "", remarks: "", isDeleted: false },
                { brand: "ENZYMEDICA", product: "DIGEST + PROBIOTICS 30'S", sku: "EZ-DPR-001", quantity: 8, status: "Low stock", expiry: "", shipment: "", remarks: "", isDeleted: false },
                { brand: "NaturesPlus", product: "SOURCE OF LIFE GOLD", sku: "NP-SLG-001", quantity: 25, status: "In Stock", expiry: "2026-10-01", shipment: "", remarks: "Regular stock", isDeleted: false },
                { brand: "Greenlife", product: "GL MAGNESIUM POWDER", sku: "GL-MP-005", quantity: 12, status: "In Stock", expiry: "2025-12-31", shipment: "SH001", remarks: "New batch arrived", isDeleted: false }
            ],
            new_products: [
                { brand: "NewBrandX", product: "New Product Alpha", sku: "NBX-PA-001", addedDate: "2025-05-20", arrivalDate: "2025-05-25", quantity: 50, notes: "Trial product", isDeleted: false }
            ],
            to_clear: [
                { brand: "NN", product: "NORDIC OMEGA KIDS", sku: "NN-OK-002", category: "Short Expiry", expiryDate: "2025-07-15", firstHighlightedDate: "2025-05-01", firstReportedBalance: 20, warehouseQty: 10, storeQty: 5, weeklyDemand: 2, actionPlan: "Promote heavily", isDeleted: false }
            ],
            master_products: [
                { brand: "Greenlife", product: "GL CALCIUM GUMMIES", category: "Vitamins", description: "Chewable calcium supplement", sku: "GL-CG-001", price: 15.00, isDeleted: false },
                { brand: "Greenlife", product: "GL VIT C + ZINC", category: "Vitamins", description: "Immune support formula", sku: "GL-VCZ-002", price: 12.50, isDeleted: false },
                { brand: "NN", product: "NORDIC KIDS VIT C GUM 60'S", category: "Vitamins", description: "Kids chewable Vitamin C", sku: "NN-KVC-001", price: 18.00, isDeleted: false },
                { brand: "NN", product: "NORDIC OMEGA KIDS", category: "Omega", description: "Kids Omega-3 DHA Gummy", sku: "NN-OK-002", price: 25.00, isDeleted: false },
                { brand: "NaturesPlus", product: "SOURCE OF LIFE GOLD", category: "Multivitamins", description: "Whole food based multivitamin", sku: "NP-SLG-001", price: 50.00, isDeleted: false },
                { brand: "ENZYMEDICA", product: "DIGEST + PROBIOTICS 30'S", category: "Digestive Health", description: "Enzymes and probiotics combo", sku: "EZ-DPR-001", price: 35.00, isDeleted: false },
                { brand: "ENZYMEDICA", product: "DIGEST GOLD", category: "Digestive Health", description: "Advanced digestive enzymes", sku: "EZ-DGL-002", price: 40.00, isDeleted: false },
                { brand: "Greenlife", product: "GL SUPER PROBIOTIC", category: "Probiotics", description: "High-potency probiotic formula", sku: "GL-SPR-003", price: 22.00, isDeleted: false },
                { brand: "Greenlife", product: "GL VITAMIN B COMPLEX", category: "Vitamins", description: "Energy support B-complex", sku: "GL-VBC-004", price: 17.50, isDeleted: false },
                { brand: "NN", product: "VITAMIN C GUMMIES", category: "Vitamins", description: "Chewable Vitamin C for adults", sku: "NN-VCG-003", price: 10.00, isDeleted: false }
            ],
            brands: [
                { name: "Greenlife" },
                { name: "NN" },
                { name: "NaturesPlus" },
                { name: "ENZYMEDICA" },
                { name: "NewBrandX" }
            ],
            statuses: [
                { name: "OOS" },
                { name: "Low stock" },
                { name: "In Stock" },
                { name: "Discontinued" }
            ],
            categories: [
                { name: "Vitamins" },
                { name: "Omega" },
                { name: "Multivitamins" },
                { name: "Digestive Health" },
                { name: "Probiotics" }
            ]
        };

        async function loadSampleData() {
            showNotification('Loading sample data... This might take a moment.', 'info');
            try {
                const collectionsToClear = [inventoryColRef, newProductsColRef, toClearColRef, masterProductsColRef, deletedItemsColRef, brandsColRef, statusesColRef, categoriesColRef];
                for (const colRef of collectionsToClear) {
                    const snapshot = await colRef.get();
                    const batch = db.batch();
                    snapshot.docs.forEach(doc => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();
                }

                // Add sample data
                for (const collectionName in sampleData) {
                    const collectionRef = db.collection(collectionName);
                    const batch = db.batch();
                    sampleData[collectionName].forEach(item => {
                        const docRef = collectionRef.doc();
                        batch.set(docRef, item);
                    });
                    await batch.commit();
                }
                showNotification('Sample data loaded successfully!', 'success');
                await updateLocalData(); // Refresh all UI
            } catch (e) {
                console.error("Error loading sample data:", e);
                showNotification('Error loading sample data. Check console for details.', 'error');
            }
        }

        function confirmLoadSampleData() {
            showConfirmModal('WARNING: This will delete ALL existing data and load sample data. Are you sure?', async (confirmed) => {
                if (confirmed) {
                    await loadSampleData();
                }
            });
        }

        // Helper to get SKU from master list
        function getSkuForProduct(brand, product) {
            const masterProduct = masterProductsData.find(item => item.brand === brand && item.product === product);
            return masterProduct ? masterProduct.sku : '';
        }

        // Save Product (OOS/LOW STOCK Tab)
        async function saveProduct(event) {
            event.preventDefault();
            const editId = document.getElementById('editProductId').value;
            const selectedBrand = document.getElementById('brand').value;
            const selectedProduct = document.getElementById('productName').value;
            const productSku = getSkuForProduct(selectedBrand, selectedProduct);

            const productData = {
                brand: selectedBrand,
                product: selectedProduct,
                sku: productSku, 
                quantity: parseInt(document.getElementById('inventoryQuantity').value), 
                status: document.getElementById('status').value,
                expiry: document.getElementById('expiry').value,
                shipment: document.getElementById('shipment').value,
                remarks: document.getElementById('remarks').value,
                isDeleted: false
            };

            try {
                await saveDataToFirestore(inventoryColRef, editId, productData);
                showNotification(editId ? 'Product updated successfully!' : 'Product added successfully!', 'success');
                closeModal('productModal');
                event.target.reset();
                await updateLocalData(); // Refresh data
            } catch (e) {
                // Error handled by saveDataToFirestore notification
            }
        }

        // Save New Product (New Products Tab)
        async function saveNewProduct(event) {
            event.preventDefault();
            const editId = document.getElementById('editNewProductId').value;
            const selectedBrand = document.getElementById('newBrand').value;
            const selectedProduct = document.getElementById('newProductName').value;
            const productSku = getSkuForProduct(selectedBrand, selectedProduct);

            const newProductData = {
                brand: selectedBrand,
                product: selectedProduct,
                sku: productSku, 
                addedDate: new Date().toISOString().slice(0, 10), // Set current date
                arrivalDate: document.getElementById('arrivalDate').value,
                quantity: parseInt(document.getElementById('quantity').value),
                notes: document.getElementById('notes').value,
                isDeleted: false
            };

            try {
                await saveDataToFirestore(newProductsColRef, editId, newProductData);
                showNotification(editId ? 'New product updated successfully!' : 'New product added successfully!', 'success');
                closeModal('newProductModal');
                event.target.reset();
                await updateLocalData();
            } catch (e) {
                // Error handled
            }
        }

        // Save Master Product (Master List Tab)
        async function saveMasterProduct(event) {
            event.preventDefault();
            const editId = document.getElementById('editMasterProductId').value;
            const masterProductData = {
                brand: document.getElementById('masterBrand').value,
                product: document.getElementById('masterProductName').value,
                category: document.getElementById('category').value,
                description: document.getElementById('description').value,
                sku: document.getElementById('sku').value, 
                price: parseFloat(document.getElementById('price').value),
                isDeleted: false
            };

            try {
                await saveDataToFirestore(masterProductsColRef, editId, masterProductData);
                showNotification(editId ? 'Master product updated successfully!' : 'Master product added successfully!', 'success');
                closeModal('masterProductModal');
                event.target.reset();
                await updateLocalData();
            } catch (e) {
                // Error handled
            }
        }

        // Save To Clear Product (To Clear Tab)
        async function saveToClear(event) {
            event.preventDefault();
            const editId = document.getElementById('editToClearId').value;
            const selectedBrand = document.getElementById('toClearBrand').value;
            const selectedProduct = document.getElementById('toClearProductName').value;
            const productSku = getSkuForProduct(selectedBrand, selectedProduct);

            const warehouseQty = parseInt(document.getElementById('toClearWarehouseQty').value);
            const storeQty = parseInt(document.getElementById('toClearStoreQty').value);
            const totalQtyAtCreation = warehouseQty + storeQty; 

            const toClearProductData = {
                brand: selectedBrand,
                product: selectedProduct,
                sku: productSku, 
                category: document.getElementById('toClearCategory').value,
                expiryDate: document.getElementById('toClearExpiryDate').value,
                warehouseQty: warehouseQty,
                storeQty: storeQty,
                weeklyDemand: parseFloat(document.getElementById('toClearWeeklyDemand').value),
                actionPlan: document.getElementById('toClearActionPlan').value,
                isDeleted: false
            };

            // Only set these fields on NEW creation
            if (!editId) {
                toClearProductData.firstHighlightedDate = new Date().toISOString().slice(0, 10);
                toClearProductData.firstReportedBalance = totalQtyAtCreation;
            } else {
                const existingItem = toClearData.find(item => item.id === editId);
                if (existingItem) {
                    toClearProductData.firstHighlightedDate = existingItem.firstHighlightedDate;
                    toClearProductData.firstReportedBalance = existingItem.firstReportedBalance;
                }
            }

            try {
                await saveDataToFirestore(toClearColRef, editId, toClearProductData);
                showNotification(editId ? 'Product to clear updated successfully!' : 'Product to clear added successfully!', 'success');
                closeModal('toClearModal');
                event.target.reset();
                await updateLocalData();
            } catch (e) {
                // Error handled
            }
        }

        // Delete functions (Soft Delete)
        async function softDeleteProduct(id) {
            showConfirmModal("Are you sure you want to move this product to the Recycle Bin?", async (confirmed) => {
                if (confirmed) {
                    try {
                        await saveDataToFirestore(inventoryColRef, id, { isDeleted: true, deletedDate: new Date().toISOString().slice(0, 10), originalCollection: inventoryColRef.id });
                        showNotification('Product moved to Recycle Bin!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error("Error deleting item: ", e);
                        showNotification('Error moving product to Recycle Bin.', 'error');
                    }
                }
            });
        }

        async function softDeleteNewProduct(id) {
            showConfirmModal("Are you sure you want to move this new product entry to the Recycle Bin?", async (confirmed) => {
                if (confirmed) {
                    try {
                        await saveDataToFirestore(newProductsColRef, id, { isDeleted: true, deletedDate: new Date().toISOString().slice(0, 10), originalCollection: newProductsColRef.id });
                        showNotification('New product moved to Recycle Bin!', 'success');
                        await updateLocalData();
                    }
                    catch (e) {
                        console.error("Error deleting item: ", e);
                        showNotification('Error moving product to Recycle Bin.', 'error');
                    }
                }
            });
        }

        async function softDeleteMasterProduct(id) {
            showConfirmModal("Are you sure you want to move this master product to the Recycle Bin? This will affect product dropdowns!", async (confirmed) => {
                if (confirmed) {
                    try {
                        await saveDataToFirestore(masterProductsColRef, id, { isDeleted: true, deletedDate: new Date().toISOString().slice(0, 10), originalCollection: masterProductsColRef.id });
                        showNotification('Master product moved to Recycle Bin!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error("Error deleting item: ", e);
                        showNotification('Error moving product to Recycle Bin.', 'error');
                    }
                }
            });
        }

        async function softDeleteToClear(id) {
            showConfirmModal("Are you sure you want to move this 'To Clear' product to the Recycle Bin?", async (confirmed) => {
                if (confirmed) {
                    try {
                        await saveDataToFirestore(toClearColRef, id, { isDeleted: true, deletedDate: new Date().toISOString().slice(0, 10), originalCollection: toClearColRef.id });
                        showNotification('"To Clear" product moved to Recycle Bin!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error("Error moving item: ", e);
                        showNotification('Error moving product to Recycle Bin.', 'error');
                    }
                }
            });
        }
        
        // Restore item from Recycle Bin
        async function restoreItem(id, originalCollectionName) {
            showConfirmModal("Are you sure you want to restore this item? It will return to its original tab.", async (confirmed) => {
                if (confirmed) {
                    try {
                        const collectionRef = db.collection(originalCollectionName);
                        await saveDataToFirestore(collectionRef, id, { isDeleted: false, deletedDate: null, originalCollection: null });
                        showNotification('Item restored successfully!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error("Error restoring item: ", e);
                        showNotification('Error restoring item.', 'error');
                    }
                }
            });
        }

        // Permanently delete item from Recycle Bin
        async function hardDeleteItem(id, originalCollectionName) {
            showConfirmModal("Are you sure you want to permanently delete this item? This action cannot be undone.", async (confirmed) => {
                if (confirmed) {
                    try {
                        await db.collection(originalCollectionName).doc(id).delete();
                        showNotification('Item permanently deleted!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error("Error permanently deleting document: ", e);
                        showNotification('Error permanently deleting item.', 'error');
                    }
                }
            });
        }

        // Empty Recycle Bin (permanently delete all deleted items)
        async function emptyRecycleBin() {
            showConfirmModal('WARNING: Are you sure you want to PERMANENTLY delete ALL items in the Recycle Bin? This action cannot be undone.', async (confirmed) => {
                if (confirmed) {
                    try {
                        const batch = db.batch();
                        deletedItemsData.forEach(item => {
                            const docRef = db.collection(item.originalCollection).doc(item.id);
                            batch.delete(docRef);
                        });
                        await batch.commit();
                        showNotification('Recycle Bin emptied successfully!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error("Error emptying Recycle Bin:", e);
                        showNotification('Error emptying Recycle Bin.', 'error');
                    }
                }
            });
        }

        // --- Display Functions ---

        function updateAllTables() {
            applyInventoryFilters(); // Applies search and filters for OOS/Low Stock
            updateNewProductsTable();
            applyMasterListFilters(); // Applies search and filters for Master List
            applyToClearFilters(); // Applies search and filters for To Clear
            updateRecycleBinTable();
        }

        // Generic table rendering function for sorting and filtering
        function renderTable(tableBodyId, dataToDisplay, columnsConfig) {
            const tbody = document.getElementById(tableBodyId);
            tbody.innerHTML = '';

            if (dataToDisplay.length === 0) {
                const row = tbody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = columnsConfig.length + 1; // +1 for Actions column
                cell.textContent = "No products found for this view.";
                cell.style.textAlign = "center";
                cell.style.padding = "20px";
                return;
            }

            dataToDisplay.forEach(item => {
                const row = tbody.insertRow();
                columnsConfig.forEach(col => {
                    const cell = row.insertCell();
                    let value = item[col.field];

                    if (col.field === 'status') {
                        let statusClass = '';
                        if (value === 'OOS') statusClass = 'oos';
                        else if (value && value.includes('Low')) statusClass = 'low';
                        else if (value === 'In Stock') statusClass = 'normal';
                        cell.innerHTML = `<span class="status-badge ${statusClass}">${value || ''}</span>`;
                    } else if (col.field === 'category') {
                        let categoryClass = '';
                        if (value === 'Short Expiry') categoryClass = 'oos';
                        else if (value === 'Excess Stock') categoryClass = 'low';
                        else categoryClass = 'normal';
                        cell.innerHTML = `<span class="status-badge ${categoryClass}">${value || ''}</span>`;
                    } else if (col.field === 'price') {
                        cell.textContent = value !== undefined ? `$${value.toFixed(2)}` : 'N/A';
                    } else if (col.field === 'expiry' && (item.status === 'OOS' || (item.status && item.status.includes('Low stock')))) {
                        cell.textContent = 'N/A'; // OOS/Low stock no need expiry date
                        cell.style.fontStyle = 'italic';
                        cell.style.color = '#888';
                    } else if (col.field === 'totalQty') {
                        cell.textContent = (item.warehouseQty || 0) + (item.storeQty || 0);
                    } else if (col.field === 'weeksSupply') {
                        const totalQty = (item.warehouseQty || 0) + (item.storeQty || 0);
                        const weeklyDemand = item.weeklyDemand || 0;
                        cell.textContent = weeklyDemand > 0 ? (totalQty / weeklyDemand).toFixed(1) : 'N/A';
                    } else if (col.field === 'supplyStatus') {
                        const totalQty = (item.warehouseQty || 0) + (item.storeQty || 0);
                        const weeklyDemand = item.weeklyDemand || 0;
                        const noOfWeekSupply = weeklyDemand > 0 ? (totalQty / weeklyDemand) : null;
                        let supplyStatusClass = '';
                        let supplyStatusText = 'N/A';
                        if (noOfWeekSupply !== null) {
                            if (noOfWeekSupply < 4) {
                                supplyStatusClass = 'danger-status';
                                supplyStatusText = 'Low Supply';
                            } else if (noOfWeekSupply >= 4 && noOfWeekSupply <= 12) {
                                supplyStatusClass = 'normal';
                                supplyStatusText = 'Good Supply';
                            } else {
                                supplyStatusClass = 'alert-status';
                                supplyStatusText = 'Excess Supply';
                            }
                        }
                        cell.innerHTML = `<span class="status-badge ${supplyStatusClass}">${supplyStatusText}</span>`;
                    }
                    else {
                        cell.textContent = value || '';
                    }
                });
                const actionCell = row.insertCell();
                if (tableBodyId === 'inventory-table') {
                    actionCell.innerHTML = `<button onclick="showEditProductModal('${item.id}')">Edit</button> <button class="btn-danger" onclick="softDeleteProduct('${item.id}')">Delete</button>`;
                } else if (tableBodyId === 'new-products-table') {
                    actionCell.innerHTML = `<button onclick="showEditNewProductModal('${item.id}')">Edit</button> <button class="btn-danger" onclick="softDeleteNewProduct('${item.id}')">Delete</button>`;
                } else if (tableBodyId === 'master-table') {
                    actionCell.innerHTML = `<button onclick="showEditMasterProductModal('${item.id}')">Edit</button> <button class="btn-danger" onclick="softDeleteMasterProduct('${item.id}')">Delete</button>`;
                } else if (tableBodyId === 'to-clear-table') {
                    actionCell.innerHTML = `<button onclick="showEditToClearModal('${item.id}')">Edit</button> <button class="btn-danger" onclick="softDeleteToClear('${item.id}')">Delete</button>`;
                } else if (tableBodyId === 'recycle-bin-table') {
                    actionCell.innerHTML = `<button class="btn-info" onclick="restoreItem('${item.id}', '${item.originalCollection}')">Restore</button> <button class="btn-danger" onclick="hardDeleteItem('${item.id}', '${item.originalCollection}')">Permanently Delete</button>`;
                }
            });
        }

        // Column configurations for each table
        const inventoryColumns = [
            { field: 'sku', type: 'string' }, { field: 'brand', type: 'string' }, { field: 'product', type: 'string' },
            { field: 'quantity', type: 'number' }, { field: 'status', type: 'string' }, { field: 'expiry', type: 'date' },
            { field: 'shipment', type: 'string' }, { field: 'remarks', type: 'string' }
        ];
        const newProductsColumns = [
            { field: 'sku', type: 'string' }, { field: 'brand', type: 'string' }, { field: 'product', type: 'string' },
            { field: 'addedDate', type: 'date' }, { field: 'arrivalDate', 'type': 'date' }, { field: 'quantity', type: 'number' },
            { field: 'notes', type: 'string' }
        ];
        const masterListColumns = [
            { field: 'sku', type: 'string' }, { field: 'brand', type: 'string' }, { field: 'product', type: 'string' },
            { field: 'category', type: 'string' }, { field: 'description', type: 'string' }, { field: 'price', type: 'number' }
        ];
        const toClearColumns = [
            { field: 'sku', type: 'string' }, { field: 'brand', type: 'string' }, { field: 'product', type: 'string' },
            { field: 'category', type: 'string' }, { field: 'expiryDate', type: 'date' }, { field: 'firstHighlightedDate', type: 'date' },
            { field: 'firstReportedBalance', type: 'number' }, { field: 'warehouseQty', type: 'number' }, { field: 'storeQty', type: 'number' },
            { field: 'totalQty', type: 'number' }, { field: 'weeklyDemand', type: 'number' }, { field: 'weeksSupply', type: 'number' },
            { field: 'supplyStatus', type: 'string' }, { field: 'actionPlan', type: 'string' }
        ];
        const recycleBinColumns = [
            { field: 'sku', type: 'string' }, { field: 'originalCollection', type: 'string' }, { field: 'brand', type: 'string' },
            { field: 'product', type: 'string' }
        ];


        function updateInventoryTableDisplay(dataToDisplay) {
            renderTable('inventory-table', dataToDisplay, inventoryColumns);
        }

        function updateNewProductsTable() {
            renderTable('new-products-table', newProductsData, newProductsColumns);
        }

        function updateMasterTableDisplay(dataToDisplay) {
            renderTable('master-table', dataToDisplay, masterListColumns);
        }

        function updateToClearTableDisplay(dataToDisplay) {
            renderTable('to-clear-table', dataToDisplay, toClearColumns);
        }

        function updateRecycleBinTable() {
            renderTable('recycle-bin-table', deletedItemsData, recycleBinColumns);
        }


        function updateDashboardStats() {
            document.getElementById('oos-count').textContent = inventoryData.filter(item => item.status === 'OOS').length;
            document.getElementById('low-count').textContent = inventoryData.filter(item => item.status && item.status.includes('Low')).length;
            document.getElementById('new-count').textContent = newProductsData.length;
        }

        function updateAlerts() {
            const alertsDiv = document.getElementById('alerts');
            alertsDiv.innerHTML = '';

            const today = new Date();
            let hasAlerts = false;

            // Low Stock Alerts
            const lowStockAlerts = inventoryData.filter(item => item.status && item.status.includes('Low stock'));
            if (lowStockAlerts.length > 0) {
                lowStockAlerts.forEach(item => {
                    alertsDiv.innerHTML += `<p class="alert-status status-badge">${item.product} (${item.brand}) is Low Stock (Qty: ${item.quantity}).</p>`;
                });
                hasAlerts = true;
            }

            // OOS Alerts
            const oosAlerts = inventoryData.filter(item => item.status === 'OOS');
            if (oosAlerts.length > 0) {
                oosAlerts.forEach(item => {
                    alertsDiv.innerHTML += `<p class="danger-status status-badge">${item.product} (${item.brand}) is Out of Stock!</p>`;
                });
                hasAlerts = true;
            }

            // Expiry Alerts (within next 3 months)
            const expiryAlerts = inventoryData.filter(item => {
                if (!item.expiry) return false;
                const expiryDate = new Date(item.expiry);
                const threeMonthsLater = new Date(today);
                threeMonthsLater.setMonth(today.getMonth() + 3);
                return expiryDate <= threeMonthsLater && expiryDate >= today;
            });

            if (expiryAlerts.length > 0) {
                expiryAlerts.forEach(item => {
                    alertsDiv.innerHTML += `<p class="warning status-badge">Expiry Alert: ${item.product} (${item.brand}) expires on ${item.expiry}.</p>`;
                });
                hasAlerts = true;
            }

            // New Product Alerts
            if (newProductsData.length > 0) {
                alertsDiv.innerHTML += `<p class="info status-badge">You have ${newProductsData.length} new products to review and merge.</p>`;
                hasAlerts = true;
            }

            if (!hasAlerts) {
                alertsDiv.innerHTML = '<p>No new alerts at this time.</p>';
            }
        }

        function updateManagementStats() {
            const totalActive = inventoryData.length + newProductsData.length + masterProductsData.length + toClearData.length;
            const totalAll = totalActive + deletedItemsData.length; 
            
            document.getElementById('total-products').textContent = totalActive;
            document.getElementById('total-products-all').textContent = totalAll;
            document.getElementById('last-updated').textContent = new Date().toLocaleString();
        }

        // --- Modal Display Functions ---

        async function showAddProductModal() {
            document.getElementById('productModalTitle').textContent = 'Add New Product';
            document.getElementById('editProductId').value = '';
            document.getElementById('brand').value = '';
            document.getElementById('productName').value = ''; 
            document.getElementById('productsDatalist').innerHTML = ''; 
            document.getElementById('inventoryQuantity').value = ''; 
            document.getElementById('status').value = '';
            document.getElementById('expiry').value = '';
            document.getElementById('shipment').value = '';
            document.getElementById('remarks').value = '';
            populateBrandDropdowns('brand'); 
            populateStatusDropdowns('status'); 
            document.getElementById('productModal').style.display = 'block';
        }

        async function showEditProductModal(id) {
            const productSnap = await inventoryColRef.doc(id).get();
            if (!productSnap.exists) {
                showNotification("Product not found!", "error");
                return;
            }
            const item = productSnap.data();

            document.getElementById('productModalTitle').textContent = 'Edit Product';
            document.getElementById('editProductId').value = id;
            populateBrandDropdowns('brand'); 
            document.getElementById('brand').value = item.brand || '';
            filterProductsForBrand(item.brand || '', 'productName', 'productsDatalist'); 
            document.getElementById('productName').value = item.product || ''; 
            document.getElementById('inventoryQuantity').value = item.quantity !== undefined ? item.quantity : ''; 
            populateStatusDropdowns('status'); 
            document.getElementById('status').value = item.status || '';
            document.getElementById('expiry').value = item.expiry || '';
            document.getElementById('shipment').value = item.shipment || '';
            document.getElementById('remarks').value = item.remarks || '';
            document.getElementById('productModal').style.display = 'block';
        }

        async function showAddNewProductModal() {
            document.getElementById('newProductModalTitle').textContent = 'Add New Product Entry';
            document.getElementById('editNewProductId').value = '';
            document.getElementById('newBrand').value = '';
            document.getElementById('newProductName').value = ''; 
            document.getElementById('newProductsDatalist').innerHTML = ''; 
            document.getElementById('arrivalDate').value = '';
            document.getElementById('quantity').value = '';
            document.getElementById('notes').value = '';
            populateBrandDropdowns('newBrand'); 
            document.getElementById('newProductModal').style.display = 'block';
        }

        async function showEditNewProductModal(id) {
            const productSnap = await newProductsColRef.doc(id).get();
            if (!productSnap.exists) {
                showNotification("New Product not found!", "error");
                return;
            }
            const item = productSnap.data();

            document.getElementById('newProductModalTitle').textContent = 'Edit New Product';
            document.getElementById('editNewProductId').value = id;
            populateBrandDropdowns('newBrand'); 
            document.getElementById('newBrand').value = item.brand || '';
            filterProductsForBrand(item.brand || '', 'newProductName', 'newProductsDatalist'); 
            document.getElementById('newProductName').value = item.product || ''; 
            document.getElementById('quantity').value = item.quantity || '';
            document.getElementById('arrivalDate').value = item.arrivalDate || '';
            document.getElementById('notes').value = item.notes || '';
            document.getElementById('newProductModal').style.display = 'block';
        }

        async function showAddMasterProductModal() {
            document.getElementById('masterProductModalTitle').textContent = 'Add Master Product';
            document.getElementById('editMasterProductId').value = '';
            document.getElementById('masterBrand').value = '';
            document.getElementById('masterProductName').value = '';
            document.getElementById('category').value = '';
            document.getElementById('description').value = '';
            document.getElementById('sku').value = '';
            document.getElementById('price').value = '';
            populateBrandDropdowns('masterBrand'); 
            populateCategoryDropdowns('category'); 
            document.getElementById('masterProductModal').style.display = 'block';
        }

        async function showEditMasterProductModal(id) {
            const productSnap = await masterProductsColRef.doc(id).get();
            if (!productSnap.exists) {
                showNotification("Master Product not found!", "error");
                return;
            }
            const item = productSnap.data();

            document.getElementById('masterProductModalTitle').textContent = 'Edit Master Product';
            document.getElementById('editMasterProductId').value = id;
            populateBrandDropdowns('masterBrand'); 
            document.getElementById('masterBrand').value = item.brand || '';
            document.getElementById('masterProductName').value = item.product || '';
            populateCategoryDropdowns('category'); 
            document.getElementById('category').value = item.category || '';
            document.getElementById('description').value = item.description || '';
            document.getElementById('sku').value = item.sku || '';
            document.getElementById('price').value = item.price || '';
            document.getElementById('masterProductModal').style.display = 'block';
        }

        async function showAddToClearModal() {
            document.getElementById('toClearModalTitle').textContent = 'Add Product to Clear';
            document.getElementById('editToClearId').value = '';
            document.getElementById('toClearBrand').value = '';
            document.getElementById('toClearProductName').value = ''; 
            document.getElementById('toClearProductsDatalist').innerHTML = ''; 
            document.getElementById('toClearCategory').value = '';
            document.getElementById('toClearExpiryDate').value = '';
            document.getElementById('toClearWarehouseQty').value = ''; 
            document.getElementById('toClearStoreQty').value = '';     
            document.getElementById('toClearWeeklyDemand').value = '';
            document.getElementById('toClearActionPlan').value = '';
            
            const today = new Date().toISOString().slice(0, 10);
            document.getElementById('toClearFirstHighlightedDate').value = today;
            document.getElementById('toClearFirstReportedBalance').value = ''; 

            populateBrandDropdowns('toClearBrand'); 
            populateCategoryDropdowns('toClearCategory'); 
            document.getElementById('toClearModal').style.display = 'block';
        }

        async function showEditToClearModal(id) {
            const productSnap = await toClearColRef.doc(id).get();
            if (!productSnap.exists) {
                showNotification("Product to Clear not found!", "error");
                return;
            }
            const item = productSnap.data();

            document.getElementById('toClearModalTitle').textContent = 'Edit Product to Clear';
            document.getElementById('editToClearId').value = id;
            populateBrandDropdowns('toClearBrand'); 
            document.getElementById('toClearBrand').value = item.brand || '';
            filterProductsForBrand(item.brand || '', 'toClearProductName', 'toClearProductsDatalist'); 
            document.getElementById('toClearProductName').value = item.product || ''; 
            populateCategoryDropdowns('toClearCategory'); 
            document.getElementById('toClearCategory').value = item.category || '';
            document.getElementById('toClearExpiryDate').value = item.expiryDate || '';
            document.getElementById('toClearWarehouseQty').value = item.warehouseQty || ''; 
            document.getElementById('toClearStoreQty').value = item.storeQty || '';     
            document.getElementById('toClearWeeklyDemand').value = item.weeklyDemand || '';
            document.getElementById('toClearActionPlan').value = item.actionPlan || '';

            document.getElementById('toClearFirstHighlightedDate').value = item.firstHighlightedDate || '';
            document.getElementById('toClearFirstReportedBalance').value = item.firstReportedBalance !== undefined ? item.firstReportedBalance : '';

            document.getElementById('toClearModal').style.display = 'block';
        }

        // --- Dynamic Dropdown Population Logic ---

        function populateSelect(selectElementId, dataArray, valueKey, textKey, addNewOption = false, addNewModalId = '') {
            const selectElement = document.getElementById(selectElementId);
            if (!selectElement) {
                console.error(`Select element with ID "${selectElementId}" not found.`);
                return;
            }
            const currentValue = selectElement.value; // Store current value before clearing
            selectElement.innerHTML = '<option value="">Select...</option>'; 

            dataArray.sort((a, b) => (a[textKey] || '').localeCompare(b[textKey] || ''));

            dataArray.forEach(item => {
                const option = document.createElement('option');
                option.value = item[valueKey];
                option.textContent = item[textKey];
                selectElement.appendChild(option);
            });

            if (addNewOption) {
                const addOption = document.createElement('option');
                addOption.value = `__add_new_${selectElementId}__`; 
                addOption.textContent = `+ Add New ${textKey.charAt(0).toUpperCase() + textKey.slice(1)}...`;
                selectElement.appendChild(addOption);

                selectElement.onchange = function() {
                    if (this.value === `__add_new_${selectElementId}__`) {
                        closeAllModals(); 
                        document.getElementById(addNewModalId).style.display = 'block';
                        // Store the ID of the select element that triggered this, for later pre-selection
                        document.getElementById(addNewModalId).querySelector('input[type="text"]').dataset.callingSelect = selectElementId;
                        this.value = ''; 
                    }
                };
            }
            // Restore previous selection if it's still a valid option
            if (currentValue && selectElement.querySelector(`option[value="${currentValue}"]`)) {
                selectElement.value = currentValue;
            }
        }

        function populateAllDropdowns() {
            populateSelect('brand', brandsData, 'name', 'name', true, 'addNewBrandModal');
            populateSelect('newBrand', brandsData, 'name', 'name', true, 'addNewBrandModal');
            populateSelect('masterBrand', brandsData, 'name', 'name', true, 'addNewBrandModal');
            populateSelect('toClearBrand', brandsData, 'name', 'name', true, 'addNewBrandModal');

            populateSelect('status', statusesData, 'name', 'name', true, 'addNewStatusModal');

            populateSelect('category', categoriesData, 'name', 'name', true, 'addNewCategoryModal');
            populateSelect('toClearCategory', categoriesData, 'name', 'name', true, 'addNewCategoryModal');

            populateProductDatalists(); 

            // Populate filter dropdowns
            populateFilterDropdown('oosLowStockBrandFilter', brandsData, 'name', 'name');
            populateFilterDropdown('oosLowStockStatusFilter', statusesData, 'name', 'name');
            populateFilterDropdown('masterListBrandFilter', brandsData, 'name', 'name');
            populateFilterDropdown('masterListCategoryFilter', categoriesData, 'name', 'name');
            populateFilterDropdown('toClearBrandFilter', brandsData, 'name', 'name');
            populateFilterDropdown('toClearCategoryFilter', categoriesData, 'name', 'name');
        }

        // Generic function to populate filter dropdowns (without "Add New" option)
        function populateFilterDropdown(selectElementId, dataArray, valueKey, textKey) {
            const selectElement = document.getElementById(selectElementId);
            if (!selectElement) {
                console.error(`Filter select element with ID "${selectElementId}" not found.`);
                return;
            }
            const currentValue = selectElement.value;
            selectElement.innerHTML = '<option value="">All</option>'; // Default "All" option

            dataArray.sort((a, b) => (a[textKey] || '').localeCompare(b[textKey] || ''));

            dataArray.forEach(item => {
                const option = document.createElement('option');
                option.value = item[valueKey];
                option.textContent = item[textKey];
                selectElement.appendChild(option);
            });
            if (currentValue && selectElement.querySelector(`option[value="${currentValue}"]`)) {
                selectElement.value = currentValue;
            }
        }


        // Handle adding new Brand
        async function handleAddNewBrand(event) {
            event.preventDefault();
            const newBrandName = document.getElementById('newBrandNameInput').value.trim();
            const callingSelectId = document.getElementById('newBrandNameInput').dataset.callingSelect;

            if (newBrandName && !brandsData.some(b => b.name.toLowerCase() === newBrandName.toLowerCase())) {
                try {
                    await brandsColRef.add({ name: newBrandName });
                    showNotification(`Brand "${newBrandName}" added!`, 'success');
                    closeModal('addNewBrandModal');
                    document.getElementById('newBrandNameInput').value = ''; 
                    await updateLocalData(); 
                    // Pre-select the newly added brand in the calling dropdown
                    if (callingSelectId && document.getElementById(callingSelectId)) {
                        document.getElementById(callingSelectId).value = newBrandName;
                        // If it's a product modal brand select, trigger its onchange to filter products
                        if (callingSelectId === 'brand' || callingSelectId === 'newBrand' || callingSelectId === 'toClearBrand') {
                            filterProductsForBrand(newBrandName, document.getElementById(callingSelectId).nextElementSibling.nextElementSibling.id, document.getElementById(callingSelectId).nextElementSibling.nextElementSibling.list.id);
                        }
                    }
                } catch (e) {
                    console.error("Error adding new brand:", e);
                    showNotification('Error adding new brand.', 'error');
                }
            } else {
                showNotification('Brand name is empty or already exists!', 'warning');
            }
        }

        // Handle adding new Status
        async function handleAddNewStatus(event) {
            event.preventDefault();
            const newStatusName = document.getElementById('newStatusNameInput').value.trim();
            const callingSelectId = document.getElementById('newStatusNameInput').dataset.callingSelect;

            if (newStatusName && !statusesData.some(s => s.name.toLowerCase() === newStatusName.toLowerCase())) {
                try {
                    await statusesColRef.add({ name: newStatusName });
                    showNotification(`Status "${newStatusName}" added!`, 'success');
                    closeModal('addNewStatusModal');
                    document.getElementById('newStatusNameInput').value = ''; 
                    await updateLocalData(); 
                    if (callingSelectId && document.getElementById(callingSelectId)) {
                        document.getElementById(callingSelectId).value = newStatusName;
                    }
                } catch (e) {
                    console.error("Error adding new status:", e);
                    showNotification('Error adding new status.', 'error');
                }
            } else {
                showNotification('Status name is empty or already exists!', 'warning');
            }
        }

        // Handle adding new Category
        async function handleAddNewCategory(event) {
            event.preventDefault();
            const newCategoryName = document.getElementById('newCategoryNameInput').value.trim();
            const callingSelectId = document.getElementById('newCategoryNameInput').dataset.callingSelect;

            if (newCategoryName && !categoriesData.some(c => c.name.toLowerCase() === newCategoryName.toLowerCase())) {
                try {
                    await categoriesColRef.add({ name: newCategoryName });
                    showNotification(`Category "${newCategoryName}" added!`, 'success');
                    closeModal('addNewCategoryModal');
                    document.getElementById('newCategoryNameInput').value = ''; 
                    await updateLocalData(); 
                    if (callingSelectId && document.getElementById(callingSelectId)) {
                        document.getElementById(callingSelectId).value = newCategoryName;
                    }
                } catch (e) {
                    console.error("Error adding new category:", e);
                    showNotification('Error adding new category.', 'error');
                }
            } else {
                showNotification('Category name is empty or already exists!', 'warning');
            }
        }

        // Close all modals helper
        function closeAllModals() {
            document.querySelectorAll('.modal').forEach(modal => {
                modal.style.display = 'none';
            });
        }

        // --- Product Datalist Population (from Master List, filtered by Brand) ---
        function populateProductDatalists() {
            const formGroups = [
                { brandSelectId: 'brand', productInputId: 'productName', datalistId: 'productsDatalist' },
                { brandSelectId: 'newBrand', productInputId: 'newProductName', datalistId: 'newProductsDatalist' },
                { brandSelectId: 'toClearBrand', productInputId: 'toClearProductName', datalistId: 'toClearProductsDatalist' }
            ];

            formGroups.forEach(group => {
                const brandSelect = document.getElementById(group.brandSelectId);
                if (brandSelect) {
                    filterProductsForBrand(brandSelect.value, group.productInputId, group.datalistId);
                }
            });
        }

        function filterProductsForBrand(selectedBrand, productInputId, datalistId) {
            const productInput = document.getElementById(productInputId);
            const datalist = document.getElementById(datalistId);
            if (!productInput || !datalist) return;

            datalist.innerHTML = ''; 

            if (selectedBrand && selectedBrand !== `__add_new_${productInputId.replace('Name', '')}__`) {
                const filteredProducts = masterProductsData.filter(item => item.brand === selectedBrand);
                filteredProducts.sort((a, b) => (a.product || '').localeCompare(b.product || ''));

                filteredProducts.forEach(product => {
                    const option = document.createElement('option');
                    option.value = product.product;
                    datalist.appendChild(option);
                });
            }
            const currentProductValue = productInput.value;
            if (currentProductValue && selectedBrand && 
                !masterProductsData.some(p => p.brand === selectedBrand && p.product === currentProductValue)) {
                productInput.value = '';
            }
        }

        // --- Tab Switching Logic ---
        function switchTab(clickedTabElement, tabId) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            clickedTabElement.classList.add('active');
            document.getElementById(tabId).classList.add('active');

            // Apply filters/search specific to the tab when switching
            if (tabId === 'oos-lowstock') {
                applyInventoryFilters();
            } else if (tabId === 'new-products') {
                applyNewProductsFilters();
            } else if (tabId === 'to-clear') {
                applyToClearFilters();
            } else if (tabId === 'master-list') {
                applyMasterListFilters();
            } else if (tabId === 'recycle-bin') {
                updateRecycleBinTable();
            }
        }

        // --- Search and Filter Functions ---

        // Generic function to apply search and filters to a dataset
        function applyFilters(data, searchInputId, filtersConfig) {
            let filteredData = [...data];
            const searchTerm = document.getElementById(searchInputId)?.value.toLowerCase() || '';

            // Apply search filter
            if (searchTerm) {
                filteredData = filteredData.filter(item => {
                    return Object.values(item).some(value => 
                        String(value).toLowerCase().includes(searchTerm)
                    );
                });
            }

            // Apply dropdown filters
            filtersConfig.forEach(filter => {
                const filterValue = document.getElementById(filter.id)?.value;
                if (filterValue) {
                    filteredData = filteredData.filter(item => String(item[filter.field]) === filterValue);
                }
            });
            return filteredData;
        }

        // Inventory (OOS/Low Stock) Filters
        function applyInventoryFilters() {
            const searchInputId = 'oosLowStockSearchInput';
            const filtersConfig = [
                { id: 'oosLowStockBrandFilter', field: 'brand' },
                { id: 'oosLowStockStatusFilter', field: 'status' }
            ];
            const filteredData = applyFilters(inventoryData, searchInputId, filtersConfig);
            updateInventoryTableDisplay(filteredData);
        }

        // New Products Filters (only search)
        function applyNewProductsFilters() {
            const searchInputId = 'newProductsSearchInput';
            const filteredData = applyFilters(newProductsData, searchInputId, []);
            updateNewProductsTableDisplay(filteredData); // Renamed for consistency
        }
        // New function to update new products table with filtered data
        function updateNewProductsTableDisplay(dataToDisplay) {
            renderTable('new-products-table', dataToDisplay, newProductsColumns);
        }


        // Master List Filters
        function applyMasterListFilters() {
            const searchInputId = 'masterListSearchInput';
            const filtersConfig = [
                { id: 'masterListBrandFilter', field: 'brand' },
                { id: 'masterListCategoryFilter', field: 'category' }
            ];
            const filteredData = applyFilters(masterProductsData, searchInputId, filtersConfig);
            updateMasterTableDisplay(filteredData);
        }

        // To Clear Filters
        function applyToClearFilters() {
            const searchInputId = 'toClearSearchInput';
            const filtersConfig = [
                { id: 'toClearBrandFilter', field: 'brand' },
                { id: 'toClearCategoryFilter', field: 'category' }
            ];
            const filteredData = applyFilters(toClearData, searchInputId, filtersConfig);
            updateToClearTableDisplay(filteredData);
        }

        // Attach event listeners for search inputs
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('oosLowStockSearchInput')?.addEventListener('keyup', applyInventoryFilters);
            document.getElementById('newProductsSearchInput')?.addEventListener('keyup', applyNewProductsFilters);
            document.getElementById('masterListSearchInput')?.addEventListener('keyup', applyMasterListFilters);
            document.getElementById('toClearSearchInput')?.addEventListener('keyup', applyToClearFilters);
        });


        // --- Sorting Functions ---
        let sortDirection = {}; // Stores the current sort direction for each column (e.g., { 'sku': 'asc', 'brand': 'desc' })

        function attachSortListeners() {
            const tables = [
                { id: 'inventory-table', columns: inventoryColumns },
                { id: 'new-products-table', columns: newProductsColumns },
                { id: 'master-table', columns: masterListColumns },
                { id: 'to-clear-table', columns: toClearColumns },
                { id: 'recycle-bin-table', columns: recycleBinColumns }
            ];

            tables.forEach(table => {
                const headerRow = document.querySelector(`#${table.id} thead tr`);
                if (headerRow) {
                    Array.from(headerRow.children).forEach((th, index) => {
                        const columnField = th.getAttribute('data-column');
                        if (columnField) { // Only attach if data-column is present
                            th.style.cursor = 'pointer';
                            th.onclick = () => sortTable(table.id, columnField, table.columns[index].type);
                        }
                    });
                }
            });
        }

        function sortTable(tableId, columnField, dataType) {
            let dataToSort;
            let renderFunction;
            let columnsConfig;

            // Determine which global data array and render function to use
            if (tableId === 'inventory-table') {
                dataToSort = inventoryData;
                renderFunction = updateInventoryTableDisplay;
                columnsConfig = inventoryColumns;
            } else if (tableId === 'new-products-table') {
                dataToSort = newProductsData;
                renderFunction = updateNewProductsTableDisplay;
                columnsConfig = newProductsColumns;
            } else if (tableId === 'master-table') {
                dataToSort = masterProductsData;
                renderFunction = updateMasterTableDisplay;
                columnsConfig = masterListColumns;
            } else if (tableId === 'to-clear-table') {
                dataToSort = toClearData;
                renderFunction = updateToClearTableDisplay;
                columnsConfig = toClearColumns;
            } else if (tableId === 'recycle-bin-table') {
                dataToSort = deletedItemsData;
                renderFunction = updateRecycleBinTable;
                columnsConfig = recycleBinColumns;
            } else {
                console.error(`Unknown tableId: ${tableId}`);
                return;
            }

            // Toggle sort direction for the clicked column
            if (sortDirection[columnField] === 'asc') {
                sortDirection[columnField] = 'desc';
            } else {
                sortDirection[columnField] = 'asc';
            }
            const direction = sortDirection[columnField];

            // Sort the data
            dataToSort.sort((a, b) => {
                let valA = a[columnField];
                let valB = b[columnField];

                // Handle special cases for derived fields (like totalQty, weeksSupply, supplyStatus)
                if (columnField === 'totalQty') {
                    valA = (a.warehouseQty || 0) + (a.storeQty || 0);
                    valB = (b.warehouseQty || 0) + (b.storeQty || 0);
                    dataType = 'number';
                } else if (columnField === 'weeksSupply') {
                    const totalA = (a.warehouseQty || 0) + (a.storeQty || 0);
                    const totalB = (b.warehouseQty || 0) + (b.storeQty || 0);
                    valA = (a.weeklyDemand > 0) ? (totalA / a.weeklyDemand) : -Infinity; // Treat N/A as very low for sorting
                    valB = (b.weeklyDemand > 0) ? (totalB / b.weeklyDemand) : -Infinity;
                    dataType = 'number';
                } else if (columnField === 'supplyStatus') {
                    // Custom sorting for supply status: Danger, Alert, Normal, N/A
                    const statusOrder = { 'Low Supply': 1, 'Alert': 2, 'Good Supply': 3, 'Excess Supply': 4, 'N/A': 5 };
                    const totalA = (a.warehouseQty || 0) + (a.storeQty || 0);
                    const totalB = (b.warehouseQty || 0) + (b.storeQty || 0);
                    const weeksA = (a.weeklyDemand > 0) ? (totalA / a.weeklyDemand) : null;
                    const weeksB = (b.weeklyDemand > 0) ? (totalB / b.weeklyDemand) : null;

                    let statusA = 'N/A';
                    if (weeksA !== null) {
                        if (weeksA < 4) statusA = 'Low Supply';
                        else if (weeksA >= 4 && weeksA <= 12) statusA = 'Good Supply';
                        else statusA = 'Excess Supply';
                    }
                    let statusB = 'N/A';
                    if (weeksB !== null) {
                        if (weeksB < 4) statusB = 'Low Supply';
                        else if (weeksB >= 4 && weeksB <= 12) statusB = 'Good Supply';
                        else statusB = 'Excess Supply';
                    }
                    valA = statusOrder[statusA];
                    valB = statusOrder[statusB];
                    dataType = 'number'; // Compare by numeric order
                }


                // Type-specific comparison
                if (dataType === 'number') {
                    valA = parseFloat(valA) || 0;
                    valB = parseFloat(valB) || 0;
                } else if (dataType === 'date') {
                    valA = valA ? new Date(valA) : new Date(0); // Use epoch for empty dates
                    valB = valB ? new Date(valB) : new Date(0);
                } else { // string comparison
                    valA = String(valA).toLowerCase();
                    valB = String(valB).toLowerCase();
                }

                if (valA < valB) {
                    return direction === 'asc' ? -1 : 1;
                }
                if (valA > valB) {
                    return direction === 'asc' ? 1 : -1;
                }
                return 0;
            });

            // Re-render the table with sorted data
            renderFunction(dataToSort);

            // Update visual sort indicators
            const headers = document.querySelectorAll(`#${tableId} thead th`);
            headers.forEach(header => {
                header.classList.remove('sort-asc', 'sort-desc');
            });
            const currentHeader = document.querySelector(`#${tableId} thead th[data-column="${columnField}"]`);
            if (currentHeader) {
                currentHeader.classList.add(`sort-${direction}`);
            }
        }


        // --- Export/Import (CSV) ---
        function convertToCSV(data, headers) {
            if (data.length === 0) return headers.join(',') + '\n';
            const csvRows = [];
            csvRows.push(headers.join(',')); // Add header row

            data.forEach(row => {
                const values = headers.map(header => {
                    let value = row[header] !== undefined ? row[header] : '';
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                        return `"${value.replace(/"/g, '""')}"`; // Escape quotes and enclose in quotes
                    }
                    return value;
                });
                csvRows.push(values.join(','));
            });
            return csvRows.join('\n');
        }

        async function exportAllData() {
            try {
                let csvContent = "";

                const invHeaders = ['sku', 'brand', 'product', 'quantity', 'status', 'expiry', 'shipment', 'remarks', 'isDeleted', 'deletedDate', 'originalCollection'];
                csvContent += "INVENTORY DATA\n";
                csvContent += convertToCSV(await fetchDataFromFirestore(inventoryColRef, true), invHeaders);

                const newProdHeaders = ['sku', 'brand', 'product', 'addedDate', 'arrivalDate', 'quantity', 'notes', 'isDeleted', 'deletedDate', 'originalCollection'];
                csvContent += "\n\nNEW PRODUCTS DATA\n";
                csvContent += convertToCSV(await fetchDataFromFirestore(newProductsColRef, true), newProdHeaders);

                const toClearHeaders = ['sku', 'brand', 'product', 'category', 'expiryDate', 'firstHighlightedDate', 'firstReportedBalance', 'warehouseQty', 'storeQty', 'weeklyDemand', 'actionPlan', 'isDeleted', 'deletedDate', 'originalCollection'];
                csvContent += "\n\nTO CLEAR DATA\n";
                csvContent += convertToCSV(await fetchDataFromFirestore(toClearColRef, true), toClearHeaders);

                const masterHeaders = ['sku', 'brand', 'product', 'category', 'description', 'price', 'isDeleted', 'deletedDate', 'originalCollection'];
                csvContent += "\n\nMASTER PRODUCTS DATA\n";
                csvContent += convertToCSV(await fetchDataFromFirestore(masterProductsColRef, true), masterHeaders);
                
                csvContent += "\n\nBRANDS DATA\n";
                csvContent += convertToCSV(await fetchDataFromFirestore(brandsColRef, true), ['name']);

                csvContent += "\n\nSTATUSES DATA\n";
                csvContent += convertToCSV(await fetchDataFromFirestore(statusesColRef, true), ['name']);

                csvContent += "\n\nCATEGORIES DATA\n";
                csvContent += convertToCSV(await fetchDataFromFirestore(categoriesColRef, true), ['name']);


                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.setAttribute('download', `all_inventory_data_${new Date().toISOString().slice(0, 10)}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                showNotification('All data exported successfully!', 'success');
            } catch (error) {
                console.error("Error exporting all data:", error);
                showNotification('Error exporting all data. Check console for details.', 'error');
            }
        }

        function exportMasterList() {
            const headers = ['sku', 'brand', 'product', 'category', 'description', 'price'];
            const csv = convertToCSV(masterProductsData, headers);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.setAttribute('download', `master_products_${new Date().toISOString().slice(0, 10)}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            showNotification('Master list exported successfully!', 'success');
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '\"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result;
        }

        async function parseCSVAndUpload(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim() !== ''); 

            if (lines.length === 0) {
                showNotification('CSV file is empty!', 'error');
                return;
            }

            const headers = parseCSVLine(lines[0]);
            const dataLines = lines.slice(1); 

            const expectedHeaders = {
                "Product Code": "sku",
                "Brand": "brand",
                "Product Name": "product",
                "Category": "category",
                "Description": "description",
                "Price": "price"
            };

            const headerIndices = {};
            for (const key in expectedHeaders) {
                const index = headers.findIndex(h => h.trim().toLowerCase() === key.toLowerCase());
                if (index === -1) {
                    showNotification(`CSV missing required header: "${key}"`, 'error');
                    return; 
                }
                headerIndices[expectedHeaders[key]] = index;
            }

            const productsToBatch = [];
            const skippedSKUs = [];

            for (const line of dataLines) {
                const values = parseCSVLine(line);
                if (values.length < headers.length) {
                    console.warn(`Skipping malformed row: ${line}`);
                    continue;
                }

                const productData = {};
                for (const prop in headerIndices) {
                    productData[prop] = values[headerIndices[prop]] || '';
                }

                productData.price = parseFloat(productData.price) || 0;
                productData.isDeleted = false; 

                const existingProduct = masterProductsData.find(item => item.sku === productData.sku && !item.isDeleted);

                if (existingProduct) {
                    skippedSKUs.push(productData.sku);
                } else {
                    productsToBatch.push(productData);
                }
            }

            if (productsToBatch.length === 0 && skippedSKUs.length === 0) {
                showNotification('No valid products found in CSV or all were duplicates.', 'info');
                return;
            }

            const batch = db.batch(); 

            productsToBatch.forEach(product => {
                const docRef = masterProductsColRef.doc(); 
                batch.set(docRef, product);
            });

            try {
                await batch.commit();
                showNotification(`Successfully imported ${productsToBatch.length} new products to Master List!`, 'success');
                if (skippedSKUs.length > 0) {
                    showNotification(`Skipped ${skippedSKUs.length} products (duplicate SKUs): ${skippedSKUs.join(', ')}`, 'warning');
                }
                await updateLocalData(); 
            } catch (error) {
                console.error("Error importing CSV to Firestore:", error);
                showNotification('Error importing CSV. Check console for details.', 'error');
            }
        }

        async function importCSV(event) {
            const file = event.target.files[0];
            if (!file) {
                showNotification('No file selected!', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = async function(e) {
                const csvText = e.target.result;
                await parseCSVAndUpload(csvText); 
            };
            reader.readAsText(file);

            event.target.value = ''; 
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = 'none';
            }
        }

        /**
         * Merges all products from the 'new_products' collection into the 'inventory' collection.
         * After merging, the 'new_products' collection is cleared.
         */
        async function mergeNewProductsToMaster() {
            if (newProductsData.length === 0) {
                showNotification('No new products to merge.', 'info');
                return;
            }

            showNotification('Merging new products to inventory...', 'info');
            const productsToMerge = [];
            const batch = db.batch();

            try {
                for (const newProduct of newProductsData) {
                    const inventoryItem = {
                        brand: newProduct.brand || '',
                        product: newProduct.product || '',
                        sku: newProduct.sku || '',
                        quantity: newProduct.quantity || 0,
                        status: 'In Stock', 
                        expiry: '', 
                        shipment: newProduct.arrivalDate || '', 
                        remarks: newProduct.notes || '', 
                        isDeleted: false
                    };

                    const docRef = inventoryColRef.doc(); 
                    batch.set(docRef, inventoryItem);

                    const newProductDocRef = newProductsColRef.doc(newProduct.id);
                    batch.delete(newProductDocRef);

                    productsToMerge.push(inventoryItem); 
                }

                await batch.commit(); 

                await updateLocalData(); 
                showNotification(`${productsToMerge.length} new products merged into Inventory and cleared from New Products!`, 'success');

            } catch (e) {
                console.error("Error merging new products:", e);
                showNotification('Error merging new products. Please try again.', 'error');
            }
        }

        // Initialize on load: Fetch data from Firestore
        window.onload = async function() {
            await updateLocalData();
            const dashboardTab = document.querySelector('.tab[onclick*=\'dashboard\']');
            if (dashboardTab) {
                switchTab(dashboardTab, 'dashboard');
            } else {
                console.error("Dashboard tab element not found on load.");
                document.getElementById('dashboard').classList.add('active');
            }
        };
    </script>
</body>
</html>
