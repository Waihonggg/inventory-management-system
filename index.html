<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory Management System</title>
    <style>
        /* General Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Body Styling */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333; /* Default text color for better contrast on white backgrounds */
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border-radius: 15px;
        }

        /* Headings */
        h1 {
            color: #2c3e50;
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        /* Tabs Navigation */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 2px solid #ecf0f1;
            overflow-x: auto;
            gap: 2px;
        }

        .tab {
            padding: 15px 20px;
            cursor: pointer;
            background-color: transparent;
            border-radius: 10px 10px 0 0;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 11px;
            transition: all 0.3s ease;
            white-space: nowrap;
            color: #7f8c8d;
            min-width: 120px;
            text-align: center;
            border: 2px solid transparent;
            border-bottom: none;
        }

        .tab:hover {
            background-color: #f8f9fa;
            color: #2c3e50;
            border-color: #e1e8ed;
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateY(-2px);
            border-color: #667eea; /* Match gradient start */
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Stats Cards for Dashboard */
        .stats-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.4);
        }

        .stat-card.urgent {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
         .stat-card.urgent:hover {
            box-shadow: 0 15px 35px rgba(231, 76, 60, 0.4);
        }

        .stat-card.warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }
        .stat-card.warning:hover {
            box-shadow: 0 15px 35px rgba(243, 156, 18, 0.4);
        }

        .stat-card.info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }
         .stat-card.info:hover {
            box-shadow: 0 15px 35px rgba(52, 152, 219, 0.4);
        }


        .stat-number {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 10px;
            line-height: 1;
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Controls (Buttons, Search) */
        .controls {
            margin: 20px 0; /* Keep vertical margin */
            display: flex;
            justify-content: space-between;
            align-items: flex-start; 
            flex-wrap: wrap;
            gap: 15px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e1e8ed;
        }
         .controls > * { 
            flex-shrink: 0;
        }


        /* Table Styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 25px; /* Increased margin for spacing */
            background: white;
            border-radius: 10px;
            overflow: hidden; /* Important for border-radius on table */
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }

        th, td {
            padding: 14px; /* Increased padding for more space */
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
            vertical-align: middle; /* Better vertical alignment */
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.6px; /* Slightly increased letter spacing */
            font-size: 12px;
            cursor: pointer; 
        }
        th .sort-arrow { 
            font-size: 0.8em;
            margin-left: 5px;
        }
        
        /* Zebra striping for table body rows */
        tbody tr:nth-child(even) {
            background-color: #f9f9fc; /* Very light purple/grey */
        }

        tbody tr:hover {
            background-color: #f1f3f5; /* Slightly darker hover for better feedback */
        }

        /* Right-align specific numeric columns */
        #inventory-table td:nth-child(4), /* Quantity */
        #new-products-table td:nth-child(6), /* Quantity */
        #to-clear-table td:nth-child(7), /* Initial Bal */
        #to-clear-table td:nth-child(8), /* WH Qty */
        #to-clear-table td:nth-child(9), /* Store Qty */
        #to-clear-table td:nth-child(10), /* Total Qty */
        #to-clear-table td:nth-child(11), /* Weekly Demand */
        #to-clear-table td:nth-child(12), /* Weeks Supply */
        #master-table td:nth-child(6) /* Price */
        {
            text-align: right;
            font-variant-numeric: tabular-nums; /* Helps align numbers if using proportional fonts */
        }


        /* Status Badges */
        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px; /* Slightly smaller for compactness */
            font-weight: bold;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-block;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .oos {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .low {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .normal {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }

        .danger-status {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .alert-status {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        /* General Buttons */
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 11px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }
         .btn-success:hover {
            box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4);
        }


        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        .btn-danger:hover {
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }

        .btn-info {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }
         .btn-info:hover {
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        /* Refined styles for buttons within table cells */
        td button.btn-info,
        td button.btn-danger,
        td button.btn-success {
            padding: 7px 10px;   /* Reduced padding for compactness */
            font-size: 10px;    /* Smaller font for text like "Edit", "Delete" */
            letter-spacing: 0.3px; /* Adjust letter spacing for smaller font */
            border-radius: 18px; /* Keep pill shape, but ensure it's compact */
            margin: 3px;         /* Spacing between buttons in a cell */
            /* Inherits general hover effects, no need to redefine transform here unless different behavior is wanted */
        }


        /* Search Box */
        .search-box {
            padding: 12px 16px;
            width: 280px;
            border: 2px solid #e1e8ed;
            border-radius: 25px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%237f8c8d' class='bi bi-search' viewBox='0 0 16 16'%3E%3Cpath d='M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z'/%3E%3C/svg%3E") no-repeat 12px center; /* Added search icon */
            padding-left: 35px; /* Space for the icon */
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .search-box:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2); /* Slightly more visible focus */
        }

        /* Modal Styling */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 30px;
            border: none;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close:hover {
            color: #e74c3c;
        }

        /* Form Group */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        .form-group input:disabled, .form-group select:disabled, .form-group textarea:disabled {
            background-color: #f0f0f0;
            opacity: 0.7;
            cursor: not-allowed;
        }
        .form-group label.disabled-label {
            opacity: 0.5;
        }


        /* Alert Notifications */
        .alert {
            padding: 15px 20px; /* More padding */
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 600;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            max-width: 320px; /* Slightly wider */
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* Stronger shadow */
            border-left-width: 5px; /* Accent border */
            border-left-style: solid;
        }

        .alert-success {
            background-color: #e6f7ed; /* Lighter green */
            color: #0f5132; /* Darker text for contrast */
            border-color: #27ae60; /* Accent color */
        }

        .alert-error {
            background-color: #fbe9e7; /* Lighter red */
            color: #842029; /* Darker text */
            border-color: #e74c3c; /* Accent color */
        }

        /* Confirmation Modal Specific Styles */
        #confirmModal .modal-content {
            text-align: center;
            padding: 40px;
            max-width: 450px;
        }

        #confirmModal .modal-content h2 {
            margin-bottom: 20px;
            color: #333;
        }

        #confirmModal .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
        }

        #confirmModal .modal-buttons button {
            flex: 1;
            max-width: 150px;
            padding: 12px 25px;
            font-size: 14px;
        }

        /* --- Mobile Responsiveness --- */
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
                border-radius: 10px;
            }

            h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 1rem;
                margin-bottom: 20px;
            }

            .tabs {
                flex-wrap: wrap; 
                justify-content: center; 
                border-bottom: none; 
            }

            .tab {
                min-width: unset; 
                flex: 1 1 auto; 
                padding: 10px 15px;
                font-size: 10px;
                border-bottom: 2px solid #ecf0f1; 
            }

            .tab.active {
                transform: none; 
                box-shadow: none; 
                border-bottom: 2px solid #667eea;
            }

            .stats-cards {
                grid-template-columns: 1fr; 
            }

            .stat-card {
                padding: 20px;
            }

            .stat-number {
                font-size: 2.5rem;
            }

            .controls {
                flex-direction: column; 
                align-items: stretch; 
                padding: 15px;
            }
            .controls .search-box { 
                 width: 100%;
            }


            button { /* General button stacking */
                width: 100%;
                margin-bottom: 10px; 
                font-size: 12px;
                padding: 10px 15px;
            }
             /* Ensure table action buttons don't go full width on mobile */
            td button.btn-info,
            td button.btn-danger,
            td button.btn-success {
                width: auto; /* Override full width for table buttons */
                margin-bottom: 2px; /* Reduce margin if stacked vertically in a small cell */
            }


            .search-box { 
                width: 100%; 
                padding-left: 35px; /* Ensure icon space maintained */
            }


            /* Responsive Tables: force table to scroll horizontally */
            table {
                display: block; 
                width: 100%;
                overflow-x: auto; 
                -webkit-overflow-scrolling: touch; 
                white-space: nowrap; 
            }

            th, td {
                min-width: 120px; /* Ensure columns have a minimum width for readability */
                padding: 10px;    /* Adjust padding for mobile if needed */
            }
            /* Adjust right-alignment for mobile if it causes issues, or keep it */
            #inventory-table td:nth-child(4),
            #new-products-table td:nth-child(6),
            #to-clear-table td:nth-child(7),
            #to-clear-table td:nth-child(8),
            #to-clear-table td:nth-child(9),
            #to-clear-table td:nth-child(10),
            #to-clear-table td:nth-child(11),
            #to-clear-table td:nth-child(12),
            #master-table td:nth-child(6) {
                text-align: right; /* Keep right alignment for consistency */
            }


            .modal-content {
                margin: 20px auto; 
                padding: 20px;
                width: 95%; 
            }

            .alert {
                width: calc(100% - 40px); 
                left: 20px;
                right: 20px;
                top: 10px; 
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Inventory Management System</h1>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab(this, 'dashboard')">📊 Dashboard</div>
            <div class="tab" onclick="switchTab(this, 'oos-lowstock')"> OOS/LOW STOCK</div>
            <div class="tab" onclick="switchTab(this, 'new-products')">✨ New Products</div>
            <div class="tab" onclick="switchTab(this, 'to-clear')">🏷️ To Clear</div>
            <div class="tab" onclick="switchTab(this, 'master-list')">📋 Master List</div>
            <div class="tab" onclick="switchTab(this, 'recycle-bin')">🗑️ Recycle Bin</div>
            <div class="tab" onclick="switchTab(this, 'management')">⚙️ Management</div>
        </div>
        
        <div id="dashboard" class="tab-content active">
            <div class="stats-cards">
                <div class="stat-card urgent" onclick="showFilteredInventory('OOS')">
                    <div class="stat-number" id="oos-count">0</div>
                    <div class="stat-label">Out of Stock</div>
                </div>
                <div class="stat-card warning" onclick="showFilteredInventory('Low stock')">
                    <div class="stat-number" id="low-count">0</div>
                    <div class="stat-label">Low Stock</div>
                </div>
                <div class="stat-card info" onclick="switchTab(document.querySelector('.tab[onclick*=\'new-products\']'), 'new-products')">
                    <div class="stat-number" id="new-count">0</div>
                    <div class="stat-label">New Products</div>
                </div>
            </div>
            
            <h3>Recent Alerts</h3>
            <div id="alerts" style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-top: 20px; border: 1px solid #e1e8ed;">
                <p>Loading alerts...</p>
            </div>
        </div>
        
        <div id="oos-lowstock" class="tab-content">
            <div class="controls">
                <button onclick="showAddProductModal()">➕ Add Product</button>
                <input type="text" id="oosSearchInput" class="search-box" placeholder="Search products..." onkeyup="searchInventory(this.value)">
            </div>
            
            <table id="inventory-table-container">
                <thead>
                    <tr>
                        <th onclick="sortTable('inventory', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('inventory', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('inventory', 'product')" data-column-key="product">Product <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('inventory', 'quantity')" data-column-key="quantity">Quantity <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('inventory', 'status')" data-column-key="status">Status <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('inventory', 'shipment')" data-column-key="shipment">Shipment <span class="sort-arrow"></span></th>
                        <th>Remarks</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="inventory-table">
                    </tbody>
            </table>
        </div>
        
        <div id="new-products" class="tab-content">
            <div class="controls">
                <button onclick="showAddNewProductModal()">➕ Add New Product</button>
                <button onclick="mergeNewProductsToMaster()">Merge All to Inventory</button>
                 <input type="text" id="newProductsSearchInput" class="search-box" placeholder="Search new products..." onkeyup="searchNewProducts(this.value)">
            </div>
            
            <table id="new-products-table-container">
                <thead>
                    <tr>
                        <th onclick="sortTable('newProducts', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('newProducts', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('newProducts', 'product')" data-column-key="product">Product <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('newProducts', 'addedDate')" data-column-key="addedDate">Added Date <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('newProducts', 'arrivalDate')" data-column-key="arrivalDate">Arrival Date <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('newProducts', 'quantity')" data-column-key="quantity">Quantity <span class="sort-arrow"></span></th>
                        <th>Notes</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="new-products-table">
                    </tbody>
            </table>
        </div>
        
        <div id="to-clear" class="tab-content">
            <div class="controls">
                <button onclick="showAddToClearModal()">➕ Add Product to Clear</button>
                <input type="text" id="toClearSearchInput" class="search-box" placeholder="Search products to clear..." onkeyup="searchToClear(this.value)">
            </div>
            
            <table id="to-clear-table-container">
                <thead>
                    <tr>
                        <th onclick="sortTable('toClear', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'product')" data-column-key="product">Product <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'category')" data-column-key="category">Category <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'expiryDate')" data-column-key="expiryDate">Expiry Date <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'firstHighlightedDate')" data-column-key="firstHighlightedDate">First Highlighted <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'firstReportedBalance')" data-column-key="firstReportedBalance">Initial Bal <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'warehouseQty')" data-column-key="warehouseQty">WH Qty <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'storeQty')" data-column-key="storeQty">Store Qty <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'totalQty')" data-column-key="totalQty">Total Qty <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'weeklyDemand')" data-column-key="weeklyDemand">Wk Demand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'weeksSupply')" data-column-key="weeksSupply">Wks Supply <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('toClear', 'supplyStatus')" data-column-key="supplyStatus">Supply Status <span class="sort-arrow"></span></th>
                        <th>Action Plan</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="to-clear-table">
                    </tbody>
            </table>
        </div>
        
        <div id="master-list" class="tab-content">
            <div class="controls">
                <button onclick="showAddMasterProductModal()">➕ Add Product</button>
                <input type="text" class="search-box" id="masterListSearchInput" placeholder="Search master products..." onkeyup="searchMasterList(this.value)">
                <button onclick="exportMasterList()">📥 Export List</button>
                <button onclick="document.getElementById('csvFileInput').click()">📤 Import CSV</button>
                <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="importCSV(event)">
            </div>
            
            <table id="master-table-container">
                <thead>
                    <tr>
                        <th onclick="sortTable('master', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('master', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('master', 'product')" data-column-key="product">Product Name <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('master', 'category')" data-column-key="category">Category <span class="sort-arrow"></span></th>
                        <th>Description</th>
                        <th onclick="sortTable('master', 'price')" data-column-key="price">Price <span class="sort-arrow"></span></th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="master-table">
                    </tbody>
            </table>
        </div>

        <div id="recycle-bin" class="tab-content">
            <div class="controls">
                <h3>Recycle Bin</h3>
                <input type="text" id="recycleBinSearchInput" class="search-box" placeholder="Search recycle bin..." onkeyup="searchRecycleBin(this.value)">
                <button class="btn-danger" onclick="emptyRecycleBin()">🗑️ Empty Recycle Bin</button>
            </div>
            <table id="recycle-bin-table-container">
                <thead>
                    <tr>
                        <th onclick="sortTable('recycleBin', 'sku')" data-column-key="sku">Product Code <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('recycleBin', 'originalCollection')" data-column-key="originalCollection">Original Tab <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('recycleBin', 'brand')" data-column-key="brand">Brand <span class="sort-arrow"></span></th>
                        <th onclick="sortTable('recycleBin', 'product')" data-column-key="product">Product <span class="sort-arrow"></span></th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="recycle-bin-table">
                    </tbody>
            </table>
        </div>
        
        <div id="management" class="tab-content">
            <div class="controls">
                <button onclick="exportAllData()">📥 Export All Data</button>
                <button onclick="confirmLoadSampleData()">📊 Load Sample Data</button>
            </div>
            
            <h3>System Information</h3>
            <p>Total Products (active): <span id="total-products">0</span></p>
            <p>Total Products (all unique SKUs): <span id="total-products-all">0</span></p>
            <p>Last Synced: <span id="last-updated">Never</span></p>
        </div>
    </div>

    <div id="productModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('productModal')">&times;</span>
            <h2 id="productModalTitle">Add New Product</h2>
            <form onsubmit="saveProduct(event)">
                <input type="hidden" id="editProductId" value="">
                <div class="form-group">
                    <label for="brand">Brand:</label>
                    <select id="brand" required onchange="filterProductsForBrand(this.value, 'productName', 'productsDatalist')">
                        </select>
                </div>
                <div class="form-group">
                    <label for="productName">Product Name:</label>
                    <input type="text" id="productName" list="productsDatalist" required>
                    <datalist id="productsDatalist"></datalist>
                </div>
                <div class="form-group">
                    <label for="inventoryQuantity">Quantity:</label>
                    <input type="number" id="inventoryQuantity" min="0" required>
                </div>
                <div class="form-group">
                    <label for="status">Status:</label>
                    <select id="status" required>
                        </select>
                </div>
                <div class="form-group">
                    <label for="shipment">Shipment No.:</label>
                    <input type="text" id="shipment">
                </div>
                <div class="form-group">
                    <label for="remarks">Remarks:</label>
                    <textarea id="remarks"></textarea>
                </div>
                <button type="submit">Save Product</button>
            </form>
        </div>
    </div>

    <div id="newProductModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('newProductModal')">&times;</span>
            <h2 id="newProductModalTitle">Add New Product Entry</h2>
            <form onsubmit="saveNewProduct(event)">
                <input type="hidden" id="editNewProductId" value="">
                <div class="form-group">
                    <label for="newBrand">Brand:</label>
                    <select id="newBrand" required onchange="filterProductsForBrand(this.value, 'newProductName', 'newProductsDatalist')">
                        </select>
                </div>
                <div class="form-group">
                    <label for="newProductSku">Product Code (SKU):</label>
                    <input type="text" id="newProductSku" required>
                </div>
                <div class="form-group">
                    <label for="newProductName">Product Name:</label>
                    <input type="text" id="newProductName" list="newProductsDatalist" required>
                    <datalist id="newProductsDatalist"></datalist>
                </div>
                <div class="form-group">
                    <label for="arrivalDate">Arrival Date:</label>
                    <input type="date" id="arrivalDate" required>
                </div>
                <div class="form-group">
                    <label for="newProductQuantity">Quantity:</label> <input type="number" id="newProductQuantity" min="0" required>
                </div>
                <div class="form-group">
                    <label for="notes">Notes:</label>
                    <textarea id="notes"></textarea>
                </div>
                <button type="submit">Save New Product</button>
            </form>
        </div>
    </div>

    <div id="masterProductModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('masterProductModal')">&times;</span>
            <h2 id="masterProductModalTitle">Add Master Product</h2>
            <form onsubmit="saveMasterProduct(event)">
                <input type="hidden" id="editMasterProductId" value="">
                <div class="form-group">
                    <label for="masterBrand">Brand:</label>
                    <select id="masterBrand" required>
                        </select>
                </div>
                <div class="form-group">
                    <label for="masterProductName">Product Name:</label>
                    <input type="text" id="masterProductName" required>
                </div>
                <div class="form-group">
                    <label for="category">Category:</label>
                    <select id="category" required>
                        </select>
                </div>
                <div class="form-group">
                    <label for="description">Description:</label>
                    <textarea id="description"></textarea>
                </div>
                <div class="form-group">
                    <label for="sku">Product Code (SKU):</label>
                    <input type="text" id="sku">
                </div>
                <div class="form-group">
                    <label for="price">Price:</label>
                    <input type="number" id="price" step="0.01" min="0">
                </div>
                <button type="submit">Save Master Product</button>
            </form>
        </div>
    </div>

    <div id="toClearModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('toClearModal')">&times;</span>
            <h2 id="toClearModalTitle">Add Product to Clear</h2>
            <form onsubmit="saveToClear(event)">
                <input type="hidden" id="editToClearId" value="">
                <div class="form-group">
                    <label for="toClearBrand">Brand:</label>
                    <select id="toClearBrand" required onchange="filterProductsForBrand(this.value, 'toClearProductName', 'toClearProductsDatalist')">
                        </select>
                </div>
                <div class="form-group">
                    <label for="toClearProductName">Product Name:</label>
                    <input type="text" id="toClearProductName" list="toClearProductsDatalist" required>
                    <datalist id="toClearProductsDatalist"></datalist>
                </div>
                <div class="form-group">
                    <label for="toClearCategory">Category:</label>
                    <select id="toClearCategory" required>
                        </select>
                </div>
                <div class="form-group">
                    <label for="toClearExpiryDate">Expiry Date:</label>
                    <input type="date" id="toClearExpiryDate" required>
                </div>
                <div class="form-group">
                    <label for="toClearFirstHighlightedDate">First Highlighted Date:</label>
                    <input type="date" id="toClearFirstHighlightedDate" required readonly>
                </div>
                <div class="form-group">
                    <label for="toClearFirstReportedBalance">First Reported Balance (Total Qty):</label>
                    <input type="number" id="toClearFirstReportedBalance" min="0">
                </div>
                <div class="form-group">
                    <label for="toClearWarehouseQty">Warehouse Qty:</label>
                    <input type="number" id="toClearWarehouseQty" min="0">
                </div>
                <div class="form-group">
                    <label for="toClearStoreQty">Store Qty:</label>
                    <input type="number" id="toClearStoreQty" min="0">
                </div>
                <div class="form-group">
                    <label for="toClearWeeklyDemand">Weekly Demand:</label>
                    <input type="number" id="toClearWeeklyDemand" min="0">
                </div>
                <div class="form-group">
                    <label for="toClearActionPlan">Action Plan:</label>
                    <textarea id="toClearActionPlan"></textarea>
                </div>
                <button type="submit">Save Product to Clear</button>
            </form>
        </div>
    </div>

    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <h2>Confirmation</h2>
            <p id="confirmMessage"></p>
            <div class="modal-buttons">
                <button class="btn-danger" id="confirmNo">No</button>
                <button class="btn-success" id="confirmYes">Yes</button>
            </div>
        </div>
    </div>

    <div id="addBrandModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addBrandModal')">&times;</span>
            <h2>Add New Brand</h2>
            <form onsubmit="saveNewBrand(event)">
                <div class="form-group">
                    <label for="newBrandName">Brand Name:</label>
                    <input type="text" id="newBrandName" required>
                </div>
                <button type="submit">Add Brand</button>
            </form>
        </div>
    </div>

    <div id="addStatusModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addStatusModal')">&times;</span>
            <h2>Add New Status</h2>
            <form onsubmit="saveNewStatus(event)">
                <div class="form-group">
                    <label for="newStatusName">Status Name:</label>
                    <input type="text" id="newStatusName" required>
                </div>
                <button type="submit">Add Status</button>
            </form>
        </div>
    </div>

    <div id="addCategoryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addCategory')">&times;</span>
            <h2>Add New Category</h2>
            <form onsubmit="saveNewCategory(event)">
                <div class="form-group">
                    <label for="newCategoryName">Category Name:</label>
                    <input type="text" id="newCategoryName" required>
                </div>
                <button type="submit">Add Category</button>
            </form>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    <script>
        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDo1-y0Vj4XTQeeEUQK_6Y2wqDs94TOAX0", // Replace with your actual API key
            authDomain: "inventory-c3bac.firebaseapp.com",
            projectId: "inventory-c3bac",
            storageBucket: "inventory-c3bac.appspot.com", // Corrected storage bucket
            messagingSenderId: "261015083855",
            appId: "1:261015083855:web:e167f359928eb8ed8cc33a",
            measurementId: "G-V744486L78"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // Global data arrays to hold fetched data
        let inventoryData = [];
        let newProductsData = [];
        let toClearData = [];
        let masterProductsData = [];
        let deletedItemsData = []; // For Recycle Bin
        let brandsData = []; 
        let statusesData = []; 
        let categoriesData = []; 

        // Data for current views (used for filtering and sorting)
        let currentInventoryViewData = [];
        let currentNewProductsViewData = [];
        let currentToClearViewData = [];
        let currentMasterListViewData = [];
        let currentRecycleBinViewData = [];

        // Firestore collection references
        const inventoryColRef = db.collection('inventory');
        const newProductsColRef = db.collection('new_products');
        const toClearColRef = db.collection('to_clear');
        const masterProductsColRef = db.collection('master_products');
        const brandsColRef = db.collection('brands');
        const statusesColRef = db.collection('statuses');
        const categoriesColRef = db.collection('categories');

        // Sort state for tables
        let sortState = {
            inventory: { column: null, direction: 'asc' },
            newProducts: { column: null, direction: 'asc' },
            master: { column: null, direction: 'asc' },
            toClear: { column: null, direction: 'asc' },
            recycleBin: { column: null, direction: 'asc' }
        };

        // --- Notification System ---
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.classList.add('alert', `alert-${type}`);
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // --- Confirmation Modal ---
        let confirmCallback = null;
        function showConfirmModal(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').style.display = 'block';
            confirmCallback = callback;
        }

        document.getElementById('confirmYes').onclick = () => {
            if (confirmCallback) {
                confirmCallback(true);
            }
            document.getElementById('confirmModal').style.display = 'none';
        };

        document.getElementById('confirmNo').onclick = () => {
            if (confirmCallback) {
                confirmCallback(false);
            }
            document.getElementById('confirmModal').style.display = 'none';
        };


        // --- Firestore Data Operations ---
        async function fetchDataFromFirestore(collectionRef, includeDeleted = false) {
            let data = [];
            let query = collectionRef;
            // For main data collections, filter by isDeleted unless includeDeleted is true
            if (!includeDeleted && 
                (collectionRef.id === 'inventory' || 
                 collectionRef.id === 'new_products' || 
                 collectionRef.id === 'to_clear' || 
                 collectionRef.id === 'master_products')) {
                query = collectionRef.where("isDeleted", "==", false);
            }
            // For auxiliary collections like brands, statuses, categories, assume they might not all have `isDeleted`
            // or we fetch all and filter client-side if necessary, based on `isDeleted: false` being standard.
            // The client-side filter in `updateLocalData` will handle ensuring only non-deleted are used.


            try {
                const querySnapshot = await query.get();
                querySnapshot.forEach((doc) => {
                    data.push({ id: doc.id, ...doc.data() });
                });
            } catch (error) {
                console.error(`Error fetching data from ${collectionRef.id}:`, error);
                if (error.code === 'failed-precondition' && !includeDeleted) {
                    console.warn(`Firestore query for ${collectionRef.id} might require an index. Check Firestore console. Query details: where("isDeleted", "==", false)`);
                } else if (error.code === 'failed-precondition') {
                     console.warn(`Firestore query for ${collectionRef.id} might require an index. Check Firestore console.`);
                }
                // Avoid showing notification if it's just a missing index warning during initial setup for auxiliary collections
                if (!( (collectionRef.id === 'brands' || collectionRef.id === 'statuses' || collectionRef.id === 'categories') && error.code === 'failed-precondition' ) ) {
                   // showNotification(`Error loading data from ${collectionRef.id}. Check console.`, 'error');
                }
            }
            return data;
        }

        async function fetchAllDataForRecycleBin() {
            const collectionsToFetchFrom = [inventoryColRef, newProductsColRef, toClearColRef, masterProductsColRef];
            let allDeletedItems = [];
            for (const colRef of collectionsToFetchFrom) {
                try {
                    const querySnapshot = await colRef.where("isDeleted", "==", true).get();
                    querySnapshot.forEach((doc) => {
                        allDeletedItems.push({ id: doc.id, ...doc.data(), originalCollection: colRef.id });
                    });
                } catch (error) {
                    console.error(`Error fetching deleted items from ${colRef.id}:`, error);
                    if (error.code === 'failed-precondition') {
                        console.warn(`Firestore query for deleted items in ${colRef.id} might require an index for 'isDeleted'. Check Firestore console.`);
                    }
                }
            }
            return allDeletedItems;
        }

        async function saveDataToFirestore(collectionRef, docId, data) {
            try {
                if (docId) {
                    await collectionRef.doc(docId).update(data);
                } else {
                    const docRef = await collectionRef.add(data);
                    return docRef.id;
                }
                return docId;
            } catch (error) {
                console.error(`Error saving data to ${collectionRef.id}:`, error);
                showNotification(`Error saving data to server for ${collectionRef.id}.`, 'error');
                throw error;
            }
        }

        // --- Update Local Data & UI ---
        async function updateLocalData() {
            try {
                inventoryData = await fetchDataFromFirestore(inventoryColRef);
                newProductsData = await fetchDataFromFirestore(newProductsColRef);
                toClearData = await fetchDataFromFirestore(toClearColRef);
                masterProductsData = await fetchDataFromFirestore(masterProductsColRef);
                deletedItemsData = await fetchAllDataForRecycleBin();

                // Fetch all brands, statuses, categories, then filter client-side for non-deleted.
                // This assumes `isDeleted: false` is consistently set when these items are added.
                const rawBrands = await fetchDataFromFirestore(brandsColRef, true);
                brandsData = rawBrands.filter(b => b.isDeleted === false || typeof b.isDeleted === 'undefined');

                const rawStatuses = await fetchDataFromFirestore(statusesColRef, true);
                statusesData = rawStatuses.filter(s => s.isDeleted === false || typeof s.isDeleted === 'undefined');
                
                const rawCategories = await fetchDataFromFirestore(categoriesColRef, true);
                categoriesData = rawCategories.filter(c => c.isDeleted === false || typeof c.isDeleted === 'undefined');


                currentInventoryViewData = inventoryData.filter(item =>
                    !item.isDeleted && (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))
                );
                currentNewProductsViewData = newProductsData.filter(item => !item.isDeleted);
                currentToClearViewData = toClearData.filter(item => !item.isDeleted);
                currentMasterListViewData = masterProductsData.filter(item => !item.isDeleted);
                currentRecycleBinViewData = [...deletedItemsData];


                updateAllTablesAndViews();
                updateDashboardStats();
                updateAlerts();
                updateManagementStats();
                populateProductDatalists();
                setupDynamicDropdowns();
            } catch (error) {
                console.error("Error updating local data from Firestore:", error);
                showNotification('Error loading data from server. Please check your internet connection or Firebase setup.', 'error');
            }
        }


        function updateAllTablesAndViews() {
            renderInventoryItems();
            renderNewProductsItems();
            renderMasterListItems();
            renderToClearItems();
            renderRecycleBinItems();
        }

        // --- Dynamic Dropdowns ---
        function setupDynamicDropdowns() {
            populateBrandDropdowns('brand');
            populateBrandDropdowns('newBrand');
            populateBrandDropdowns('masterBrand');
            populateBrandDropdowns('toClearBrand');
            populateStatusDropdowns('status');
            populateCategoryDropdowns('category');
            populateCategoryDropdowns('toClearCategory');
        }

        function populateBrandDropdowns(selectId) {
            const selectElement = document.getElementById(selectId);
            if (!selectElement) return;

            const currentValue = selectElement.value; // Store current value before clearing
            selectElement.innerHTML = '<option value="">Select Brand</option>';

            const uniqueBrandsFromMaster = [...new Set(masterProductsData.filter(item => !item.isDeleted).map(item => item.brand).filter(Boolean))];
            let allUniqueBrands = [...uniqueBrandsFromMaster];
            
            // Use pre-filtered brandsData (non-deleted items)
            brandsData.forEach(brandDoc => {
                if (brandDoc.name && !allUniqueBrands.includes(brandDoc.name)) {
                    allUniqueBrands.push(brandDoc.name);
                }
            });
            allUniqueBrands.sort((a, b) => a.localeCompare(b));

            allUniqueBrands.forEach(brand => {
                const option = document.createElement('option');
                option.value = brand;
                option.textContent = brand;
                selectElement.appendChild(option);
            });

            const addNewOption = document.createElement('option');
            addNewOption.value = 'add_new_brand';
            addNewOption.textContent = '+ Add New Brand...';
            selectElement.appendChild(addNewOption);
            
            // Try to restore previous valid selection
            if (currentValue && allUniqueBrands.includes(currentValue)) {
                selectElement.value = currentValue;
            } else if (currentValue === 'add_new_brand') {
                selectElement.value = ''; // Reset if "Add New" was selected and modal closed
            }


            selectElement.removeEventListener('change', handleDynamicDropdownChange); 
            selectElement.addEventListener('change', handleDynamicDropdownChange);
        }

        function populateStatusDropdowns(selectId) {
            const selectElement = document.getElementById(selectId);
            if (!selectElement) return;

            const currentValue = selectElement.value;
            selectElement.innerHTML = '<option value="">Select Status</option>';

            const uniqueStatusesFromInventory = [...new Set(inventoryData.filter(item => !item.isDeleted).map(item => item.status).filter(Boolean))];
            let allUniqueStatuses = [...uniqueStatusesFromInventory];
            statusesData.forEach(statusDoc => { 
                if (statusDoc.name && !allUniqueStatuses.includes(statusDoc.name)) {
                    allUniqueStatuses.push(statusDoc.name);
                }
            });
            allUniqueStatuses.sort((a, b) => a.localeCompare(b));

            allUniqueStatuses.forEach(status => {
                const option = document.createElement('option');
                option.value = status;
                option.textContent = status;
                selectElement.appendChild(option);
            });

            const addNewOption = document.createElement('option');
            addNewOption.value = 'add_new_status';
            addNewOption.textContent = '+ Add New Status...';
            selectElement.appendChild(addNewOption);

            if (currentValue && allUniqueStatuses.includes(currentValue)) {
                selectElement.value = currentValue;
            }  else if (currentValue === 'add_new_status') {
                selectElement.value = ''; 
            }
            selectElement.removeEventListener('change', handleDynamicDropdownChange);
            selectElement.addEventListener('change', handleDynamicDropdownChange);
        }

        function populateCategoryDropdowns(selectId) {
            const selectElement = document.getElementById(selectId);
            if (!selectElement) return;

            const currentValue = selectElement.value;
            selectElement.innerHTML = '<option value="">Select Category</option>';

            const uniqueCategoriesFromMaster = [...new Set(masterProductsData.filter(item => !item.isDeleted).map(item => item.category).filter(Boolean))];
            let allUniqueCategories = [...uniqueCategoriesFromMaster];
            categoriesData.forEach(categoryDoc => { 
                if (categoryDoc.name && !allUniqueCategories.includes(categoryDoc.name)) {
                    allUniqueCategories.push(categoryDoc.name);
                }
            });
            allUniqueCategories.sort((a, b) => a.localeCompare(b));

            allUniqueCategories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                selectElement.appendChild(option);
            });

            const addNewOption = document.createElement('option');
            addNewOption.value = 'add_new_category';
            addNewOption.textContent = '+ Add New Category...';
            selectElement.appendChild(addNewOption);

            if (currentValue && allUniqueCategories.includes(currentValue)) {
                selectElement.value = currentValue;
            } else if (currentValue === 'add_new_category') {
                selectElement.value = ''; 
            }
            selectElement.removeEventListener('change', handleDynamicDropdownChange);
            selectElement.addEventListener('change', handleDynamicDropdownChange);
        }


        function handleDynamicDropdownChange(event) {
            const selectElement = event.target;
            const selectedOptionValue = selectElement.value;
            
            // Store the previous valid value, not "add_new_..."
            let previousValue = "";
            for(let i=0; i < selectElement.options.length; i++){
                if(selectElement.options[i].value !== 'add_new_brand' && 
                   selectElement.options[i].value !== 'add_new_status' &&
                   selectElement.options[i].value !== 'add_new_category' &&
                   selectElement.options[i].selected && selectElement.options[i].value !== selectedOptionValue) { // This logic is a bit off
                    // A simpler way: when "Add New" is chosen, just open modal. After modal, updateLocalData refreshes everything.
                }
            }


            if (selectedOptionValue === 'add_new_brand') {
                showAddBrandModal();
                // selectElement.value = previousValue; // Attempt to reset, but updateLocalData will handle better
            } else if (selectedOptionValue === 'add_new_status') {
                showAddStatusModal();
                // selectElement.value = previousValue;
            } else if (selectedOptionValue === 'add_new_category') {
                showAddCategoryModal();
                // selectElement.value = previousValue;
            }
        }

        // --- Product Datalists (for autocomplete) ---
        function populateProductDatalists() {
            const productsDatalist = document.getElementById('productsDatalist');
            const newProductsDatalist = document.getElementById('newProductsDatalist');
            const toClearProductsDatalist = document.getElementById('toClearProductsDatalist');

            if (productsDatalist) productsDatalist.innerHTML = '';
            if (newProductsDatalist) newProductsDatalist.innerHTML = '';
            if (toClearProductsDatalist) toClearProductsDatalist.innerHTML = '';

            const allProductNames = [...new Set(masterProductsData.filter(item => !item.isDeleted).map(item => item.product).filter(Boolean))].sort();

            allProductNames.forEach(productName => {
                const option1 = document.createElement('option');
                option1.value = productName;
                if (productsDatalist) productsDatalist.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = productName;
                if (newProductsDatalist) newProductsDatalist.appendChild(option2);

                const option3 = document.createElement('option');
                option3.value = productName;
                if (toClearProductsDatalist) toClearProductsDatalist.appendChild(option3);
            });
        }

        function filterProductsForBrand(brand, productNameInputId, datalistId) {
            const productNameInput = document.getElementById(productNameInputId);
            const datalist = document.getElementById(datalistId);
            if (!productNameInput || !datalist) return;

            datalist.innerHTML = '';
            const filteredProducts = masterProductsData.filter(item => !item.isDeleted && item.brand === brand);
            const uniqueProductNames = [...new Set(filteredProducts.map(item => item.product).filter(Boolean))].sort();

            uniqueProductNames.forEach(productName => {
                const option = document.createElement('option');
                option.value = productName;
                datalist.appendChild(option);
            });

            if (productNameInput.value && !uniqueProductNames.includes(productNameInput.value)) {
                productNameInput.value = '';
            }
        }

        // --- Tab Switching ---
        function switchTab(clickedTab, tabId) {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            clickedTab.classList.add('active');

            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');

            if (tabId === 'oos-lowstock') {
                currentInventoryViewData = inventoryData.filter(item =>
                    !item.isDeleted && (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))
                );
                if(document.getElementById('oosSearchInput')) document.getElementById('oosSearchInput').value = '';
                renderInventoryItems();
            } else if (tabId === 'new-products') {
                currentNewProductsViewData = newProductsData.filter(item => !item.isDeleted);
                if(document.getElementById('newProductsSearchInput')) document.getElementById('newProductsSearchInput').value = '';
                renderNewProductsItems();
            } else if (tabId === 'to-clear') {
                currentToClearViewData = toClearData.filter(item => !item.isDeleted);
                if(document.getElementById('toClearSearchInput')) document.getElementById('toClearSearchInput').value = '';
                renderToClearItems();
            } else if (tabId === 'master-list') {
                currentMasterListViewData = masterProductsData.filter(item => !item.isDeleted);
                if(document.getElementById('masterListSearchInput')) document.getElementById('masterListSearchInput').value = '';
                renderMasterListItems();
            } else if (tabId === 'recycle-bin') {
                currentRecycleBinViewData = [...deletedItemsData];
                if(document.getElementById('recycleBinSearchInput')) document.getElementById('recycleBinSearchInput').value = '';
                renderRecycleBinItems();
            }
        }

        // --- Modals ---
        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                 modal.style.display = 'none';
                const form = modal.querySelector('form');
                if (form) {
                    form.reset();
                     // After form reset, if there are select elements that were dynamically populated,
                    // ensure their datalists for product names are cleared if they depend on a brand.
                    if (modalId === 'productModal') filterProductsForBrand('', 'productName', 'productsDatalist');
                    if (modalId === 'newProductModal') filterProductsForBrand('', 'newProductName', 'newProductsDatalist');
                    if (modalId === 'toClearModal') filterProductsForBrand('', 'toClearProductName', 'toClearProductsDatalist');
                }
                if (modalId === 'productModal') document.getElementById('editProductId').value = '';
                else if (modalId === 'newProductModal') document.getElementById('editNewProductId').value = '';
                else if (modalId === 'masterProductModal') document.getElementById('editMasterProductId').value = '';
                else if (modalId === 'toClearModal') document.getElementById('editToClearId').value = '';
            }
        }
        
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target == modal) {
                    closeModal(modal.id);
                }
            });
        }


        // --- CRUD Operations & Rendering ---

        // Inventory (OOS/Low Stock)
        function renderInventoryItems() {
            const tableBody = document.getElementById('inventory-table');
            if (!tableBody) return;
            tableBody.innerHTML = '';
            const sortedData = sortArray(currentInventoryViewData, sortState.inventory.column, sortState.inventory.direction);

            sortedData.forEach(item => {
                const row = tableBody.insertRow();
                row.insertCell().textContent = item.sku || '';
                row.insertCell().textContent = item.brand || '';
                row.insertCell().textContent = item.product || '';
                row.insertCell().textContent = item.quantity !== undefined ? item.quantity : '';
                const statusCell = row.insertCell();
                const badgeClass = item.status === 'OOS' ? 'oos' : 'low';
                statusCell.innerHTML = `<span class="status-badge ${badgeClass}">${item.status || ''}</span>`;
                row.insertCell().textContent = item.shipment || '';
                row.insertCell().textContent = item.remarks || '';

                const actionsCell = row.insertCell();
                actionsCell.innerHTML = `
                    <button class="btn-info" onclick="editProduct('${item.id}')">✏️ Edit</button>
                    <button class="btn-danger" onclick="moveToRecycleBin('${item.id}', 'inventory')">🗑️ Delete</button>
                `;
            });
        }

        function showAddProductModal() {
            document.getElementById('productModalTitle').textContent = 'Add New Product';
            document.getElementById('editProductId').value = '';
            document.getElementById('productModal').querySelector('form').reset();
            populateBrandDropdowns('brand');
            populateStatusDropdowns('status');
            filterProductsForBrand('', 'productName', 'productsDatalist'); 
            openModal('productModal');
        }

        async function saveProduct(event) {
            event.preventDefault();
            const id = document.getElementById('editProductId').value;
            const brand = document.getElementById('brand').value;
            const productName = document.getElementById('productName').value;
            let sku = getSkuForProduct(brand, productName); // Attempt to get existing SKU

            const data = {
                brand: brand,
                product: productName,
                quantity: parseInt(document.getElementById('inventoryQuantity').value),
                status: document.getElementById('status').value,
                shipment: document.getElementById('shipment').value,
                remarks: document.getElementById('remarks').value,
                isDeleted: false 
            };
            // If SKU couldn't be found (e.g. product not in master), and this is a new item,
            // it might be better to enforce adding to master first or handle SKU generation carefully.
            // For now, if no ID (new item) and no SKU, it will be blank.
            if (sku) data.sku = sku;
            else if (!id) { // If new product and no SKU from master, create a placeholder or require SKU
                // For now, let's assume an SKU should ideally come from selecting a master product.
                // If it's a truly new product, it should perhaps go via "New Products" or "Master List" flow first.
                // showNotification("Product not found in Master List. Please add to Master List first or ensure Brand/Product Name match.", "error");
                // return; 
                // Or assign a temporary SKU, though this isn't ideal for real inventory
                 data.sku = `TEMP_SKU_${Date.now()}`; // This is generally not good practice for real inventory
            }


            try {
                await saveDataToFirestore(inventoryColRef, id, data);
                showNotification('Product saved successfully!', 'success');
                closeModal('productModal');
                await updateLocalData(); 
            } catch (e) {
                // Error handled
            }
        }

        async function editProduct(id) {
            const item = inventoryData.find(p => p.id === id);
            if (item) {
                document.getElementById('productModalTitle').textContent = 'Edit Product';
                document.getElementById('editProductId').value = item.id;
                populateBrandDropdowns('brand'); 
                document.getElementById('brand').value = item.brand;
                filterProductsForBrand(item.brand, 'productName', 'productsDatalist'); 
                document.getElementById('productName').value = item.product;
                document.getElementById('inventoryQuantity').value = item.quantity;
                populateStatusDropdowns('status'); 
                document.getElementById('status').value = item.status;
                document.getElementById('shipment').value = item.shipment;
                document.getElementById('remarks').value = item.remarks;
                openModal('productModal');
            }
        }

        function showFilteredInventory(statusFilter) {
            currentInventoryViewData = inventoryData.filter(item =>
                !item.isDeleted && item.status && item.status.toLowerCase().includes(statusFilter.toLowerCase())
            );
            renderInventoryItems();
            const oosLowStockTab = document.querySelector('.tab[onclick*=\'oos-lowstock\']');
            if (oosLowStockTab) {
                switchTab(oosLowStockTab, 'oos-lowstock');
            }
        }

        function searchInventory(searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
            
            let baseFilteredData = inventoryData.filter(item =>
                !item.isDeleted && (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))
            );

            if (lowerCaseSearchTerm) {
                currentInventoryViewData = baseFilteredData.filter(item =>
                    (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.status && item.status.toLowerCase().includes(lowerCaseSearchTerm))
                );
            } else {
                currentInventoryViewData = baseFilteredData;
            }
            renderInventoryItems();
        }


        // New Products
        function renderNewProductsItems() {
            const tableBody = document.getElementById('new-products-table');
            if (!tableBody) return;
            tableBody.innerHTML = '';

            const sortedData = sortArray(currentNewProductsViewData, sortState.newProducts.column, sortState.newProducts.direction);

            sortedData.forEach(item => {
                const row = tableBody.insertRow();
                row.insertCell().textContent = item.sku || '';
                row.insertCell().textContent = item.brand || '';
                row.insertCell().textContent = item.product || '';
                row.insertCell().textContent = item.addedDate || '';
                row.insertCell().textContent = item.arrivalDate || '';
                row.insertCell().textContent = item.quantity !== undefined ? item.quantity : '';
                row.insertCell().textContent = item.notes || '';

                const actionsCell = row.insertCell();
                actionsCell.innerHTML = `
                    <button class="btn-info" onclick="editNewProduct('${item.id}')">✏️ Edit</button>
                    <button class="btn-success" onclick="moveNewProductToMaster('${item.id}')">✅ Approve</button>
                    <button class="btn-danger" onclick="moveToRecycleBin('${item.id}', 'new_products')">🗑️ Delete</button>
                `;
            });
        }

        function showAddNewProductModal() {
            document.getElementById('newProductModalTitle').textContent = 'Add New Product Entry';
            document.getElementById('editNewProductId').value = '';
            document.getElementById('newProductModal').querySelector('form').reset();
            document.getElementById('arrivalDate').valueAsDate = new Date();
            populateBrandDropdowns('newBrand');
            filterProductsForBrand('', 'newProductName', 'newProductsDatalist');
            openModal('newProductModal');
        }

        async function saveNewProduct(event) {
            event.preventDefault();
            const id = document.getElementById('editNewProductId').value;
            const skuValue = document.getElementById('newProductSku').value.trim();

            if (!skuValue) {
                showNotification('Product Code (SKU) is required for new products.', 'error');
                return;
            }
            // Check for SKU uniqueness in new_products and master_products if it's a new item
            if (!id) { // Only for new items
                const skuExistsInNew = newProductsData.some(p => p.sku === skuValue && !p.isDeleted);
                const skuExistsInMaster = masterProductsData.some(p => p.sku === skuValue && !p.isDeleted);
                if (skuExistsInNew || skuExistsInMaster) {
                    showNotification('This SKU already exists. Please use a unique SKU.', 'error');
                    return;
                }
            }


            const data = {
                brand: document.getElementById('newBrand').value,
                sku: skuValue,
                product: document.getElementById('newProductName').value,
                arrivalDate: document.getElementById('arrivalDate').value,
                quantity: parseInt(document.getElementById('newProductQuantity').value),
                notes: document.getElementById('notes').value,
                addedDate: id ? (newProductsData.find(item => item.id === id)?.addedDate || new Date().toISOString().split('T')[0]) : new Date().toISOString().split('T')[0],
                isDeleted: false
            };

            try {
                await saveDataToFirestore(newProductsColRef, id, data);
                showNotification('New product entry saved successfully!', 'success');
                closeModal('newProductModal');
                await updateLocalData();
            } catch (e) {
                //error handled
            }
        }

        async function editNewProduct(id) {
            const item = newProductsData.find(p => p.id === id);
            if (item) {
                document.getElementById('newProductModalTitle').textContent = 'Edit New Product Entry';
                document.getElementById('editNewProductId').value = item.id;
                populateBrandDropdowns('newBrand');
                document.getElementById('newBrand').value = item.brand;
                filterProductsForBrand(item.brand, 'newProductName', 'newProductsDatalist');
                document.getElementById('newProductSku').value = item.sku || '';
                document.getElementById('newProductName').value = item.product;
                document.getElementById('arrivalDate').value = item.arrivalDate;
                document.getElementById('newProductQuantity').value = item.quantity;
                document.getElementById('notes').value = item.notes;
                openModal('newProductModal');
            }
        }

        async function moveNewProductToMaster(id) {
            showConfirmModal('Are you sure you want to approve this new product and move it to Master List & Inventory?', async (confirmed) => {
                if (confirmed) {
                    const item = newProductsData.find(p => p.id === id);
                    if (item) {
                        try {
                            // Check if SKU already exists in Master List (non-deleted)
                            const masterProductExists = masterProductsData.find(mp => mp.sku === item.sku && !mp.isDeleted);
                            if (masterProductExists) {
                                showNotification(`SKU ${item.sku} already exists in Master List. Cannot move. Please edit SKU or manage in Master List.`, 'error');
                                return;
                            }

                            const masterProductData = {
                                brand: item.brand,
                                product: item.product,
                                sku: item.sku,
                                category: 'Uncategorized', // Default for new
                                description: item.notes || '',
                                price: 0.00, // Default
                                isDeleted: false
                            };
                            await saveDataToFirestore(masterProductsColRef, null, masterProductData); // Add as new to master

                            const inventoryProductData = {
                                brand: item.brand,
                                product: item.product,
                                sku: item.sku,
                                quantity: item.quantity,
                                status: 'In stock', // Default status
                                shipment: '',
                                remarks: `Added from New Products (Approved: ${new Date().toISOString().split('T')[0]})`,
                                isDeleted: false,
                                expiry: '' 
                            };
                            await saveDataToFirestore(inventoryColRef, null, inventoryProductData);

                            await saveDataToFirestore(newProductsColRef, item.id, { isDeleted: true }); // Mark as deleted in New Products

                            showNotification('Product approved and moved successfully!', 'success');
                            await updateLocalData();
                        } catch (e) {
                            console.error("Error moving new product to master:", e);
                            showNotification('Error moving product.', 'error');
                        }
                    }
                }
            });
        }
        
        async function mergeNewProductsToMaster() {
            showConfirmModal('Are you sure you want to merge ALL new products to Master List & Inventory? This will mark them as approved. SKUs already in Master List will be skipped.', async (confirmed) => {
                if (confirmed) {
                    const batch = db.batch();
                    let successCount = 0;
                    let skippedCount = 0;
                    const activeNewProducts = newProductsData.filter(item => !item.isDeleted);

                    if (activeNewProducts.length === 0) {
                        showNotification('No new products to merge.', 'info');
                        return;
                    }

                    for (const item of activeNewProducts) {
                        // Check if SKU already exists in Master List (non-deleted)
                        const masterProductExists = masterProductsData.find(mp => mp.sku === item.sku && !mp.isDeleted);
                        if (masterProductExists) {
                            skippedCount++;
                            console.warn(`Skipping SKU ${item.sku} as it already exists in Master List.`);
                            // Optionally, still mark as deleted from new_products if desired
                            // const newProductRef = newProductsColRef.doc(item.id);
                            // batch.update(newProductRef, { isDeleted: true });
                            continue; // Skip this item for adding to master/inventory
                        }
                        
                        try {
                            const masterProductRef = masterProductsColRef.doc(); 
                            const masterProductData = {
                                brand: item.brand, product: item.product, sku: item.sku,
                                category: 'Uncategorized', description: item.notes || '', price: 0.00, isDeleted: false
                            };
                            batch.set(masterProductRef, masterProductData);

                            const inventoryProductRef = inventoryColRef.doc(); 
                            const inventoryProductData = {
                                brand: item.brand, product: item.product, sku: item.sku,
                                quantity: item.quantity, status: 'In stock', shipment: '',
                                remarks: `Added from New Products (Batch Merge: ${new Date().toISOString().split('T')[0]})`,
                                isDeleted: false, expiry: ''
                            };
                            batch.set(inventoryProductRef, inventoryProductData);

                            const newProductRef = newProductsColRef.doc(item.id);
                            batch.update(newProductRef, { isDeleted: true });
                            successCount++;
                        } catch (e) {
                            console.error(`Error processing new product ${item.id || item.sku} for merge:`, e);
                        }
                    }

                    if (successCount > 0 || skippedCount > 0) {
                        try {
                            await batch.commit();
                            let message = "";
                            if (successCount > 0) message += `Successfully merged ${successCount} new products. `;
                            if (skippedCount > 0) message += `${skippedCount} products were skipped as their SKUs already exist in Master List.`;
                            showNotification(message.trim(), successCount > 0 ? 'success' : 'info');
                            await updateLocalData();
                        } catch (e) {
                            console.error("Batch commit failed:", e);
                            showNotification('Error committing batch merge.', 'error');
                        }
                    } else if (activeNewProducts.length > 0) { 
                         showNotification('Failed to merge new products. Check console.', 'error');
                    } else {
                        showNotification('No new products were eligible for merging.', 'info');
                    }
                }
            });
        }


        function searchNewProducts(searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
            const baseData = newProductsData.filter(item => !item.isDeleted);
            if (lowerCaseSearchTerm) {
                currentNewProductsViewData = baseData.filter(item =>
                    (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm))
                );
            } else {
                currentNewProductsViewData = baseData;
            }
            renderNewProductsItems();
        }

        // To Clear
        function renderToClearItems() {
            const tableBody = document.getElementById('to-clear-table');
            if (!tableBody) return;
            tableBody.innerHTML = '';

            const sortedData = sortArray(currentToClearViewData, sortState.toClear.column, sortState.toClear.direction);

            sortedData.forEach(item => {
                const row = tableBody.insertRow();
                row.insertCell().textContent = item.sku || '';
                row.insertCell().textContent = item.brand || '';
                row.insertCell().textContent = item.product || '';
                row.insertCell().textContent = item.category || '';
                row.insertCell().textContent = item.expiryDate || '';
                row.insertCell().textContent = item.firstHighlightedDate || '';
                row.insertCell().textContent = item.firstReportedBalance !== undefined ? item.firstReportedBalance : '';
                row.insertCell().textContent = item.warehouseQty !== undefined ? item.warehouseQty : '';
                row.insertCell().textContent = item.storeQty !== undefined ? item.storeQty : '';
                const totalQty = (Number(item.warehouseQty) || 0) + (Number(item.storeQty) || 0);
                row.insertCell().textContent = totalQty;
                row.insertCell().textContent = item.weeklyDemand !== undefined ? item.weeklyDemand : '';
                const weeksSupply = (Number(item.weeklyDemand) || 0) > 0 ? (totalQty / Number(item.weeklyDemand)).toFixed(2) : 'N/A';
                row.insertCell().textContent = weeksSupply;
                // Updated to pass the full item object for new supply status logic
                const supplyStatusClass = getSupplyStatusClass(item);
                row.insertCell().innerHTML = `<span class="status-badge ${supplyStatusClass}">${getSupplyStatusText(item)}</span>`;
                row.insertCell().textContent = item.actionPlan || '';

                const actionsCell = row.insertCell();
                actionsCell.innerHTML = `
                    <button class="btn-info" onclick="editToClear('${item.id}')">✏️ Edit</button>
                    <button class="btn-danger" onclick="moveToRecycleBin('${item.id}', 'to_clear')">🗑️ Delete</button>
                `;
            });
        }

        function showAddToClearModal() {
            document.getElementById('toClearModalTitle').textContent = 'Add Product to Clear';
            document.getElementById('editToClearId').value = '';
            const form = document.getElementById('toClearModal').querySelector('form');
            if (form) form.reset();
            document.getElementById('toClearFirstHighlightedDate').valueAsDate = new Date();
            populateBrandDropdowns('toClearBrand');
            populateCategoryDropdowns('toClearCategory');
            filterProductsForBrand('', 'toClearProductName', 'toClearProductsDatalist');
            openModal('toClearModal');
        }

        async function saveToClear(event) {
            event.preventDefault();
            const id = document.getElementById('editToClearId').value;
            const brand = document.getElementById('toClearBrand').value;
            const productName = document.getElementById('toClearProductName').value;
            const skuValue = getSkuForProduct(brand, productName);

            if (!skuValue) {
                showNotification("Product not found in Master List. Please select a product from an existing brand or add it to Master List first.", "error");
                return;
            }
            
            const data = {
                brand: brand,
                product: productName,
                category: document.getElementById('toClearCategory').value,
                expiryDate: document.getElementById('toClearExpiryDate').value,
                firstHighlightedDate: document.getElementById('toClearFirstHighlightedDate').value,
                firstReportedBalance: parseInt(document.getElementById('toClearFirstReportedBalance').value || '0'),
                warehouseQty: parseInt(document.getElementById('toClearWarehouseQty').value || '0'),
                storeQty: parseInt(document.getElementById('toClearStoreQty').value || '0'),
                weeklyDemand: parseInt(document.getElementById('toClearWeeklyDemand').value || '0'),
                actionPlan: document.getElementById('toClearActionPlan').value,
                sku: skuValue, 
                isDeleted: false
            };

            try {
                await saveDataToFirestore(toClearColRef, id, data);
                showNotification('Product to clear saved successfully!', 'success');
                closeModal('toClearModal');
                await updateLocalData();
            } catch (e) {
                //error handled
            }
        }

        async function editToClear(id) {
            const item = toClearData.find(p => p.id === id);
            if (item) {
                document.getElementById('toClearModalTitle').textContent = 'Edit Product to Clear';
                document.getElementById('editToClearId').value = item.id;
                populateBrandDropdowns('toClearBrand');
                document.getElementById('toClearBrand').value = item.brand;
                filterProductsForBrand(item.brand, 'toClearProductName', 'toClearProductsDatalist');
                document.getElementById('toClearProductName').value = item.product;
                populateCategoryDropdowns('toClearCategory');
                document.getElementById('toClearCategory').value = item.category;
                document.getElementById('toClearExpiryDate').value = item.expiryDate;
                document.getElementById('toClearFirstHighlightedDate').value = item.firstHighlightedDate;
                document.getElementById('toClearFirstReportedBalance').value = item.firstReportedBalance;
                document.getElementById('toClearWarehouseQty').value = item.warehouseQty;
                document.getElementById('toClearStoreQty').value = item.storeQty;
                document.getElementById('toClearWeeklyDemand').value = item.weeklyDemand;
                document.getElementById('toClearActionPlan').value = item.actionPlan;
                openModal('toClearModal');
            }
        }

        function searchToClear(searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
            const baseData = toClearData.filter(item => !item.isDeleted);
            if (lowerCaseSearchTerm) {
                currentToClearViewData = baseData.filter(item =>
                    (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.category && item.category.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.actionPlan && item.actionPlan.toLowerCase().includes(lowerCaseSearchTerm))
                );
            } else {
                currentToClearViewData = baseData;
            }
            renderToClearItems();
        }

        function getSkuForProduct(brand, product) {
            const masterProduct = masterProductsData.find(item => !item.isDeleted && item.brand === brand && item.product === product);
            return masterProduct ? masterProduct.sku : '';
        }

        /**
         * Determines the CSS class for the supply status badge based on expiry and demand.
         * @param {object} item - The product item from toClearData.
         * @param {string} item.expiryDate - The expiry date in 'YYYY-MM-DD' format.
         * @param {number} item.warehouseQty - Quantity in warehouse.
         * @param {number} item.storeQty - Quantity in store.
         * @param {number} item.weeklyDemand - Weekly demand for the product.
         * @returns {string} The CSS class ('normal', 'alert-status', 'danger-status', 'info').
         */
        function getSupplyStatusClass(item) {
            const expiryDateStr = item.expiryDate;
            const warehouseQty = Number(item.warehouseQty) || 0;
            const storeQty = Number(item.storeQty) || 0;
            const weeklyDemand = Number(item.weeklyDemand) || 0;
            const totalQuantity = warehouseQty + storeQty;

            const today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize to start of day

            // Case 1: No Expiry Date
            if (!expiryDateStr) {
                return 'info'; // N/A
            }

            const expiryDate = new Date(expiryDateStr);
            expiryDate.setHours(0, 0, 0, 0); // Normalize to start of day

            // Case 2: Already Expired or Expires Today
            if (expiryDate <= today) {
                return 'danger-status'; // Expired
            }

            // Case 3: Zero Weekly Demand (but has expiry date and not expired)
            if (weeklyDemand <= 0) {
                return 'danger-status'; // Danger (won't sell out)
            }

            // Calculate Days to Sell Out
            const daysToSellOut = (totalQuantity / weeklyDemand) * 7;
            const projectedSellOutDate = new Date(today.getTime() + daysToSellOut * 24 * 60 * 60 * 1000);
            projectedSellOutDate.setHours(0, 0, 0, 0); // Normalize to start of day

            // Calculate thresholds for expiry
            const expiryDateMinus9Months = new Date(expiryDate);
            expiryDateMinus9Months.setMonth(expiryDateMinus9Months.getMonth() - 9);
            expiryDateMinus9Months.setHours(0, 0, 0, 0);

            const expiryDateMinus6Months = new Date(expiryDate);
            expiryDateMinus6Months.setMonth(expiryDateMinus6Months.getMonth() - 6);
            expiryDateMinus6Months.setHours(0, 0, 0, 0);

            // Determine status based on projected sell-out date vs expiry thresholds
            if (projectedSellOutDate <= expiryDateMinus9Months) {
                return 'normal'; // Normal: sells out 9 months or more before expiry
            } else if (projectedSellOutDate > expiryDateMinus9Months && projectedSellOutDate <= expiryDateMinus6Months) {
                return 'alert-status'; // Alert: sells out between 6 and 9 months before expiry
            } else {
                return 'danger-status'; // Danger: sells out less than 6 months before expiry, or after expiry
            }
        }

        /**
         * Determines the text for the supply status badge based on expiry and demand.
         * @param {object} item - The product item from toClearData.
         * @param {string} item.expiryDate - The expiry date in 'YYYY-MM-DD' format.
         * @param {number} item.warehouseQty - Quantity in warehouse.
         * @param {number} item.storeQty - Quantity in store.
         * @param {number} item.weeklyDemand - Weekly demand for the product.
         * @returns {string} The status text ('N/A', 'Expired', 'Danger', 'Alert', 'Normal').
         */
        function getSupplyStatusText(item) {
            const expiryDateStr = item.expiryDate;
            const warehouseQty = Number(item.warehouseQty) || 0;
            const storeQty = Number(item.storeQty) || 0;
            const weeklyDemand = Number(item.weeklyDemand) || 0;
            const totalQuantity = warehouseQty + storeQty;

            const today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize to start of day

            // Case 1: No Expiry Date
            if (!expiryDateStr) {
                return 'N/A';
            }

            const expiryDate = new Date(expiryDateStr);
            expiryDate.setHours(0, 0, 0, 0); // Normalize to start of day

            // Case 2: Already Expired or Expires Today
            if (expiryDate <= today) {
                return 'Expired';
            }

            // Case 3: Zero Weekly Demand (but has expiry date and not expired)
            if (weeklyDemand <= 0) {
                return 'Danger'; // Won't sell out before expiry
            }

            // Calculate Days to Sell Out
            const daysToSellOut = (totalQuantity / weeklyDemand) * 7;
            const projectedSellOutDate = new Date(today.getTime() + daysToSellOut * 24 * 60 * 60 * 1000);
            projectedSellOutDate.setHours(0, 0, 0, 0); // Normalize to start of day

            // Calculate thresholds for expiry
            const expiryDateMinus9Months = new Date(expiryDate);
            expiryDateMinus9Months.setMonth(expiryDateMinus9Months.getMonth() - 9);
            expiryDateMinus9Months.setHours(0, 0, 0, 0);

            const expiryDateMinus6Months = new Date(expiryDate);
            expiryDateMinus6Months.setMonth(expiryDateMinus6Months.getMonth() - 6);
            expiryDateMinus6Months.setHours(0, 0, 0, 0);

            // Determine status based on projected sell-out date vs expiry thresholds
            if (projectedSellOutDate <= expiryDateMinus9Months) {
                return 'Normal'; // Sells out 9 months or more before expiry
            } else if (projectedSellOutDate > expiryDateMinus9Months && projectedSellOutDate <= expiryDateMinus6Months) {
                return 'Alert'; // Sells out between 6 and 9 months before expiry
            } else {
                return 'Danger'; // Sells out less than 6 months before expiry, or after expiry
            }
        }


        // Master List
        function renderMasterListItems() {
            const tableBody = document.getElementById('master-table');
            if (!tableBody) return;
            tableBody.innerHTML = '';

            const sortedData = sortArray(currentMasterListViewData, sortState.master.column, sortState.master.direction);

            sortedData.forEach(item => {
                const row = tableBody.insertRow();
                row.insertCell().textContent = item.sku || '';
                row.insertCell().textContent = item.brand || '';
                row.insertCell().textContent = item.product || '';
                row.insertCell().textContent = item.category || '';
                row.insertCell().textContent = item.description || '';
                row.insertCell().textContent = item.price !== undefined ? parseFloat(item.price).toFixed(2) : '';

                const actionsCell = row.insertCell();
                actionsCell.innerHTML = `
                    <button class="btn-info" onclick="editMasterProduct('${item.id}')">✏️ Edit</button>
                    <button class="btn-danger" onclick="moveToRecycleBin('${item.id}', 'master_products')">🗑️ Delete</button>
                `;
            });
        }

        function showAddMasterProductModal() {
            document.getElementById('masterProductModalTitle').textContent = 'Add Master Product';
            document.getElementById('editMasterProductId').value = '';
            document.getElementById('masterProductModal').querySelector('form').reset();
            populateBrandDropdowns('masterBrand');
            populateCategoryDropdowns('category');
            openModal('masterProductModal');
        }

        async function saveMasterProduct(event) {
            event.preventDefault();
            const id = document.getElementById('editMasterProductId').value;
            const sku = document.getElementById('sku').value.trim();
            const productName = document.getElementById('masterProductName').value.trim();
            const brandName = document.getElementById('masterBrand').value;

            if (!sku) {
                showNotification('Product Code (SKU) is required.', 'error');
                return;
            }
            if (!productName) {
                showNotification('Product Name is required.', 'error');
                return;
            }
             if (!brandName) {
                showNotification('Brand is required.', 'error');
                return;
            }


            // Check for SKU uniqueness
            if (masterProductsData.some(p => p.sku === sku && p.id !== id && !p.isDeleted)) {
                showNotification('This SKU already exists for another product.', 'error');
                return;
            }
            // Optional: Check for Brand + Product Name uniqueness
            if (masterProductsData.some(p => p.brand === brandName && p.product === productName && p.id !== id && !p.isDeleted)) {
                 showNotification('This Brand and Product Name combination already exists.', 'error');
                return;
            }

            
            const data = {
                brand: brandName,
                product: productName,
                category: document.getElementById('category').value,
                description: document.getElementById('description').value,
                sku: sku,
                price: parseFloat(document.getElementById('price').value || '0'),
                isDeleted: false
            };

            try {
                await saveDataToFirestore(masterProductsColRef, id, data);
                showNotification('Master product saved successfully!', 'success');
                closeModal('masterProductModal');
                await updateLocalData();
            } catch (e) {
                //error handled
            }
        }

        async function editMasterProduct(id) {
            const item = masterProductsData.find(p => p.id === id);
            if (item) {
                document.getElementById('masterProductModalTitle').textContent = 'Edit Master Product';
                document.getElementById('editMasterProductId').value = item.id;
                populateBrandDropdowns('masterBrand');
                document.getElementById('masterBrand').value = item.brand;
                document.getElementById('masterProductName').value = item.product;
                populateCategoryDropdowns('category');
                document.getElementById('category').value = item.category;
                document.getElementById('description').value = item.description;
                document.getElementById('sku').value = item.sku;
                document.getElementById('price').value = item.price;
                openModal('masterProductModal');
            }
        }

        function searchMasterList(searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
            const baseData = masterProductsData.filter(item => !item.isDeleted);
            if (lowerCaseSearchTerm) {
                currentMasterListViewData = baseData.filter(item =>
                    (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.category && item.category.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.description && item.description.toLowerCase().includes(lowerCaseSearchTerm))
                );
            } else {
                currentMasterListViewData = baseData;
            }
            renderMasterListItems();
        }

        function exportMasterList() {
            const headers = ["Product Code", "Brand", "Product Name", "Category", "Description", "Price"];
            const activeMasterList = masterProductsData.filter(item => !item.isDeleted);
            const rows = activeMasterList.map(item => [
                item.sku || '',
                item.brand || '',
                item.product || '',
                item.category || '',
                item.description || '',
                item.price !== undefined ? parseFloat(item.price).toFixed(2) : ''
            ]);

            let csvContent = headers.join(',') + '\n';
            rows.forEach(row => {
                csvContent += row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',') + '\n';
            });

            downloadCSV(csvContent, 'master_list.csv');
            showNotification('Master list exported!', 'success');
        }

        // Recycle Bin
        function renderRecycleBinItems() {
            const tableBody = document.getElementById('recycle-bin-table');
            if (!tableBody) return;
            tableBody.innerHTML = '';

            const sortedData = sortArray(currentRecycleBinViewData, sortState.recycleBin.column, sortState.recycleBin.direction);

            sortedData.forEach(item => {
                const row = tableBody.insertRow();
                row.insertCell().textContent = item.sku || '';
                row.insertCell().textContent = item.originalCollection || '';
                row.insertCell().textContent = item.brand || '';
                row.insertCell().textContent = item.product || '';

                const actionsCell = row.insertCell();
                actionsCell.innerHTML = `
                    <button class="btn-success" onclick="restoreItem('${item.id}', '${item.originalCollection}')">↩️ Restore</button>
                    <button class="btn-danger" onclick="deleteItemPermanently('${item.id}', '${item.originalCollection}')">❌ Permanent Delete</button>
                `;
            });
        }

        async function moveToRecycleBin(id, collectionName) {
            showConfirmModal('Are you sure you want to move this item to Recycle Bin?', async (confirmed) => {
                if (confirmed) {
                    try {
                        const collectionRef = db.collection(collectionName);
                        await saveDataToFirestore(collectionRef, id, { isDeleted: true });
                        showNotification('Item moved to Recycle Bin!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error(`Error moving item to recycle bin from ${collectionName}:`, e);
                        showNotification('Error moving item to Recycle Bin.', 'error');
                    }
                }
            });
        }

        async function restoreItem(id, originalCollection) {
            showConfirmModal('Are you sure you want to restore this item?', async (confirmed) => {
                if (confirmed) {
                    try {
                        const itemToRestore = deletedItemsData.find(item => item.id === id && item.originalCollection === originalCollection);
                        if (!itemToRestore) {
                             showNotification('Item not found for restoration.', 'error');
                             return;
                        }

                        // Check for SKU conflict if restoring to master_products or new_products
                        if (originalCollection === 'master_products' || originalCollection === 'new_products') {
                            const sku = itemToRestore.sku;
                            if (sku) {
                                const skuExistsInMaster = masterProductsData.some(p => p.sku === sku && !p.isDeleted);
                                const skuExistsInNew = newProductsData.some(p => p.sku === sku && !p.isDeleted);
                                if ((originalCollection === 'master_products' && skuExistsInNew) || // Restoring to master, but SKU active in new
                                    (originalCollection === 'new_products' && skuExistsInMaster) || // Restoring to new, but SKU active in master
                                    (skuExistsInMaster && originalCollection !== 'master_products' && itemToRestore.originalCollection === 'master_products') || // trying to restore an already active master SKU
                                    (skuExistsInNew && originalCollection !== 'new_products' && itemToRestore.originalCollection === 'new_products') ) {
                                   // This logic is a bit complex, simplified: if SKU is active in its target destination, block.
                                }
                                if ( (originalCollection === 'master_products' && masterProductsData.some(p => p.sku === sku && !p.isDeleted && p.id !== id)) ||
                                     (originalCollection === 'new_products' && newProductsData.some(p => p.sku === sku && !p.isDeleted && p.id !== id)) ) {
                                     showNotification(`Cannot restore: SKU ${sku} already exists in an active item in ${originalCollection}. Please resolve conflict first.`, 'error');
                                     return;
                                }
                            }
                        }


                        const collectionRef = db.collection(originalCollection);
                        await saveDataToFirestore(collectionRef, id, { isDeleted: false });
                        showNotification('Item restored successfully!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error(`Error restoring item to ${originalCollection}:`, e);
                        showNotification('Error restoring item.', 'error');
                    }
                }
            });
        }

        async function deleteItemPermanently(id, originalCollection) {
            showConfirmModal('WARNING: This will permanently delete this item. Are you sure?', async (confirmed) => {
                if (confirmed) {
                    try {
                        const collectionRef = db.collection(originalCollection);
                        await collectionRef.doc(id).delete();
                        showNotification('Item permanently deleted!', 'success');
                        await updateLocalData();
                    } catch (e) {
                        console.error(`Error permanently deleting item from ${originalCollection}:`, e);
                        showNotification('Error permanently deleting item.', 'error');
                    }
                }
            });
        }

        async function emptyRecycleBin() {
            showConfirmModal('WARNING: This will permanently delete ALL items in the Recycle Bin. Are you sure?', async (confirmed) => {
                if (confirmed) {
                    if (deletedItemsData.length === 0) {
                        showNotification('Recycle Bin is already empty.', 'info');
                        return;
                    }
                    const batch = db.batch();
                    let deleteCount = 0;
                    for (const item of deletedItemsData) {
                        try {
                            const collectionRef = db.collection(item.originalCollection);
                            batch.delete(collectionRef.doc(item.id));
                            deleteCount++;
                        } catch (e) {
                            console.error(`Error adding item ${item.id} to batch for permanent deletion:`, e);
                        }
                    }

                    if (deleteCount > 0) {
                        try {
                            await batch.commit();
                            showNotification(`Successfully deleted ${deleteCount} items permanently.`, 'success');
                            await updateLocalData();
                        } catch (e) {
                            console.error("Batch commit for empty recycle bin failed:", e);
                            showNotification('Error emptying recycle bin.', 'error');
                        }
                    } else {
                         showNotification('No items were eligible for deletion, or an error occurred preparing deletions.', 'info');
                    }
                }
            });
        }

        function searchRecycleBin(searchTerm) {
            const lowerCaseSearchTerm = searchTerm.toLowerCase().trim();
             if (lowerCaseSearchTerm) {
                currentRecycleBinViewData = deletedItemsData.filter(item =>
                    (item.brand && item.brand.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.product && item.product.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.sku && item.sku.toLowerCase().includes(lowerCaseSearchTerm)) ||
                    (item.originalCollection && item.originalCollection.toLowerCase().includes(lowerCaseSearchTerm))
                );
            } else {
                currentRecycleBinViewData = [...deletedItemsData];
            }
            renderRecycleBinItems();
        }
        
        // Functions to show Add Brand/Status/Category Modals
        function showAddBrandModal() {
            document.getElementById('addBrandModal').querySelector('form').reset();
            openModal('addBrandModal');
        }

        function showAddStatusModal() {
            document.getElementById('addStatusModal').querySelector('form').reset();
            openModal('addStatusModal');
        }

        function showAddCategoryModal() {
            // Corrected the ID to 'addCategoryModal'
            document.getElementById('addCategoryModal').querySelector('form').reset();
            openModal('addCategoryModal');
        }

        // Functions to save New Brand/Status/Category
        async function saveNewBrand(event) {
            event.preventDefault();
            const newBrandNameInput = document.getElementById('newBrandName');
            const newBrandName = newBrandNameInput.value.trim();

            if (!newBrandName) {
                showNotification('Brand name cannot be empty.', 'error');
                return;
            }
            // Check against current brandsData (which should be non-deleted)
            if (brandsData.some(brand => brand.name.toLowerCase() === newBrandName.toLowerCase())) {
                showNotification('This brand already exists.', 'error');
                return;
            }
            try {
                await saveDataToFirestore(brandsColRef, null, { name: newBrandName, isDeleted: false }); // Ensure isDeleted: false
                showNotification('Brand added successfully!', 'success');
                closeModal('addBrandModal'); // This will also reset the form
                await updateLocalData(); 
            } catch (e) {
                showNotification('Error adding brand. Check console.', 'error');
                console.error("Error adding new brand:", e);
            }
        }

        async function saveNewStatus(event) {
            event.preventDefault();
            const newStatusNameInput = document.getElementById('newStatusName');
            const newStatusName = newStatusNameInput.value.trim();

            if (!newStatusName) {
                showNotification('Status name cannot be empty.', 'error');
                return;
            }
            if (statusesData.some(status => status.name.toLowerCase() === newStatusName.toLowerCase())) {
                showNotification('This status already exists.', 'error');
                return;
            }
            try {
                await saveDataToFirestore(statusesColRef, null, { name: newStatusName, isDeleted: false });
                showNotification('Status added successfully!', 'success');
                closeModal('addStatusModal');
                await updateLocalData();
            } catch (e) {
                showNotification('Error adding status. Check console.', 'error');
                console.error("Error adding new status:", e);
            }
        }

        async function saveNewCategory(event) {
            event.preventDefault();
            const newCategoryNameInput = document.getElementById('newCategoryName');
            const newCategoryName = newCategoryNameInput.value.trim();

            if (!newCategoryName) {
                showNotification('Category name cannot be empty.', 'error');
                return;
            }
            if (categoriesData.some(cat => cat.name.toLowerCase() === newCategoryName.toLowerCase())) {
                showNotification('This category already exists.', 'error');
                return;
            }
            try {
                await saveDataToFirestore(categoriesColRef, null, { name: newCategoryName, isDeleted: false });
                showNotification('Category added successfully!', 'success');
                closeModal('addCategoryModal');
                await updateLocalData();
            } catch (e) {
                showNotification('Error adding category. Check console.', 'error');
                console.error("Error adding new category:", e);
            }
        }


        // Management Tab Functions
        // Helper function to get data and headers for a specific table
        function getTableDataForExport(tableKey, dataArray) {
            let headers = [];
            let rows = [];

            if (tableKey === 'inventory') {
                headers = ["Product Code", "Brand", "Product", "Quantity", "Status", "Shipment", "Remarks"];
                rows = dataArray.filter(item => !item.isDeleted && (item.status === 'OOS' || (item.status && item.status.toLowerCase().includes('low stock')))).map(item => [
                    item.sku || '',
                    item.brand || '',
                    item.product || '',
                    item.quantity !== undefined ? item.quantity : '',
                    item.status || '',
                    item.shipment || '',
                    item.remarks || ''
                ]);
            } else if (tableKey === 'new_products') {
                headers = ["Product Code", "Brand", "Product", "Added Date", "Arrival Date", "Quantity", "Notes"];
                rows = dataArray.filter(item => !item.isDeleted).map(item => [
                    item.sku || '',
                    item.brand || '',
                    item.product || '',
                    item.addedDate || '',
                    item.arrivalDate || '',
                    item.quantity !== undefined ? item.quantity : '',
                    item.notes || ''
                ]);
            } else if (tableKey === 'to_clear') {
                headers = ["Product Code", "Brand", "Product", "Category", "Expiry Date", "First Highlighted", "Initial Bal", "WH Qty", "Store Qty", "Total Qty", "Wk Demand", "Wks Supply", "Supply Status", "Action Plan"];
                rows = dataArray.filter(item => !item.isDeleted).map(item => {
                    const totalQty = (Number(item.warehouseQty) || 0) + (Number(item.storeQty) || 0);
                    const weeksSupply = (Number(item.weeklyDemand) || 0) > 0 ? (totalQty / Number(item.weeklyDemand)).toFixed(2) : 'N/A';
                    const supplyStatusText = getSupplyStatusText(item); // Re-use existing function for status text
                    return [
                        item.sku || '',
                        item.brand || '',
                        item.product || '',
                        item.category || '',
                        item.expiryDate || '',
                        item.firstHighlightedDate || '',
                        item.firstReportedBalance !== undefined ? item.firstReportedBalance : '',
                        item.warehouseQty !== undefined ? item.warehouseQty : '',
                        item.storeQty !== undefined ? item.storeQty : '',
                        totalQty,
                        item.weeklyDemand !== undefined ? item.weeklyDemand : '',
                        weeksSupply,
                        supplyStatusText,
                        item.actionPlan || ''
                    ];
                });
            } else if (tableKey === 'master_products') {
                headers = ["Product Code", "Brand", "Product Name", "Category", "Description", "Price"];
                rows = dataArray.filter(item => !item.isDeleted).map(item => [
                    item.sku || '',
                    item.brand || '',
                    item.product || '',
                    item.category || '',
                    item.description || '',
                    item.price !== undefined ? parseFloat(item.price).toFixed(2) : ''
                ]);
            }
            return { headers, rows };
        }

        async function exportAllData() {
            if (typeof JSZip === 'undefined') {
                showNotification('Data export library (JSZip) is not loaded. Please try again in a moment or check console.', 'error');
                console.error('JSZip library not found for exportAllData.');
                return;
            }

            let zip = new JSZip();

            // Define the collections to export and their corresponding data arrays
            const collectionsToExport = [
                { key: 'inventory', data: inventoryData, fileName: 'oos_low_stock_products.csv' },
                { key: 'new_products', data: newProductsData, fileName: 'new_products.csv' },
                { key: 'to_clear', data: toClearData, fileName: 'to_clear_products.csv' },
                { key: 'master_products', data: masterProductsData, fileName: 'master_list.csv' }
            ];

            for (const collectionInfo of collectionsToExport) {
                const { headers, rows } = getTableDataForExport(collectionInfo.key, collectionInfo.data);
                
                if (rows.length === 0) {
                    console.log(`No data to export for ${collectionInfo.fileName}. Skipping.`);
                    continue;
                }

                let csvContent = headers.map(header => `"${String(header).replace(/"/g, '""')}"`).join(',') + '\n';
                rows.forEach(row => {
                    csvContent += row.map(field => `"${String(field !== undefined && field !== null ? field : '').replace(/"/g, '""')}"`).join(',') + '\n';
                });
                zip.file(collectionInfo.fileName, csvContent);
            }

            try {
                const content = await zip.generateAsync({ type: "blob" });
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'inventory_reports.zip'; // Changed zip file name
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a); 
                URL.revokeObjectURL(url);
                showNotification('Selected data exported as ZIP!', 'success');
            } catch (e) {
                console.error("Error generating zip file:", e);
                showNotification('Error exporting all data.', 'error');
            }
        }


        async function loadSampleData() {
            showNotification('Loading sample data... This may take a moment.', 'info');
            const sampleBrands = [
                { name: 'BrandX', isDeleted: false }, { name: 'BrandY', isDeleted: false }, { name: 'BrandZ', isDeleted: false },
                { name: 'BrandA', isDeleted: false }, { name: 'BrandB', isDeleted: false }, { name: 'BrandC', isDeleted: false }
            ];
            const sampleStatuses = [
                { name: 'OOS', isDeleted: false }, { name: 'Low stock', isDeleted: false }, { name: 'In stock', isDeleted: false }
            ];
            const sampleCategories = [
                { name: 'Electronics', isDeleted: false }, { name: 'Accessories', isDeleted: false },
                { name: 'Smart Home', isDeleted: false }, { name: 'Office Furniture', isDeleted: false }
            ];
            const sampleMasterProducts = [
                { brand: 'BrandX', product: 'Laptop Pro', sku: 'LX1001', category: 'Electronics', description: 'High performance laptop', price: 1200.00, isDeleted: false },
                { brand: 'BrandY', product: 'Wireless Mouse', sku: 'WM2002', category: 'Accessories', description: 'Ergonomic wireless mouse', price: 25.00, isDeleted: false },
                { brand: 'BrandX', product: 'Mechanical Keyboard', sku: 'MK3003', category: 'Accessories', description: 'RGB Mechanical Keyboard', price: 80.00, isDeleted: false },
                { brand: 'BrandZ', product: 'Smart Speaker', sku: 'SS4004', category: 'Smart Home', description: 'Voice activated smart speaker', price: 99.00, isDeleted: false },
                { brand: 'BrandA', product: 'Ergonomic Chair', sku: 'EC5005', category: 'Office Furniture', description: 'Adjustable ergonomic office chair', price: 350.00, isDeleted: false },
                { brand: 'BrandB', product: 'Old Stock Monitor', sku: 'OSM6006', category: 'Electronics', description: '1080p LED Monitor', price: 150.00, isDeleted: false },
                { brand: 'BrandC', product: 'Demo Unit Tablet', sku: 'DUT7007', category: 'Electronics', description: 'Compact Android Tablet', price: 100.00, isDeleted: false }
            ];
            const sampleInventory = [
                { brand: 'BrandX', product: 'Laptop Pro', sku: 'LX1001', quantity: 5, status: 'Low stock', expiry: '', shipment: 'SHP001', remarks: '', isDeleted: false },
                { brand: 'BrandY', product: 'Wireless Mouse', sku: 'WM2002', quantity: 0, status: 'OOS', expiry: '', shipment: 'SHP002', remarks: 'Awaiting restock', isDeleted: false },
                { brand: 'BrandX', product: 'Mechanical Keyboard', sku: 'MK3003', quantity: 20, status: 'In stock', expiry: '', shipment: 'SHP003', remarks: '', isDeleted: false }
            ];
            const sampleNewProducts = [
                { brand: 'BrandZ', product: 'Smart Speaker', sku: 'SS4004', arrivalDate: '2025-06-15', quantity: 50, notes: 'New model launch', addedDate: '2025-05-20', isDeleted: false },
                { brand: 'BrandA', product: 'Ergonomic Chair', sku: 'EC5005', arrivalDate: '2025-06-20', quantity: 15, notes: '', addedDate: '2025-05-25', isDeleted: false }
            ];
            const sampleToClear = [
                { brand: 'BrandB', product: 'Old Stock Monitor', sku: 'OSM6006', category: 'Electronics', expiryDate: '2025-07-31', firstHighlightedDate: '2025-05-01', firstReportedBalance: 20, warehouseQty: 10, storeQty: 5, weeklyDemand: 3, actionPlan: 'Promotional discount', isDeleted: false },
                { brand: 'BrandC', product: 'Demo Unit Tablet', sku: 'DUT7007', category: 'Electronics', expiryDate: '2025-08-30', firstHighlightedDate: '2025-05-10', firstReportedBalance: 5, warehouseQty: 1, storeQty: 2, weeklyDemand: 1, actionPlan: 'Clearance sale', isDeleted: false }
            ];
            
            const collectionsAndData = [
                { ref: brandsColRef, data: sampleBrands },
                { ref: statusesColRef, data: sampleStatuses },
                { ref: categoriesColRef, data: sampleCategories },
                { ref: masterProductsColRef, data: sampleMasterProducts },
                { ref: inventoryColRef, data: sampleInventory },
                { ref: newProductsColRef, data: sampleNewProducts },
                { ref: toClearColRef, data: sampleToClear }
            ];

            try {
                for (const { ref } of collectionsAndData) {
                    const snapshot = await ref.get();
                    const deleteBatch = db.batch();
                    snapshot.docs.forEach(doc => deleteBatch.delete(doc.ref));
                    if(snapshot.docs.length > 0) await deleteBatch.commit();
                }

                const loadBatch = db.batch();
                for (const { ref, data } of collectionsAndData) {
                    data.forEach(item => {
                        // For collections where we expect a specific ID (like master_products based on SKU for linking)
                        // this sample data uses auto-generated IDs. If specific IDs were needed, they'd be in the sample data.
                        const docRef = ref.doc(); 
                        loadBatch.set(docRef, item);
                    });
                }
                await loadBatch.commit();
                showNotification('Sample data loaded successfully!', 'success');
                await updateLocalData();
            } catch (e) {
                console.error("Error loading sample data:", e);
                showNotification('Error loading sample data. Check console.', 'error');
            }
        }


        function confirmLoadSampleData() {
            showConfirmModal('WARNING: This will delete ALL existing data and load sample data. Are you sure?', async (confirmed) => {
                if (confirmed) {
                    await loadSampleData();
                }
            });
        }

        // Sorting
        function sortTable(tableKey, column) {
            const tableSortState = sortState[tableKey];
            if (tableSortState.column === column) {
                tableSortState.direction = tableSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                tableSortState.column = column;
                tableSortState.direction = 'asc';
            }
            updateSortIndicators(tableKey);
            if (tableKey === 'inventory') renderInventoryItems();
            else if (tableKey === 'newProducts') renderNewProductsItems();
            else if (tableKey === 'master') renderMasterListItems();
            else if (tableKey === 'toClear') renderToClearItems();
            else if (tableKey === 'recycleBin') renderRecycleBinItems();
        }

        function sortArray(arr, column, direction) {
            if (!column || !arr) return arr || []; 

            return [...arr].sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                if (sortState.toClear.column === 'totalQty' && column === 'totalQty') {
                    valA = (Number(a.warehouseQty) || 0) + (Number(a.storeQty) || 0);
                    valB = (Number(b.warehouseQty) || 0) + (Number(b.storeQty) || 0);
                } else if (sortState.toClear.column === 'weeksSupply' && column === 'weeksSupply') {
                    const totalA = (Number(a.warehouseQty) || 0) + (Number(a.storeQty) || 0);
                    valA = (Number(a.weeklyDemand) || 0) > 0 ? (totalA / Number(a.weeklyDemand)) : (direction === 'asc' ? Infinity : -Infinity);
                    const totalB = (Number(b.warehouseQty) || 0) + (Number(b.storeQty) || 0);
                    valB = (Number(b.weeklyDemand) || 0) > 0 ? (totalB / Number(b.weeklyDemand)) : (direction === 'asc' ? Infinity : -Infinity);
                }

                const aUndefined = (valA === undefined || valA === null || valA === 'N/A' || (typeof valA === 'number' && isNaN(valA)) );
                const bUndefined = (valB === undefined || valB === null || valB === 'N/A' || (typeof valB === 'number' && isNaN(valB)) );

                if (aUndefined && bUndefined) return 0;
                if (aUndefined) return direction === 'asc' ? 1 : -1;
                if (bUndefined) return direction === 'asc' ? -1 : 1;


                if (typeof valA === 'string' && typeof valB === 'string') {
                     // Check for date strings (YYYY-MM-DD)
                    if (/^\d{4}-\d{2}-\d{2}$/.test(valA) && /^\d{4}-\d{2}-\d{2}$/.test(valB)) {
                        return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    }
                    // Check for numeric strings for locale-aware numeric sort if possible, otherwise standard string sort
                    const numA = parseFloat(valA);
                    const numB = parseFloat(valB);
                    if (!isNaN(numA) && !isNaN(numB) && String(numA) === valA && String(numB) === valB) { // Both are purely numeric strings
                         return direction === 'asc' ? numA - numB : numB - numA;
                    }
                    return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return direction === 'asc' ? valA - valB : valB - valA;
                }
                
                // Fallback for mixed types or other cases
                const strA = String(valA);
                const strB = String(valB);
                return direction === 'asc' ? strA.localeCompare(strB) : strB.localeCompare(strA);
            });
        }


        function updateSortIndicators(tableKey) {
            const tableContainer = document.getElementById(`${tableKey}-table-container`); 
            let headers;
            if (tableContainer) {
                headers = tableContainer.querySelectorAll('thead th[data-column-key]');
            } else { // Fallback for tables not wrapped in a specific *-table-container div
                const table = document.getElementById(`${tableKey}-table`) || // e.g. master-table
                              document.querySelector(`#${tableKey} table`);  // e.g. #dashboard table
                if (table) headers = table.querySelectorAll('thead th[data-column-key]');
                else return; // No table or headers found
            }
            
            headers.forEach(header => {
                const arrowSpan = header.querySelector('.sort-arrow');
                if (arrowSpan) arrowSpan.textContent = ''; 
                if (header.dataset.columnKey === sortState[tableKey].column) {
                    if (arrowSpan) arrowSpan.textContent = sortState[tableKey].direction === 'asc' ? ' ▲' : ' ▼';
                }
            });
        }


        // Dashboard Stats
        function updateDashboardStats() {
            document.getElementById('oos-count').textContent = inventoryData.filter(item => !item.isDeleted && item.status === 'OOS').length;
            document.getElementById('low-count').textContent = inventoryData.filter(item => !item.isDeleted && item.status && item.status.toLowerCase().includes('low stock')).length;
            document.getElementById('new-count').textContent = newProductsData.filter(item => !item.isDeleted).length;
        }

        function updateAlerts() {
            const alertsDiv = document.getElementById('alerts');
            alertsDiv.innerHTML = '';
            let alertContent = '';

            const recentOOS = inventoryData.filter(item => !item.isDeleted && item.status === 'OOS').slice(0, 5);
            const recentLowStock = inventoryData.filter(item => !item.isDeleted && item.status && item.status.toLowerCase().includes('low stock')).slice(0, 5);
            
            const today = new Date();
            today.setHours(0, 0, 0, 0); 
            const ninetyDaysFromToday = new Date(today);
            ninetyDaysFromToday.setDate(today.getDate() + 90);

            const expiringSoon = toClearData.filter(item => {
                if (!item.isDeleted && item.expiryDate) {
                    try {
                        const expiryParts = item.expiryDate.split('-');
                        const expiry = new Date(expiryParts[0], expiryParts[1] - 1, expiryParts[2]);
                        expiry.setHours(0,0,0,0);
                        return expiry >= today && expiry <= ninetyDaysFromToday;
                    } catch (e) { console.warn("Error parsing expiry date for alert:", item.expiryDate, e); return false; }
                }
                return false;
            }).sort((a,b) => new Date(a.expiryDate) - new Date(b.expiryDate)).slice(0, 5);


            if (recentOOS.length > 0) {
                alertContent += '<h4>Out of Stock Items:</h4><ul>' +
                    recentOOS.map(item => `<li><span class="status-badge oos">OOS</span> ${item.product || 'N/A'} (${item.brand || 'N/A'})</li>`).join('') +
                    '</ul>';
            }
            if (recentLowStock.length > 0) {
                alertContent += '<h4>Low Stock Items:</h4><ul>' +
                    recentLowStock.map(item => `<li><span class="status-badge low">Low</span> ${item.product || 'N/A'} (${item.brand || 'N/A'}) - Qty: ${item.quantity}</li>`).join('') +
                    '</ul>';
            }
            if (expiringSoon.length > 0) {
                alertContent += '<h4>Expiring Soon Items (within 90 days):</h4><ul>' +
                    expiringSoon.map(item => `<li><span class="status-badge alert-status">Expiring</span> ${item.product || 'N/A'} (${item.brand || 'N/A'}) - Expiry: ${item.expiryDate}</li>`).join('') +
                    '</ul>';
            }
            
            alertsDiv.innerHTML = alertContent || '<p>No immediate alerts.</p>';
        }

        function updateManagementStats() {
            const activeMasterProductsCount = masterProductsData.filter(item => !item.isDeleted).length;
            document.getElementById('total-products').textContent = activeMasterProductsCount;
            
            const allUniqueSkus = new Set(masterProductsData.filter(item => !item.isDeleted && item.sku).map(item => item.sku));
            document.getElementById('total-products-all').textContent = allUniqueSkus.size; 
            document.getElementById('last-updated').textContent = new Date().toLocaleString();
        }


        function downloadCSV(csvContent, fileName) {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', fileName);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link); 
                URL.revokeObjectURL(url);
            } else {
                showNotification('Your browser does not support downloading files directly.', 'error');
            }
        }

        async function importCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                const lines = text.split(/\r\n|\n/).filter(line => line.trim() !== ''); 
                if (lines.length < 2) { 
                    showNotification('CSV file is empty, invalid, or has no data rows.', 'error');
                    event.target.value = ''; 
                    return;
                }

                const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, '').toLowerCase()); 
                const requiredHeaders = ['product code', 'brand', 'product name']; 
                const missingHeaders = requiredHeaders.filter(rh => !headers.includes(rh));
                if (missingHeaders.length > 0) {
                    showNotification(`CSV missing required headers: ${missingHeaders.join(', ')}. Required: 'product code', 'brand', 'product name'.`, 'error');
                    event.target.value = '';
                    return;
                }
                
                const headerMap = {
                    'product code': 'sku', 'brand': 'brand', 'product name': 'product',
                    'category': 'category', 'description': 'description', 'price': 'price'
                };

                const importData = [];
                const importedSkusThisBatch = new Set(); // To check for duplicate SKUs within the CSV itself

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                    if (values.length !== headers.length) {
                        console.warn(`Skipping CSV row ${i + 1} due to column mismatch.`);
                        continue;
                    }
                    let item = { isDeleted: false }; 
                    let validRow = true;
                    let currentSku = '';

                    headers.forEach((header, index) => {
                        const fieldName = headerMap[header.toLowerCase()]; // Ensure mapping with lowercase header
                        if (fieldName) {
                            let value = values[index];
                            if (fieldName === 'price') item[fieldName] = parseFloat(value) || 0;
                            else if (fieldName === 'sku') {
                                currentSku = value.trim();
                                if (!currentSku) {
                                    console.warn(`Skipping CSV row ${i+1} due to missing SKU.`);
                                    validRow = false; 
                                } else {
                                    item[fieldName] = currentSku;
                                }
                            }
                            else item[fieldName] = value;
                        }
                    });

                    if (!item.brand || !item.product) { // Check for required brand and product name
                         console.warn(`Skipping CSV row ${i+1} due to missing Brand or Product Name.`);
                         validRow = false;
                    }

                    if (validRow && currentSku) {
                        if (importedSkusThisBatch.has(currentSku)) {
                            console.warn(`Skipping CSV row ${i+1}: Duplicate SKU '${currentSku}' within this CSV file.`);
                            validRow = false;
                        } else {
                            importedSkusThisBatch.add(currentSku);
                            importData.push(item);
                        }
                    }
                }

                if (importData.length === 0) {
                    showNotification('No valid data found to import from CSV after checks.', 'error');
                    event.target.value = '';
                    return;
                }

                showConfirmModal(`Found ${importData.length} valid items. Importing will add new items or update existing ones in Master List based on SKU. Continue?`, async (confirmed) => {
                    if (confirmed) {
                        const batch = db.batch();
                        let newItemsCount = 0;
                        let updatedItemsCount = 0;

                        for (const item of importData) {
                            try {
                                const existingProduct = masterProductsData.find(mp => mp.sku === item.sku && !mp.isDeleted);
                                if (existingProduct) { // Update existing
                                    const docRef = masterProductsColRef.doc(existingProduct.id);
                                    batch.set(docRef, item, { merge: true }); // Merge to update, keeps other fields if not in CSV
                                    updatedItemsCount++;
                                } else { // Add new
                                    const docRef = masterProductsColRef.doc(); 
                                    batch.set(docRef, item);
                                    newItemsCount++;
                                }
                            } catch (err) {
                                console.error("Error adding item to batch for import:", item, err);
                            }
                        }

                        if (newItemsCount > 0 || updatedItemsCount > 0) {
                            try {
                                await batch.commit();
                                showNotification(`Successfully imported: ${newItemsCount} new, ${updatedItemsCount} updated.`, 'success');
                                await updateLocalData();
                            } catch (err) {
                                console.error("Batch commit failed for import:", err);
                                showNotification('Error during CSV import batch commit.', 'error');
                            }
                        } else {
                            showNotification('No items were imported (perhaps all were duplicates or invalid).', 'info');
                        }
                    }
                    event.target.value = ''; 
                });
            };
            reader.onerror = () => {
                showNotification('Error reading CSV file.', 'error');
                event.target.value = '';
            };
            reader.readAsText(file);
        }


        window.onload = async function() {
            if (typeof JSZip === 'undefined') {
                console.log("JSZip not found, attempting to load...");
                const script = document.createElement('script');
                script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js";
                script.onload = async () => {
                    console.log("JSZip loaded successfully.");
                    await initializeApp();
                };
                script.onerror = () => {
                    console.error("Failed to load JSZip. Export all data may not work.");
                    initializeApp(); 
                };
                document.head.appendChild(script);
            } else {
                await initializeApp();
            }
        };

        async function initializeApp() {
            await updateLocalData();
            // Set the Dashboard tab as active on initial load
            const dashboardTabButton = document.querySelector('.tab[onclick*="dashboard"]');
            const dashboardContent = document.getElementById('dashboard');

            // Deactivate all tabs and content first
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            if (dashboardTabButton && dashboardContent) {
                dashboardTabButton.classList.add('active');
                dashboardContent.classList.add('active');
            } else { // Fallback
                const firstTab = document.querySelector('.tab');
                const firstContent = document.querySelector('.tab-content');
                if(firstTab) firstTab.classList.add('active');
                if(firstContent) firstContent.classList.add('active');
            }
            
            Object.keys(sortState).forEach(tableKey => updateSortIndicators(tableKey));
        }
    </script>
    </body>
</html>
